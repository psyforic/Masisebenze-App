/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.7.0 (NJsonSchema v9.13.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class ActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createActivityLog(input: CreateActivityLogInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/CreateActivityLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActivityLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActivityLog(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateActivityLog(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editActivityLog(input: ActivityLogDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/EditActivityLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditActivityLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditActivityLog(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditActivityLog(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<ActivityLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ActivityLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityLogListDto.fromJS(resultData200) : new ActivityLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityLogListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<ActivityLogDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<ActivityLogDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityLogDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<ActivityLogDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityLogDetailOutput.fromJS(resultData200) : new ActivityLogDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityLogDetailOutput>(<any>null);
    }
}

@Injectable()
export class AffectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createAsync(input: AffectDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Affect/CreateAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAsync(id: string | null | undefined): Observable<AffectDto> {
        let url_ = this.baseUrl + "/api/services/app/Affect/GetAsync?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAsync(<any>response_);
                } catch (e) {
                    return <Observable<AffectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AffectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAsync(response: HttpResponseBase): Observable<AffectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AffectDto.fromJS(resultData200) : new AffectDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AffectDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getByClientAsync(clientId: string | null | undefined): Observable<AffectDto> {
        let url_ = this.baseUrl + "/api/services/app/Affect/GetByClientAsync?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByClientAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByClientAsync(<any>response_);
                } catch (e) {
                    return <Observable<AffectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AffectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByClientAsync(response: HttpResponseBase): Observable<AffectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AffectDto.fromJS(resultData200) : new AffectDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AffectDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getListAsync(clientId: string | null | undefined): Observable<ListResultDtoOfAffectDto> {
        let url_ = this.baseUrl + "/api/services/app/Affect/GetListAsync?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAffectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAffectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetListAsync(response: HttpResponseBase): Observable<ListResultDtoOfAffectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAffectDto.fromJS(resultData200) : new ListResultDtoOfAffectDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAffectDto>(<any>null);
    }
}

@Injectable()
export class AssessmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @param identifiers (optional) 
     * @return Success
     */
    createPhysicalAssessmentTests(clientId: string | null | undefined, identifiers: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreatePhysicalAssessmentTests?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identifiers);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePhysicalAssessmentTests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePhysicalAssessmentTests(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePhysicalAssessmentTests(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createGripStrength(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateGripStrength?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGripStrength(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGripStrength(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateGripStrength(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createMusclePower(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateMusclePower?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMusclePower(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMusclePower(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMusclePower(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createGait(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateGait?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGait(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGait(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateGait(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createPosture(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreatePosture?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePosture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePosture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePosture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createBorgBalance(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateBorgBalance?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBorgBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBorgBalance(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBorgBalance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createSensation(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateSensation?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSensation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSensation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSensation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createCoordination(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateCoordination?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCoordination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCoordination(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCoordination(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createCoordinationIncomplete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateCoordinationIncomplete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCoordinationIncomplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCoordinationIncomplete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCoordinationIncomplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createRangeOfMotion(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateRangeOfMotion?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRangeOfMotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRangeOfMotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRangeOfMotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessments (optional) 
     * @return Success
     */
    addAssessments(clientId: string | null | undefined, assessments: AssessmentsListListDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/AddAssessments?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assessments);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAssessments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAssessments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddAssessments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSelectedPositionalToleranceAssessments(clientId: string | null | undefined): Observable<ListResultDtoOfAssessmentsListListDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetSelectedPositionalToleranceAssessments?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectedPositionalToleranceAssessments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectedPositionalToleranceAssessments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAssessmentsListListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAssessmentsListListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSelectedPositionalToleranceAssessments(response: HttpResponseBase): Observable<ListResultDtoOfAssessmentsListListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAssessmentsListListDto.fromJS(resultData200) : new ListResultDtoOfAssessmentsListListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAssessmentsListListDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSelectedRepetitiveToleranceAssessments(clientId: string | null | undefined): Observable<ListResultDtoOfAssessmentsListListDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetSelectedRepetitiveToleranceAssessments?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectedRepetitiveToleranceAssessments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectedRepetitiveToleranceAssessments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAssessmentsListListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAssessmentsListListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSelectedRepetitiveToleranceAssessments(response: HttpResponseBase): Observable<ListResultDtoOfAssessmentsListListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAssessmentsListListDto.fromJS(resultData200) : new ListResultDtoOfAssessmentsListListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAssessmentsListListDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param categoryId (optional) 
     * @return Success
     */
    getSelectedAssessments(clientId: string | null | undefined, categoryId: string | null | undefined): Observable<ListResultDtoOfAssessmentsListListDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetSelectedAssessments?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectedAssessments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectedAssessments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAssessmentsListListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAssessmentsListListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSelectedAssessments(response: HttpResponseBase): Observable<ListResultDtoOfAssessmentsListListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAssessmentsListListDto.fromJS(resultData200) : new ListResultDtoOfAssessmentsListListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAssessmentsListListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param status (optional) 
     * @return Success
     */
    updateAssessmentStatus(id: string | null | undefined, status: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdateAssessmentStatus?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssessmentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssessmentStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssessmentStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param categoryId (optional) 
     * @return Success
     */
    getcurrentAssessments(clientId: string | null | undefined, categoryId: string | null | undefined): Observable<ListResultDtoOfClientAssessmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetcurrentAssessments?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcurrentAssessments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcurrentAssessments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfClientAssessmentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfClientAssessmentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetcurrentAssessments(response: HttpResponseBase): Observable<ListResultDtoOfClientAssessmentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfClientAssessmentDto.fromJS(resultData200) : new ListResultDtoOfClientAssessmentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfClientAssessmentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param identifier (optional) 
     * @return Success
     */
    getAssessmentStatus(clientId: string | null | undefined, identifier: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetAssessmentStatus?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssessmentStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssessmentStatus(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssessmentStatus(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class AttorneyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createAttorney(input: CreateAttorneyInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/CreateAttorney";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAttorney(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAttorney(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAttorney(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfAttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAttorneyListDto.fromJS(resultData200) : new PagedResultDtoOfAttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAttorneyListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editAttorney(input: AttorneyDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/EditAttorney";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditAttorney(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditAttorney(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditAttorney(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<AttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<AttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttorneyListDto.fromJS(resultData200) : new AttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttorneyListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<AttorneyDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<AttorneyDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttorneyDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<AttorneyDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttorneyDetailOutput.fromJS(resultData200) : new AttorneyDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttorneyDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    search(input: string | null | undefined): Observable<ListResultDtoOfAttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/Search?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListResultDtoOfAttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAttorneyListDto.fromJS(resultData200) : new ListResultDtoOfAttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAttorneyListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<AttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttorneyListDto.fromJS(resultData200) : new AttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttorneyListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateAttorneyInput | null | undefined): Observable<AttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttorneyListDto.fromJS(resultData200) : new AttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttorneyListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: AttorneyListDto | null | undefined): Observable<AttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttorneyListDto.fromJS(resultData200) : new AttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttorneyListDto>(<any>null);
    }
}

@Injectable()
export class BalanceProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    create(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BalanceProtocol/Create?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfBalanceProtocolOptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/BalanceProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBalanceProtocolOptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBalanceProtocolOptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfBalanceProtocolOptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfBalanceProtocolOptionListDto.fromJS(resultData200) : new ListResultDtoOfBalanceProtocolOptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBalanceProtocolOptionListDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getBalanceProtocol(clientId: string | null | undefined): Observable<BalanceProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/BalanceProtocol/GetBalanceProtocol?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalanceProtocol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalanceProtocol(<any>response_);
                } catch (e) {
                    return <Observable<BalanceProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BalanceProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBalanceProtocol(response: HttpResponseBase): Observable<BalanceProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BalanceProtocolDto.fromJS(resultData200) : new BalanceProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceProtocolDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateTestStatus(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BalanceProtocol/UpdateTestStatus?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTestStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTestStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTestStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param balanceProtocolOptionId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(clientId: string | null | undefined, balanceProtocolOptionId: string | null | undefined, input: BalanceProtocolOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BalanceProtocol/Update?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (balanceProtocolOptionId !== undefined)
            url_ += "BalanceProtocolOptionId=" + encodeURIComponent("" + balanceProtocolOptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BilateralTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: BilateralTestCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BilateralTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfBilateralTestDto> {
        let url_ = this.baseUrl + "/api/services/app/BilateralTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBilateralTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBilateralTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfBilateralTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfBilateralTestDto.fromJS(resultData200) : new ListResultDtoOfBilateralTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBilateralTestDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getBilateralCarry(clientId: string | null | undefined): Observable<BilateralDto> {
        let url_ = this.baseUrl + "/api/services/app/BilateralTest/GetBilateralCarry?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBilateralCarry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBilateralCarry(<any>response_);
                } catch (e) {
                    return <Observable<BilateralDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BilateralDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBilateralCarry(response: HttpResponseBase): Observable<BilateralDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BilateralDto.fromJS(resultData200) : new BilateralDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BilateralDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<BilateralTestDto> {
        let url_ = this.baseUrl + "/api/services/app/BilateralTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<BilateralTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BilateralTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<BilateralTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BilateralTestDto.fromJS(resultData200) : new BilateralTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BilateralTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BilateralTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param bilateralId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(bilateralId: string | null | undefined, input: BilateralTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BilateralTest/Update?";
        if (bilateralId !== undefined)
            url_ += "bilateralId=" + encodeURIComponent("" + bilateralId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BookingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createBooking(input: CreateBookingInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Booking/CreateBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBooking(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBooking(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editBooking(input: BookingDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Booking/EditBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditBooking(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditBooking(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<BookingDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<BookingDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookingDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<BookingDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BookingDetailOutput.fromJS(resultData200) : new BookingDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookingDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<BookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<BookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<BookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BookingListDto.fromJS(resultData200) : new BookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookingListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getBookings(input: any | null | undefined): Observable<ListResultDtoOfBookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetBookings?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBookings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBookings(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBookings(response: HttpResponseBase): Observable<ListResultDtoOfBookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfBookingListDto.fromJS(resultData200) : new ListResultDtoOfBookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBookingListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createEvent(input: CreateEventInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Booking/CreateEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEvent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEvent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllEvents(input: any | null | undefined): Observable<ListResultDtoOfEventListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetAllEvents?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEvents(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEventListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEventListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEvents(response: HttpResponseBase): Observable<ListResultDtoOfEventListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEventListDto.fromJS(resultData200) : new ListResultDtoOfEventListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEventListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEventDetail(id: number | null | undefined): Observable<EventDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetEventDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventDetail(<any>response_);
                } catch (e) {
                    return <Observable<EventDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEventDetail(response: HttpResponseBase): Observable<EventDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EventDetailOutput.fromJS(resultData200) : new EventDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getEventById(input: number | null | undefined): Observable<EventListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetEventById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventById(<any>response_);
                } catch (e) {
                    return <Observable<EventListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEventById(response: HttpResponseBase): Observable<EventListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EventListDto.fromJS(resultData200) : new EventListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserBookings(id: string | null | undefined): Observable<ListResultDtoOfBookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetUserBookings?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserBookings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserBookings(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserBookings(response: HttpResponseBase): Observable<ListResultDtoOfBookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfBookingListDto.fromJS(resultData200) : new ListResultDtoOfBookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBookingListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<BookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<BookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BookingListDto.fromJS(resultData200) : new BookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookingListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfBookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBookingListDto.fromJS(resultData200) : new PagedResultDtoOfBookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBookingListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateBookingInput | null | undefined): Observable<BookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<BookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BookingListDto.fromJS(resultData200) : new BookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookingListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: BookingListDto | null | undefined): Observable<BookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<BookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BookingListDto.fromJS(resultData200) : new BookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookingListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Booking/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BorgBalanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param borgBalanceOptionId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateBorgBalanceOption(borgBalanceOptionId: string | null | undefined, input: BorgBalanceOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BorgBalance/UpdateBorgBalanceOption?";
        if (borgBalanceOptionId !== undefined)
            url_ += "borgBalanceOptionId=" + encodeURIComponent("" + borgBalanceOptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBorgBalanceOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBorgBalanceOption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBorgBalanceOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getBorgBalance(clientId: string | null | undefined): Observable<ListResultDtoOfBorgBalanceOptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/BorgBalance/GetBorgBalance?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBorgBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBorgBalance(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBorgBalanceOptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBorgBalanceOptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBorgBalance(response: HttpResponseBase): Observable<ListResultDtoOfBorgBalanceOptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfBorgBalanceOptionListDto.fromJS(resultData200) : new ListResultDtoOfBorgBalanceOptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBorgBalanceOptionListDto>(<any>null);
    }
}

@Injectable()
export class CalculationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param age (optional) 
     * @param gender (optional) 
     * @param side (optional) 
     * @param weight (optional) 
     * @param machineTest (optional) 
     * @return Success
     */
    getGripStrengthResults(age: number | null | undefined, gender: number | null | undefined, side: number | null | undefined, weight: number | null | undefined, machineTest: number | null | undefined): Observable<AssessmentResult> {
        let url_ = this.baseUrl + "/api/services/app/Calculations/GetGripStrengthResults?";
        if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&"; 
        if (gender !== undefined)
            url_ += "Gender=" + encodeURIComponent("" + gender) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        if (weight !== undefined)
            url_ += "Weight=" + encodeURIComponent("" + weight) + "&"; 
        if (machineTest !== undefined)
            url_ += "MachineTest=" + encodeURIComponent("" + machineTest) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGripStrengthResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGripStrengthResults(<any>response_);
                } catch (e) {
                    return <Observable<AssessmentResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssessmentResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGripStrengthResults(response: HttpResponseBase): Observable<AssessmentResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssessmentResult.fromJS(resultData200) : new AssessmentResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssessmentResult>(<any>null);
    }

    /**
     * @param seconds (optional) 
     * @param type (optional) 
     * @return Success
     */
    getCoordinationCompleteResults(seconds: number | null | undefined, type: number | null | undefined): Observable<AssessmentResult> {
        let url_ = this.baseUrl + "/api/services/app/Calculations/GetCoordinationCompleteResults?";
        if (seconds !== undefined)
            url_ += "Seconds=" + encodeURIComponent("" + seconds) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoordinationCompleteResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoordinationCompleteResults(<any>response_);
                } catch (e) {
                    return <Observable<AssessmentResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssessmentResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoordinationCompleteResults(response: HttpResponseBase): Observable<AssessmentResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssessmentResult.fromJS(resultData200) : new AssessmentResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssessmentResult>(<any>null);
    }
}

@Injectable()
export class ClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createClient(input: CreateClientInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/CreateClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClient(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateClient(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editClient(input: ClientDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/EditClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditClient(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditClient(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param url (optional) 
     * @return Success
     */
    updateProfilePic(id: string | null | undefined, url: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/UpdateProfilePic?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (url !== undefined)
            url_ += "url=" + encodeURIComponent("" + url) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePic(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePic(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfClientListDto.fromJS(resultData200) : new PagedResultDtoOfClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfClientListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<ClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientListDto.fromJS(resultData200) : new ClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListDto>(<any>null);
    }

    /**
     * @param attorneyId (optional) 
     * @param contactId (optional) 
     * @return Success
     */
    getByContactAttorneyId(attorneyId: string | null | undefined, contactId: string | null | undefined): Observable<ListResultDtoOfClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetByContactAttorneyId?";
        if (attorneyId !== undefined)
            url_ += "AttorneyId=" + encodeURIComponent("" + attorneyId) + "&"; 
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByContactAttorneyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByContactAttorneyId(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByContactAttorneyId(response: HttpResponseBase): Observable<ListResultDtoOfClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfClientListDto.fromJS(resultData200) : new ListResultDtoOfClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfClientListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<ClientDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<ClientDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<ClientDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientDetailOutput.fromJS(resultData200) : new ClientDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createWorkHistory(input: CreateWorkHistoryInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/CreateWorkHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWorkHistory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateWorkHistory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkHistoryDetail(id: string | null | undefined): Observable<WorkHistoryDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetWorkHistoryDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkHistoryDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistoryDetail(<any>response_);
                } catch (e) {
                    return <Observable<WorkHistoryDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkHistoryDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkHistoryDetail(response: HttpResponseBase): Observable<WorkHistoryDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkHistoryDetailOutput.fromJS(resultData200) : new WorkHistoryDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkHistoryDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getWorkHistoryByClientId(input: string | null | undefined): Observable<WorkHistoryListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetWorkHistoryByClientId?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkHistoryByClientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistoryByClientId(<any>response_);
                } catch (e) {
                    return <Observable<WorkHistoryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkHistoryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkHistoryByClientId(response: HttpResponseBase): Observable<WorkHistoryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkHistoryListDto.fromJS(resultData200) : new WorkHistoryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkHistoryListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editWorkHistory(input: WorkHistoryDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/EditWorkHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditWorkHistory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditWorkHistory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createMedicalHistory(input: CreateMedicalHistoryInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/CreateMedicalHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMedicalHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMedicalHistory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMedicalHistory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMedicalHistoryDetail(id: string | null | undefined): Observable<MedicalHistoryDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetMedicalHistoryDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedicalHistoryDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedicalHistoryDetail(<any>response_);
                } catch (e) {
                    return <Observable<MedicalHistoryDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicalHistoryDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedicalHistoryDetail(response: HttpResponseBase): Observable<MedicalHistoryDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MedicalHistoryDetailOutput.fromJS(resultData200) : new MedicalHistoryDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicalHistoryDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getMedicalHistoryByClientId(input: string | null | undefined): Observable<MedicalHistoryListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetMedicalHistoryByClientId?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedicalHistoryByClientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedicalHistoryByClientId(<any>response_);
                } catch (e) {
                    return <Observable<MedicalHistoryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicalHistoryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedicalHistoryByClientId(response: HttpResponseBase): Observable<MedicalHistoryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MedicalHistoryListDto.fromJS(resultData200) : new MedicalHistoryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicalHistoryListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editMedicalHistory(input: MedicalHistoryDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/EditMedicalHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditMedicalHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditMedicalHistory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditMedicalHistory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clientSearch(input: string | null | undefined): Observable<ListResultDtoOfClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/ClientSearch?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClientSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClientSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processClientSearch(response: HttpResponseBase): Observable<ListResultDtoOfClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfClientListDto.fromJS(resultData200) : new ListResultDtoOfClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfClientListDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param contactId (optional) 
     * @return Success
     */
    resendEmail(clientId: string | null | undefined, contactId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/ResendEmail?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResendEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<ClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientListDto.fromJS(resultData200) : new ClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateClientInput | null | undefined): Observable<ClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientListDto.fromJS(resultData200) : new ClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: ClientListDto | null | undefined): Observable<ClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientListDto.fromJS(resultData200) : new ClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListDto>(<any>null);
    }
}

@Injectable()
export class ClientAssessmentReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @param gender (optional) 
     * @param age (optional) 
     * @return Success
     */
    getAssessmentReport(clientId: string | null | undefined, gender: number | null | undefined, age: number | null | undefined): Observable<AssessmentReportDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetAssessmentReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (gender !== undefined)
            url_ += "Gender=" + encodeURIComponent("" + gender) + "&"; 
        if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssessmentReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssessmentReport(<any>response_);
                } catch (e) {
                    return <Observable<AssessmentReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssessmentReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssessmentReport(response: HttpResponseBase): Observable<AssessmentReportDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssessmentReportDto.fromJS(resultData200) : new AssessmentReportDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssessmentReportDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getBalanceProtocolReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetBalanceProtocolReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalanceProtocolReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalanceProtocolReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetBalanceProtocolReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getBorgBalanceReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetBorgBalanceReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBorgBalanceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBorgBalanceReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetBorgBalanceReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getCoordinationReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetCoordinationReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoordinationReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoordinationReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoordinationReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getCrawlingProtocolReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetCrawlingProtocolReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCrawlingProtocolReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCrawlingProtocolReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCrawlingProtocolReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getGaitReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetGaitReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGaitReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGaitReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetGaitReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param age (optional) 
     * @param gender (optional) 
     * @return Success
     */
    getGripStrengthReport(clientId: string | null | undefined, age: number | null | undefined, gender: number | null | undefined): Observable<ReportGripStrength> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetGripStrengthReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&"; 
        if (gender !== undefined)
            url_ += "Gender=" + encodeURIComponent("" + gender) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGripStrengthReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGripStrengthReport(<any>response_);
                } catch (e) {
                    return <Observable<ReportGripStrength>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportGripStrength>><any>_observableThrow(response_);
        }));
    }

    protected processGetGripStrengthReport(response: HttpResponseBase): Observable<ReportGripStrength> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReportGripStrength.fromJS(resultData200) : new ReportGripStrength();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportGripStrength>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getLadderWorkProtocolReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetLadderWorkProtocolReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLadderWorkProtocolReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLadderWorkProtocolReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetLadderWorkProtocolReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getMusclePowerReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetMusclePowerReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMusclePowerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMusclePowerReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetMusclePowerReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPostureReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetPostureReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostureReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostureReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPostureReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRepetitiveFootMotionProtocolReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetRepetitiveFootMotionProtocolReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepetitiveFootMotionProtocolReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepetitiveFootMotionProtocolReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepetitiveFootMotionProtocolReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRepetitiveSquattingProtocolReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetRepetitiveSquattingProtocolReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepetitiveSquattingProtocolReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepetitiveSquattingProtocolReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepetitiveSquattingProtocolReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRoMAnkleReport(clientId: string | null | undefined): Observable<ReportRoMAnkleDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetRoMAnkleReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoMAnkleReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoMAnkleReport(<any>response_);
                } catch (e) {
                    return <Observable<ReportRoMAnkleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportRoMAnkleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoMAnkleReport(response: HttpResponseBase): Observable<ReportRoMAnkleDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReportRoMAnkleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportRoMAnkleDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRoMElbowReport(clientId: string | null | undefined): Observable<ReportRoMElbowDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetRoMElbowReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoMElbowReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoMElbowReport(<any>response_);
                } catch (e) {
                    return <Observable<ReportRoMElbowDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportRoMElbowDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoMElbowReport(response: HttpResponseBase): Observable<ReportRoMElbowDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReportRoMElbowDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportRoMElbowDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRoMForearmWristReport(clientId: string | null | undefined): Observable<ReportRoMForearmWristDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetRoMForearmWristReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoMForearmWristReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoMForearmWristReport(<any>response_);
                } catch (e) {
                    return <Observable<ReportRoMForearmWristDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportRoMForearmWristDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoMForearmWristReport(response: HttpResponseBase): Observable<ReportRoMForearmWristDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReportRoMForearmWristDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportRoMForearmWristDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRoMHandReport(clientId: string | null | undefined): Observable<ReportRoMHandDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetRoMHandReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoMHandReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoMHandReport(<any>response_);
                } catch (e) {
                    return <Observable<ReportRoMHandDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportRoMHandDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoMHandReport(response: HttpResponseBase): Observable<ReportRoMHandDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReportRoMHandDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportRoMHandDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRoMHipReport(clientId: string | null | undefined): Observable<ReportRoMHipDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetRoMHipReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoMHipReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoMHipReport(<any>response_);
                } catch (e) {
                    return <Observable<ReportRoMHipDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportRoMHipDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoMHipReport(response: HttpResponseBase): Observable<ReportRoMHipDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReportRoMHipDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportRoMHipDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRoMKneeReport(clientId: string | null | undefined): Observable<ReportRoMKneeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetRoMKneeReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoMKneeReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoMKneeReport(<any>response_);
                } catch (e) {
                    return <Observable<ReportRoMKneeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportRoMKneeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoMKneeReport(response: HttpResponseBase): Observable<ReportRoMKneeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReportRoMKneeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportRoMKneeDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRoMShoulderReport(clientId: string | null | undefined): Observable<ReportRoMShoulderDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetRoMShoulderReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoMShoulderReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoMShoulderReport(<any>response_);
                } catch (e) {
                    return <Observable<ReportRoMShoulderDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportRoMShoulderDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoMShoulderReport(response: HttpResponseBase): Observable<ReportRoMShoulderDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ReportRoMShoulderDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportRoMShoulderDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSensationLowerReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetSensationLowerReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSensationLowerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSensationLowerReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSensationLowerReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSensationTrunkReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetSensationTrunkReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSensationTrunkReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSensationTrunkReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSensationTrunkReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSensationUpperReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetSensationUpperReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSensationUpperReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSensationUpperReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSensationUpperReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getStairClimbingProtocolReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetStairClimbingProtocolReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStairClimbingProtocolReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStairClimbingProtocolReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetStairClimbingProtocolReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getWalkingProtocolReport(clientId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ClientAssessmentReport/GetWalkingProtocolReport?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWalkingProtocolReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWalkingProtocolReport(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetWalkingProtocolReport(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class CognitiveServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param identifiers (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    create(identifiers: number[] | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/Create?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identifiers);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createAttentionAndConcentration(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateAttentionAndConcentration?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAttentionAndConcentration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAttentionAndConcentration(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAttentionAndConcentration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getAttentionAndConcentration(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetAttentionAndConcentration?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttentionAndConcentration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttentionAndConcentration(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAttentionAndConcentration(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAttentionAndConcentration(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateAttentionAndConcentration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAttentionAndConcentration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAttentionAndConcentration(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAttentionAndConcentration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param attentionAndConcentrationId (optional) 
     * @return Success
     */
    deleteAttentionAndConcentration(attentionAndConcentrationId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteAttentionAndConcentration?";
        if (attentionAndConcentrationId !== undefined)
            url_ += "attentionAndConcentrationId=" + encodeURIComponent("" + attentionAndConcentrationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAttentionAndConcentration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAttentionAndConcentration(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAttentionAndConcentration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createComprehension(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateComprehension?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateComprehension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateComprehension(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateComprehension(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getComprehension(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetComprehension?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetComprehension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComprehension(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetComprehension(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateComprehension(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateComprehension";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateComprehension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateComprehension(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateComprehension(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param comprehensionId (optional) 
     * @return Success
     */
    deleteComprehension(comprehensionId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteComprehension?";
        if (comprehensionId !== undefined)
            url_ += "comprehensionId=" + encodeURIComponent("" + comprehensionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteComprehension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteComprehension(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteComprehension(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createNaming(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateNaming?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNaming(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNaming(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateNaming(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateNaming(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateNaming";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNaming(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNaming(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNaming(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getNaming(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetNaming?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNaming(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNaming(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNaming(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param namingId (optional) 
     * @return Success
     */
    deleteNaming(namingId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteNaming?";
        if (namingId !== undefined)
            url_ += "namingId=" + encodeURIComponent("" + namingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNaming(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNaming(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNaming(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createImageComprehension(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateImageComprehension?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateImageComprehension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateImageComprehension(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateImageComprehension(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateImageComprehension(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateImageComprehension";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateImageComprehension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateImageComprehension(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateImageComprehension(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getImageComprehension(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetImageComprehension?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageComprehension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageComprehension(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetImageComprehension(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param imageComprehensionId (optional) 
     * @return Success
     */
    deleteImageComprehension(imageComprehensionId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteImageComprehension?";
        if (imageComprehensionId !== undefined)
            url_ += "imageComprehensionId=" + encodeURIComponent("" + imageComprehensionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImageComprehension(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImageComprehension(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteImageComprehension(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createReading(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateReading?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReading(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReading(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateReading(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateReading(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateReading";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReading(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReading(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateReading(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getReading(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetReading?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReading(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReading(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReading(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param readingId (optional) 
     * @return Success
     */
    deleteReading(readingId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteReading?";
        if (readingId !== undefined)
            url_ += "readingId=" + encodeURIComponent("" + readingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteReading(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReading(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteReading(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createRepetition(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateRepetition?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRepetition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRepetition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRepetition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateRepetition(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateRepetition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRepetition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRepetition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRepetition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRepetition(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetRepetition?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepetition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepetition(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepetition(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param repetitionId (optional) 
     * @return Success
     */
    deleteRepetition(repetitionId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteRepetition?";
        if (repetitionId !== undefined)
            url_ += "repetitionId=" + encodeURIComponent("" + repetitionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRepetition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRepetition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRepetition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createWriting(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateWriting?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWriting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWriting(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateWriting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateWriting(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateWriting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWriting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWriting(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateWriting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getWriting(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetWriting?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWriting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWriting(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWriting(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param writingId (optional) 
     * @return Success
     */
    deleteWriting(writingId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteWriting?";
        if (writingId !== undefined)
            url_ += "writingId=" + encodeURIComponent("" + writingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWriting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWriting(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWriting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createMemory(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateMemory?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMemory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMemory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMemory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateMemory(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateMemory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMemory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMemory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMemory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getMemory(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetMemory?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemory(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemory(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param memoryId (optional) 
     * @return Success
     */
    deleteMemory(memoryId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteMemory?";
        if (memoryId !== undefined)
            url_ += "memoryId=" + encodeURIComponent("" + memoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMemory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMemory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMemory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createOrientation(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateOrientation?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrientation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrientation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrientation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateOrientation(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateOrientation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrientation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrientation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrientation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getOrientation(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetOrientation?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrientation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrientation(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrientation(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param orientationId (optional) 
     * @return Success
     */
    deleteOrientation(orientationId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteOrientation?";
        if (orientationId !== undefined)
            url_ += "orientationId=" + encodeURIComponent("" + orientationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrientation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrientation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrientation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createPerceptualAbility(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreatePerceptualAbility?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePerceptualAbility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePerceptualAbility(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePerceptualAbility(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updatePerceptualAbility(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdatePerceptualAbility";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePerceptualAbility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePerceptualAbility(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePerceptualAbility(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPerceptualAbility(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetPerceptualAbility?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerceptualAbility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerceptualAbility(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerceptualAbility(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param perceptualAbilityId (optional) 
     * @return Success
     */
    deletePerceptualAbility(perceptualAbilityId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeletePerceptualAbility?";
        if (perceptualAbilityId !== undefined)
            url_ += "perceptualAbilityId=" + encodeURIComponent("" + perceptualAbilityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerceptualAbility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerceptualAbility(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerceptualAbility(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createRegistration(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateRegistration?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRegistration(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRegistration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateRegistration(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRegistration(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRegistration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRegistration(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetRegistration?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegistration(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegistration(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param registrationId (optional) 
     * @return Success
     */
    deleteRegistration(registrationId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteRegistration?";
        if (registrationId !== undefined)
            url_ += "registrationId=" + encodeURIComponent("" + registrationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegistration(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRegistration(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createVerbalFluency(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateVerbalFluency?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVerbalFluency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVerbalFluency(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateVerbalFluency(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateVerbalFulency(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateVerbalFulency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVerbalFulency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVerbalFulency(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateVerbalFulency(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getVerbalFluency(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetVerbalFluency?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVerbalFluency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVerbalFluency(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVerbalFluency(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param verbalFluencyId (optional) 
     * @return Success
     */
    deleteVerbalFluency(verbalFluencyId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteVerbalFluency?";
        if (verbalFluencyId !== undefined)
            url_ += "verbalFluencyId=" + encodeURIComponent("" + verbalFluencyId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVerbalFluency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVerbalFluency(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteVerbalFluency(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createVirtualPerception(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateVirtualPerception?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVirtualPerception(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVirtualPerception(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateVirtualPerception(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateVirtualPerception(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateVirtualPerception";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVirtualPerception(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVirtualPerception(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateVirtualPerception(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getVirtualPerception(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetVirtualPerception?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVirtualPerception(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVirtualPerception(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVirtualPerception(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param virtualPerceptionId (optional) 
     * @return Success
     */
    deleteVirtualPerception(virtualPerceptionId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteVirtualPerception?";
        if (virtualPerceptionId !== undefined)
            url_ += "virtualPerceptionId=" + encodeURIComponent("" + virtualPerceptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVirtualPerception(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVirtualPerception(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteVirtualPerception(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param identifier (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createVisuoSpatialAbility(identifier: number | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/CreateVisuoSpatialAbility?";
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVisuoSpatialAbility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVisuoSpatialAbility(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateVisuoSpatialAbility(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateVisuoSpatialAbility(input: OptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateVisuoSpatialAbility";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVisuoSpatialAbility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVisuoSpatialAbility(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateVisuoSpatialAbility(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getVisuoSpatialAbility(clientId: string | null | undefined): Observable<CognitiveParentDto> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/GetVisuoSpatialAbility?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVisuoSpatialAbility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVisuoSpatialAbility(<any>response_);
                } catch (e) {
                    return <Observable<CognitiveParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CognitiveParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVisuoSpatialAbility(response: HttpResponseBase): Observable<CognitiveParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CognitiveParentDto.fromJS(resultData200) : new CognitiveParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CognitiveParentDto>(<any>null);
    }

    /**
     * @param visuoSpatialAbilityId (optional) 
     * @return Success
     */
    deleteVisuoSpatialAbility(visuoSpatialAbilityId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/DeleteVisuoSpatialAbility?";
        if (visuoSpatialAbilityId !== undefined)
            url_ += "visuoSpatialAbilityId=" + encodeURIComponent("" + visuoSpatialAbilityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVisuoSpatialAbility(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVisuoSpatialAbility(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteVisuoSpatialAbility(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param options (optional) 
     * @param identifier (optional) 
     * @return Success
     */
    updateOptions(clientId: string | null | undefined, options: OptionDto[] | null | undefined, identifier: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/UpdateOptions?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (identifier !== undefined)
            url_ += "identifier=" + encodeURIComponent("" + identifier) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOptions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOptions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateCognitiveComment(input: CognitiveParentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Cognitive/updateCognitiveComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCognitiveComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCognitiveComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCognitiveComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createComment(input: CreateCommentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comment/CreateComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editComment(input: CreateCommentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comment/EditComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<CommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentListDto.fromJS(resultData200) : new CommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<CommentDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Comment/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<CommentDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<CommentDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentDetailOutput.fromJS(resultData200) : new CommentDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDetailOutput>(<any>null);
    }

    /**
     * @param targetId (optional) 
     * @return Success
     */
    getUserComments(targetId: string | null | undefined): Observable<CommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/GetUserComments?";
        if (targetId !== undefined)
            url_ += "TargetId=" + encodeURIComponent("" + targetId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserComments(<any>response_);
                } catch (e) {
                    return <Observable<CommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserComments(response: HttpResponseBase): Observable<CommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentListDto.fromJS(resultData200) : new CommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<CommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentListDto.fromJS(resultData200) : new CommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfCommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCommentListDto.fromJS(resultData200) : new PagedResultDtoOfCommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCommentListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateCommentInput | null | undefined): Observable<CommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentListDto.fromJS(resultData200) : new CommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: CommentListDto | null | undefined): Observable<CommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentListDto.fromJS(resultData200) : new CommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeUiTheme(input: ChangeUiThemeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createContact(input: CreateContactInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contact/CreateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editContact(input: ContactDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contact/EditContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contact/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<ContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactListDto.fromJS(resultData200) : new ContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<ContactDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Contact/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<ContactDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<ContactDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactDetailOutput.fromJS(resultData200) : new ContactDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getByLawFirm(input: string | null | undefined): Observable<ListResultDtoOfContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/GetByLawFirm?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLawFirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLawFirm(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByLawFirm(response: HttpResponseBase): Observable<ListResultDtoOfContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfContactListDto.fromJS(resultData200) : new ListResultDtoOfContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfContactListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<ContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactListDto.fromJS(resultData200) : new ContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfContactListDto.fromJS(resultData200) : new PagedResultDtoOfContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContactListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateContactInput | null | undefined): Observable<ContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactListDto.fromJS(resultData200) : new ContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: ContactListDto | null | undefined): Observable<ContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactListDto.fromJS(resultData200) : new ContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactListDto>(<any>null);
    }
}

@Injectable()
export class CoordinationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param coordinationId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateCoordinationOption(coordinationId: string | null | undefined, input: CoordinationOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Coordination/UpdateCoordinationOption?";
        if (coordinationId !== undefined)
            url_ += "coordinationId=" + encodeURIComponent("" + coordinationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCoordinationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCoordinationOption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCoordinationOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param position (optional) 
     * @return Success
     */
    getCoordination(clientId: string | null | undefined, position: number | null | undefined): Observable<ListResultDtoOfCoordinationOptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Coordination/GetCoordination?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (position !== undefined)
            url_ += "Position=" + encodeURIComponent("" + position) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoordination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoordination(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCoordinationOptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCoordinationOptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoordination(response: HttpResponseBase): Observable<ListResultDtoOfCoordinationOptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCoordinationOptionListDto.fromJS(resultData200) : new ListResultDtoOfCoordinationOptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCoordinationOptionListDto>(<any>null);
    }
}

@Injectable()
export class CoordinationIncompleteServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateCoordinationIncomplete(clientId: string | null | undefined, input: CoordinationIncompleteDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CoordinationIncomplete/UpdateCoordinationIncomplete?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCoordinationIncomplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCoordinationIncomplete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCoordinationIncomplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getCoordinationIncomplete(clientId: string | null | undefined, side: number | null | undefined): Observable<CoordinationIncompleteDto> {
        let url_ = this.baseUrl + "/api/services/app/CoordinationIncomplete/GetCoordinationIncomplete?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoordinationIncomplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoordinationIncomplete(<any>response_);
                } catch (e) {
                    return <Observable<CoordinationIncompleteDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CoordinationIncompleteDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoordinationIncomplete(response: HttpResponseBase): Observable<CoordinationIncompleteDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CoordinationIncompleteDto.fromJS(resultData200) : new CoordinationIncompleteDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoordinationIncompleteDto>(<any>null);
    }
}

@Injectable()
export class CrawlingProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    create(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CrawlingProtocol/Create?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<CrawlingProtocolDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/CrawlingProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CrawlingProtocolDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CrawlingProtocolDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CrawlingProtocolDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CrawlingProtocolDetailOutput.fromJS(resultData200) : new CrawlingProtocolDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CrawlingProtocolDetailOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<CrawlingProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/CrawlingProtocol/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CrawlingProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CrawlingProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CrawlingProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CrawlingProtocolDto.fromJS(resultData200) : new CrawlingProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CrawlingProtocolDto>(<any>null);
    }

    /**
     * @param crawlingProtocolId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(crawlingProtocolId: string | null | undefined, input: CrawlingProtocolDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CrawlingProtocol/Update?";
        if (crawlingProtocolId !== undefined)
            url_ += "crawlingProtocolId=" + encodeURIComponent("" + crawlingProtocolId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateTestStatus(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CrawlingProtocol/UpdateTestStatus?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTestStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTestStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTestStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CrouchingTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CrouchingTestCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CrouchingTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfCrouchingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/CrouchingTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCrouchingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCrouchingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfCrouchingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCrouchingTestDto.fromJS(resultData200) : new ListResultDtoOfCrouchingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCrouchingTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<CrouchingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/CrouchingTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CrouchingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CrouchingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CrouchingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CrouchingTestDto.fromJS(resultData200) : new CrouchingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CrouchingTestDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getCrouching(clientId: string | null | undefined): Observable<CrouchingDto> {
        let url_ = this.baseUrl + "/api/services/app/CrouchingTest/GetCrouching?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCrouching(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCrouching(<any>response_);
                } catch (e) {
                    return <Observable<CrouchingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CrouchingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCrouching(response: HttpResponseBase): Observable<CrouchingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CrouchingDto.fromJS(resultData200) : new CrouchingDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CrouchingDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CrouchingTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param crouchingId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(crouchingId: string | null | undefined, input: CrouchingTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CrouchingTest/Update?";
        if (crouchingId !== undefined)
            url_ += "crouchingId=" + encodeURIComponent("" + crouchingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getLatestActivity(input: any | null | undefined): Observable<ListResultDtoOfBookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/DashBoard/GetLatestActivity?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestActivity(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestActivity(response: HttpResponseBase): Observable<ListResultDtoOfBookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfBookingListDto.fromJS(resultData200) : new ListResultDtoOfBookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBookingListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getNewClients(input: any | null | undefined): Observable<ListResultDtoOfClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/DashBoard/GetNewClients?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewClients(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNewClients(response: HttpResponseBase): Observable<ListResultDtoOfClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfClientListDto.fromJS(resultData200) : new ListResultDtoOfClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfClientListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getNumberFiles(input: any | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DashBoard/GetNumberFiles?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNumberFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNumberFiles(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetNumberFiles(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getNumberLawFirms(input: any | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DashBoard/GetNumberLawFirms?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNumberLawFirms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNumberLawFirms(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetNumberLawFirms(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAssessmentStats(): Observable<ListResultDtoOfAssessmentsDto> {
        let url_ = this.baseUrl + "/api/services/app/DashBoard/GetAssessmentStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssessmentStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssessmentStats(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAssessmentsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAssessmentsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssessmentStats(response: HttpResponseBase): Observable<ListResultDtoOfAssessmentsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAssessmentsDto.fromJS(resultData200) : new ListResultDtoOfAssessmentsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAssessmentsDto>(<any>null);
    }
}

@Injectable()
export class DocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createDocument(input: CreateDocumentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/CreateDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editDocument(input: DocumentDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/EditDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getAllUserDocuments(clientId: string | null | undefined): Observable<ListResultDtoOfDocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAllUserDocuments?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserDocuments(response: HttpResponseBase): Observable<ListResultDtoOfDocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfDocumentListDto.fromJS(resultData200) : new ListResultDtoOfDocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDocumentListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: number | null | undefined): Observable<DocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<DocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentListDto.fromJS(resultData200) : new DocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: number | null | undefined): Observable<DocumentDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<DocumentDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<DocumentDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentDetailOutput.fromJS(resultData200) : new DocumentDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentDetailOutput>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getClientDocuments(clientId: string | null | undefined): Observable<ListResultDtoOfDocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetClientDocuments?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientDocuments(response: HttpResponseBase): Observable<ListResultDtoOfDocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfDocumentListDto.fromJS(resultData200) : new ListResultDtoOfDocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDocumentListDto>(<any>null);
    }

    /**
     * @param documentId (optional) 
     * @return Success
     */
    getChildDocuments(documentId: number | null | undefined): Observable<ListResultDtoOfDocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetChildDocuments?";
        if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetChildDocuments(response: HttpResponseBase): Observable<ListResultDtoOfDocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfDocumentListDto.fromJS(resultData200) : new ListResultDtoOfDocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDocumentListDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getAllChildDocuments(clientId: string | null | undefined): Observable<ListResultDtoOfDocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAllChildDocuments?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChildDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChildDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChildDocuments(response: HttpResponseBase): Observable<ListResultDtoOfDocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfDocumentListDto.fromJS(resultData200) : new ListResultDtoOfDocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDocumentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<DocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentListDto.fromJS(resultData200) : new DocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDocumentListDto.fromJS(resultData200) : new PagedResultDtoOfDocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDocumentListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateDocumentInput | null | undefined): Observable<DocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentListDto.fromJS(resultData200) : new DocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: DocumentListDto | null | undefined): Observable<DocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentListDto.fromJS(resultData200) : new DocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ElevatedReachTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: ElevatedReachTestCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElevatedReachTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfElevatedReachTestDto> {
        let url_ = this.baseUrl + "/api/services/app/ElevatedReachTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfElevatedReachTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfElevatedReachTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfElevatedReachTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfElevatedReachTestDto.fromJS(resultData200) : new ListResultDtoOfElevatedReachTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfElevatedReachTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<ElevatedReachTestDto> {
        let url_ = this.baseUrl + "/api/services/app/ElevatedReachTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ElevatedReachTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElevatedReachTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ElevatedReachTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ElevatedReachTestDto.fromJS(resultData200) : new ElevatedReachTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElevatedReachTestDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getElevatedReach(clientId: string | null | undefined): Observable<ElevatedReachDto> {
        let url_ = this.baseUrl + "/api/services/app/ElevatedReachTest/GetElevatedReach?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetElevatedReach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetElevatedReach(<any>response_);
                } catch (e) {
                    return <Observable<ElevatedReachDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElevatedReachDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetElevatedReach(response: HttpResponseBase): Observable<ElevatedReachDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ElevatedReachDto.fromJS(resultData200) : new ElevatedReachDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElevatedReachDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElevatedReachTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param elevatedReachTestId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(elevatedReachTestId: string | null | undefined, input: ElevatedReachTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ElevatedReachTest/Update?";
        if (elevatedReachTestId !== undefined)
            url_ += "elevatedReachTestId=" + encodeURIComponent("" + elevatedReachTestId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FunctionalAssessmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param types (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    createAsync(types: number[] | null | undefined, clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FunctionalAssessment/CreateAsync?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(types);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAsync(id: string | null | undefined): Observable<ClientAnswerListDto> {
        let url_ = this.baseUrl + "/api/services/app/FunctionalAssessment/GetAsync?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAsync(<any>response_);
                } catch (e) {
                    return <Observable<ClientAnswerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientAnswerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAsync(response: HttpResponseBase): Observable<ClientAnswerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientAnswerListDto.fromJS(resultData200) : new ClientAnswerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAnswerListDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param questionId (optional) 
     * @return Success
     */
    getByQuestionIdAsync(clientId: string | null | undefined, questionId: string | null | undefined): Observable<ListResultDtoOfClientAnswerListDto> {
        let url_ = this.baseUrl + "/api/services/app/FunctionalAssessment/GetByQuestionIdAsync?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (questionId !== undefined)
            url_ += "questionId=" + encodeURIComponent("" + questionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByQuestionIdAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByQuestionIdAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfClientAnswerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfClientAnswerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByQuestionIdAsync(response: HttpResponseBase): Observable<ListResultDtoOfClientAnswerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfClientAnswerListDto.fromJS(resultData200) : new ListResultDtoOfClientAnswerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfClientAnswerListDto>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    getListAsync(type: number | null | undefined, clientId: string | null | undefined): Observable<ListResultDtoOfClientAnswerListDto> {
        let url_ = this.baseUrl + "/api/services/app/FunctionalAssessment/GetListAsync?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfClientAnswerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfClientAnswerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetListAsync(response: HttpResponseBase): Observable<ListResultDtoOfClientAnswerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfClientAnswerListDto.fromJS(resultData200) : new ListResultDtoOfClientAnswerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfClientAnswerListDto>(<any>null);
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    getQuestionList(type: number | null | undefined): Observable<ListResultDtoOfQuestionListDto> {
        let url_ = this.baseUrl + "/api/services/app/FunctionalAssessment/GetQuestionList?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionList(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfQuestionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfQuestionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionList(response: HttpResponseBase): Observable<ListResultDtoOfQuestionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfQuestionListDto.fromJS(resultData200) : new ListResultDtoOfQuestionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfQuestionListDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getQuestionnaires(clientId: string | null | undefined): Observable<ListResultDtoOfQuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/app/FunctionalAssessment/GetQuestionnaires?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionnaires(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionnaires(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfQuestionnaireDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfQuestionnaireDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionnaires(response: HttpResponseBase): Observable<ListResultDtoOfQuestionnaireDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfQuestionnaireDto.fromJS(resultData200) : new ListResultDtoOfQuestionnaireDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfQuestionnaireDto>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param clientId (optional) 
     * @return Success
     */
    getQuestionnaire(type: number | null | undefined, clientId: string | null | undefined): Observable<QuestionnaireDto> {
        let url_ = this.baseUrl + "/api/services/app/FunctionalAssessment/GetQuestionnaire?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuestionnaire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuestionnaire(<any>response_);
                } catch (e) {
                    return <Observable<QuestionnaireDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionnaireDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuestionnaire(response: HttpResponseBase): Observable<QuestionnaireDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? QuestionnaireDto.fromJS(resultData200) : new QuestionnaireDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionnaireDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAsync(input: QuestionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FunctionalAssessment/UpdateAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param questions (optional) 
     * @return Success
     */
    updateQuestionList(questions: ClientAnswerListDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FunctionalAssessment/UpdateQuestionList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(questions);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestionList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuestionList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateQuestionnaire(input: QuestionnaireDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FunctionalAssessment/UpdateQuestionnaire";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestionnaire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestionnaire(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuestionnaire(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param type (optional) 
     * @return Success
     */
    updateQuestionnaireStatus(clientId: string | null | undefined, type: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FunctionalAssessment/UpdateQuestionnaireStatus?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuestionnaireStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuestionnaireStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuestionnaireStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GaitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateGait(clientId: string | null | undefined, input: GaitDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Gait/UpdateGait?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGait(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGait(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGait(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getGait(clientId: string | null | undefined): Observable<GaitDto> {
        let url_ = this.baseUrl + "/api/services/app/Gait/GetGait?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGait(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGait(<any>response_);
                } catch (e) {
                    return <Observable<GaitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GaitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGait(response: HttpResponseBase): Observable<GaitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GaitDto.fromJS(resultData200) : new GaitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GaitDto>(<any>null);
    }
}

@Injectable()
export class GripStrengthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateGripStrength(clientId: string | null | undefined, side: number | null | undefined, input: GripStrengthDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GripStrength/UpdateGripStrength?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGripStrength(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGripStrength(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGripStrength(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getGripStrength(clientId: string | null | undefined, side: number | null | undefined): Observable<GripStrengthDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/GripStrength/GetGripStrength?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGripStrength(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGripStrength(<any>response_);
                } catch (e) {
                    return <Observable<GripStrengthDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GripStrengthDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGripStrength(response: HttpResponseBase): Observable<GripStrengthDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GripStrengthDetailOutput.fromJS(resultData200) : new GripStrengthDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GripStrengthDetailOutput>(<any>null);
    }
}

@Injectable()
export class JobDescriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createJobDescription(input: CreateJobDescriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/CreateJobDescription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateJobDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateJobDescription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateJobDescription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editJobDescription(input: JobDescriptionDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/EditJobDescription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditJobDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditJobDescription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditJobDescription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: number | null | undefined): Observable<JobDescriptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<JobDescriptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDescriptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<JobDescriptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobDescriptionListDto.fromJS(resultData200) : new JobDescriptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDescriptionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: number | null | undefined): Observable<JobDescriptionDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<JobDescriptionDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDescriptionDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<JobDescriptionDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobDescriptionDetailOutput.fromJS(resultData200) : new JobDescriptionDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDescriptionDetailOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getList(): Observable<JobDescriptionDetailOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/GetList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<JobDescriptionDetailOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDescriptionDetailOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<JobDescriptionDetailOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(JobDescriptionDetailOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDescriptionDetailOutput[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<JobDescriptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<JobDescriptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDescriptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobDescriptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobDescriptionListDto.fromJS(resultData200) : new JobDescriptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDescriptionListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfJobDescriptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfJobDescriptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfJobDescriptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfJobDescriptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfJobDescriptionListDto.fromJS(resultData200) : new PagedResultDtoOfJobDescriptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfJobDescriptionListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateJobDescriptionInput | null | undefined): Observable<JobDescriptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<JobDescriptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDescriptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<JobDescriptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobDescriptionListDto.fromJS(resultData200) : new JobDescriptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDescriptionListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: JobDescriptionListDto | null | undefined): Observable<JobDescriptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<JobDescriptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDescriptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<JobDescriptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobDescriptionListDto.fromJS(resultData200) : new JobDescriptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDescriptionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class KneelingTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: KneelingTestCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KneelingTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfKneelingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/KneelingTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfKneelingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfKneelingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfKneelingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfKneelingTestDto.fromJS(resultData200) : new ListResultDtoOfKneelingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfKneelingTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<KneelingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/KneelingTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<KneelingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KneelingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<KneelingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? KneelingTestDto.fromJS(resultData200) : new KneelingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KneelingTestDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getKneeling(clientId: string | null | undefined): Observable<KneelingDto> {
        let url_ = this.baseUrl + "/api/services/app/KneelingTest/GetKneeling?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKneeling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKneeling(<any>response_);
                } catch (e) {
                    return <Observable<KneelingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KneelingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetKneeling(response: HttpResponseBase): Observable<KneelingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? KneelingDto.fromJS(resultData200) : new KneelingDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KneelingDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KneelingTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param crouchingId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(crouchingId: string | null | undefined, input: KneelingTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KneelingTest/Update?";
        if (crouchingId !== undefined)
            url_ += "crouchingId=" + encodeURIComponent("" + crouchingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LadderWorkProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: LadderWorkCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LadderWorkProtocol/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getLadderWorkProtocol(clientId: string | null | undefined): Observable<LadderWorkProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/LadderWorkProtocol/GetLadderWorkProtocol?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLadderWorkProtocol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLadderWorkProtocol(<any>response_);
                } catch (e) {
                    return <Observable<LadderWorkProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LadderWorkProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLadderWorkProtocol(response: HttpResponseBase): Observable<LadderWorkProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LadderWorkProtocolDto.fromJS(resultData200) : new LadderWorkProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LadderWorkProtocolDto>(<any>null);
    }

    /**
     * @param ladderWorkOptionId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateOption(ladderWorkOptionId: string | null | undefined, input: LadderWorkOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LadderWorkProtocol/UpdateOption?";
        if (ladderWorkOptionId !== undefined)
            url_ += "ladderWorkOptionId=" + encodeURIComponent("" + ladderWorkOptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateTestStatus(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LadderWorkProtocol/UpdateTestStatus?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTestStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTestStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTestStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfLadderWorkOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/LadderWorkProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLadderWorkOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLadderWorkOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfLadderWorkOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLadderWorkOptionDto.fromJS(resultData200) : new ListResultDtoOfLadderWorkOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLadderWorkOptionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLadderWorkOptionById(id: string | null | undefined): Observable<LadderWorkOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/LadderWorkProtocol/GetLadderWorkOptionById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLadderWorkOptionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLadderWorkOptionById(<any>response_);
                } catch (e) {
                    return <Observable<LadderWorkOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LadderWorkOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLadderWorkOptionById(response: HttpResponseBase): Observable<LadderWorkOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LadderWorkOptionDto.fromJS(resultData200) : new LadderWorkOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LadderWorkOptionDto>(<any>null);
    }
}

@Injectable()
export class LawFirmServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createLawFirm(input: CreateLawFirmInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/CreateLawFirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLawFirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLawFirm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLawFirm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editLawFirm(input: LawFirmDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/EditLawFirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditLawFirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditLawFirm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditLawFirm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<LawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<LawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<LawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LawFirmListDto.fromJS(resultData200) : new LawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LawFirmListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<LawFirmDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<LawFirmDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<LawFirmDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<LawFirmDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LawFirmDetailOutput.fromJS(resultData200) : new LawFirmDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LawFirmDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getLawFirms(input: any | null | undefined): Observable<ListResultDtoOfLawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetLawFirms?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLawFirms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLawFirms(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLawFirms(response: HttpResponseBase): Observable<ListResultDtoOfLawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLawFirmListDto.fromJS(resultData200) : new ListResultDtoOfLawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLawFirmListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAttorneys(id: string | null | undefined): Observable<ListResultDtoOfAttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetAttorneys?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttorneys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttorneys(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAttorneys(response: HttpResponseBase): Observable<ListResultDtoOfAttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAttorneyListDto.fromJS(resultData200) : new ListResultDtoOfAttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAttorneyListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContacts(id: string | null | undefined): Observable<ListResultDtoOfContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetContacts?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContacts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContacts(response: HttpResponseBase): Observable<ListResultDtoOfContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfContactListDto.fromJS(resultData200) : new ListResultDtoOfContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfContactListDto>(<any>null);
    }

    /**
     * @param lawFirmId (optional) 
     * @return Success
     */
    getClients(lawFirmId: string | null | undefined): Observable<ListResultDtoOfClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetClients?";
        if (lawFirmId !== undefined)
            url_ += "LawFirmId=" + encodeURIComponent("" + lawFirmId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClients(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClients(response: HttpResponseBase): Observable<ListResultDtoOfClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfClientListDto.fromJS(resultData200) : new ListResultDtoOfClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfClientListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    search(input: string | null | undefined): Observable<ListResultDtoOfLawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/Search?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ListResultDtoOfLawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLawFirmListDto.fromJS(resultData200) : new ListResultDtoOfLawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLawFirmListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<LawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LawFirmListDto.fromJS(resultData200) : new LawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LawFirmListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfLawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLawFirmListDto.fromJS(resultData200) : new PagedResultDtoOfLawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLawFirmListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateLawFirmInput | null | undefined): Observable<LawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<LawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LawFirmListDto.fromJS(resultData200) : new LawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LawFirmListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: LawFirmListDto | null | undefined): Observable<LawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<LawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LawFirmListDto.fromJS(resultData200) : new LawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LawFirmListDto>(<any>null);
    }
}

@Injectable()
export class LiftingTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: LiftingTestCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LiftingTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<LiftingTestDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/LiftingTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LiftingTestDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<LiftingTestDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LiftingTestDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LiftingTestDetailOutput.fromJS(resultData200) : new LiftingTestDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LiftingTestDetailOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<LiftingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/LiftingTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<LiftingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LiftingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<LiftingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LiftingTestDto.fromJS(resultData200) : new LiftingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LiftingTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LiftingTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param liftingId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(liftingId: string | null | undefined, input: LiftingTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LiftingTest/Update?";
        if (liftingId !== undefined)
            url_ += "liftingId=" + encodeURIComponent("" + liftingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LiftWaistTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: LiftWaistTestCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LiftWaistTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param type (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined, type: number | null | undefined): Observable<ListResultDtoOfLiftWaistTestDto> {
        let url_ = this.baseUrl + "/api/services/app/LiftWaistTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLiftWaistTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLiftWaistTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfLiftWaistTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLiftWaistTestDto.fromJS(resultData200) : new ListResultDtoOfLiftWaistTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLiftWaistTestDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getAll(clientId: string | null | undefined): Observable<ListResultDtoOfLiftWaistTestDto> {
        let url_ = this.baseUrl + "/api/services/app/LiftWaistTest/GetAll?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLiftWaistTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLiftWaistTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfLiftWaistTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLiftWaistTestDto.fromJS(resultData200) : new ListResultDtoOfLiftWaistTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLiftWaistTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<LiftWaistTestDto> {
        let url_ = this.baseUrl + "/api/services/app/LiftWaistTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<LiftWaistTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LiftWaistTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<LiftWaistTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LiftWaistTestDto.fromJS(resultData200) : new LiftWaistTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LiftWaistTestDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getLifting(clientId: string | null | undefined): Observable<LiftWaistDto> {
        let url_ = this.baseUrl + "/api/services/app/LiftWaistTest/GetLifting?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLifting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLifting(<any>response_);
                } catch (e) {
                    return <Observable<LiftWaistDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LiftWaistDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLifting(response: HttpResponseBase): Observable<LiftWaistDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LiftWaistDto.fromJS(resultData200) : new LiftWaistDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LiftWaistDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LiftWaistTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param liftWaistId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(liftWaistId: string | null | undefined, input: LiftWaistTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LiftWaistTest/Update?";
        if (liftWaistId !== undefined)
            url_ += "liftWaistId=" + encodeURIComponent("" + liftWaistId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MidLevelReachTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: MidLevelReachCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MidLevelReachTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfMidLevelReachTestDto> {
        let url_ = this.baseUrl + "/api/services/app/MidLevelReachTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfMidLevelReachTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfMidLevelReachTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfMidLevelReachTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfMidLevelReachTestDto.fromJS(resultData200) : new ListResultDtoOfMidLevelReachTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfMidLevelReachTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<MidLevelReachTestDto> {
        let url_ = this.baseUrl + "/api/services/app/MidLevelReachTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<MidLevelReachTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MidLevelReachTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<MidLevelReachTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MidLevelReachTestDto.fromJS(resultData200) : new MidLevelReachTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MidLevelReachTestDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getMidLevelReach(clientId: string | null | undefined): Observable<MidLevelReachDto> {
        let url_ = this.baseUrl + "/api/services/app/MidLevelReachTest/GetMidLevelReach?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMidLevelReach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMidLevelReach(<any>response_);
                } catch (e) {
                    return <Observable<MidLevelReachDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MidLevelReachDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMidLevelReach(response: HttpResponseBase): Observable<MidLevelReachDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MidLevelReachDto.fromJS(resultData200) : new MidLevelReachDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MidLevelReachDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MidLevelReachTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param midLevelReachTestId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(midLevelReachTestId: string | null | undefined, input: MidLevelReachTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MidLevelReachTest/Update?";
        if (midLevelReachTestId !== undefined)
            url_ += "midLevelReachTestId=" + encodeURIComponent("" + midLevelReachTestId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MobilityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createAsync(input: MobilityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Mobility/CreateAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAsync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAsync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAsync(id: string | null | undefined): Observable<MobilityDto> {
        let url_ = this.baseUrl + "/api/services/app/Mobility/GetAsync?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAsync(<any>response_);
                } catch (e) {
                    return <Observable<MobilityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MobilityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAsync(response: HttpResponseBase): Observable<MobilityDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobilityDto.fromJS(resultData200) : new MobilityDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MobilityDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getByClientAsync(clientId: string | null | undefined): Observable<MobilityDto> {
        let url_ = this.baseUrl + "/api/services/app/Mobility/GetByClientAsync?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByClientAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByClientAsync(<any>response_);
                } catch (e) {
                    return <Observable<MobilityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MobilityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByClientAsync(response: HttpResponseBase): Observable<MobilityDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobilityDto.fromJS(resultData200) : new MobilityDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MobilityDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getListAsync(clientId: string | null | undefined): Observable<ListResultDtoOfMobilityDto> {
        let url_ = this.baseUrl + "/api/services/app/Mobility/GetListAsync?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfMobilityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfMobilityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetListAsync(response: HttpResponseBase): Observable<ListResultDtoOfMobilityDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfMobilityDto.fromJS(resultData200) : new ListResultDtoOfMobilityDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfMobilityDto>(<any>null);
    }
}

@Injectable()
export class MusclePowerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateMusclePower(clientId: string | null | undefined, input: MusclePowerDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MusclePower/UpdateMusclePower?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMusclePower(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMusclePower(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMusclePower(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param type (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateMusclePowerOption(clientId: string | null | undefined, type: number | null | undefined, input: MusclePowerOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MusclePower/UpdateMusclePowerOption?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMusclePowerOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMusclePowerOption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMusclePowerOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param type (optional) 
     * @return Success
     */
    getMusclePowerOption(clientId: string | null | undefined, type: number | null | undefined): Observable<MusclePowerOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/MusclePower/GetMusclePowerOption?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMusclePowerOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMusclePowerOption(<any>response_);
                } catch (e) {
                    return <Observable<MusclePowerOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MusclePowerOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMusclePowerOption(response: HttpResponseBase): Observable<MusclePowerOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MusclePowerOptionDto.fromJS(resultData200) : new MusclePowerOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MusclePowerOptionDto>(<any>null);
    }
}

@Injectable()
export class PostureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param postureOptionId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updatePostureOption(postureOptionId: string | null | undefined, input: PostureOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Posture/UpdatePostureOption?";
        if (postureOptionId !== undefined)
            url_ += "postureOptionId=" + encodeURIComponent("" + postureOptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePostureOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePostureOption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePostureOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPosture(clientId: string | null | undefined): Observable<ListResultDtoOfPostureOptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Posture/GetPosture?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosture(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPostureOptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPostureOptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPosture(response: HttpResponseBase): Observable<ListResultDtoOfPostureOptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPostureOptionListDto.fromJS(resultData200) : new ListResultDtoOfPostureOptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPostureOptionListDto>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserProfile(): Observable<ProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<ProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<ProfileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfileDto.fromJS(resultData200) : new ProfileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLoggedInUser(id: number | null | undefined): Observable<ProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetLoggedInUser?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoggedInUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoggedInUser(<any>response_);
                } catch (e) {
                    return <Observable<ProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoggedInUser(response: HttpResponseBase): Observable<ProfileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfileDto.fromJS(resultData200) : new ProfileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileDto>(<any>null);
    }
}

@Injectable()
export class PullingTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: PullingTestCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PullingTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfPullingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/PullingTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPullingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPullingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfPullingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPullingTestDto.fromJS(resultData200) : new ListResultDtoOfPullingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPullingTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<PullingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/PullingTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PullingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PullingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PullingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PullingTestDto.fromJS(resultData200) : new PullingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PullingTestDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPulling(clientId: string | null | undefined): Observable<PullingDto> {
        let url_ = this.baseUrl + "/api/services/app/PullingTest/GetPulling?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPulling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPulling(<any>response_);
                } catch (e) {
                    return <Observable<PullingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PullingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPulling(response: HttpResponseBase): Observable<PullingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PullingDto.fromJS(resultData200) : new PullingDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PullingDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PullingTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param pullingId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(pullingId: string | null | undefined, input: PullingTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PullingTest/Update?";
        if (pullingId !== undefined)
            url_ += "pullingId=" + encodeURIComponent("" + pullingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PushingTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: PushingTestCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PushingTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfPushingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/PushingTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPushingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPushingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfPushingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPushingTestDto.fromJS(resultData200) : new ListResultDtoOfPushingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPushingTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<PushingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/PushingTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PushingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PushingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PushingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PushingTestDto.fromJS(resultData200) : new PushingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PushingTestDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPushing(clientId: string | null | undefined): Observable<PushingDto> {
        let url_ = this.baseUrl + "/api/services/app/PushingTest/GetPushing?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPushing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPushing(<any>response_);
                } catch (e) {
                    return <Observable<PushingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PushingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPushing(response: HttpResponseBase): Observable<PushingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PushingDto.fromJS(resultData200) : new PushingDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PushingDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PushingTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param pushingId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(pushingId: string | null | undefined, input: PushingTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PushingTest/Update?";
        if (pushingId !== undefined)
            url_ += "pushingId=" + encodeURIComponent("" + pushingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RangeOfMotionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createClientRangeOfMotion(input: CreateAssessmentListInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/CreateClientRangeOfMotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClientRangeOfMotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClientRangeOfMotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateClientRangeOfMotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getClientRangeOfMotion(clientId: string | null | undefined): Observable<RangeOfMotionDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetClientRangeOfMotion?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientRangeOfMotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientRangeOfMotion(<any>response_);
                } catch (e) {
                    return <Observable<RangeOfMotionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RangeOfMotionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientRangeOfMotion(response: HttpResponseBase): Observable<RangeOfMotionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RangeOfMotionDto.fromJS(resultData200) : new RangeOfMotionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RangeOfMotionDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getAnkle(clientId: string | null | undefined, side: number | null | undefined): Observable<AnkleDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetAnkle?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnkle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnkle(<any>response_);
                } catch (e) {
                    return <Observable<AnkleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AnkleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAnkle(response: HttpResponseBase): Observable<AnkleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AnkleDto.fromJS(resultData200) : new AnkleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnkleDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getElbow(clientId: string | null | undefined, side: number | null | undefined): Observable<ElbowDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetElbow?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetElbow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetElbow(<any>response_);
                } catch (e) {
                    return <Observable<ElbowDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElbowDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetElbow(response: HttpResponseBase): Observable<ElbowDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ElbowDto.fromJS(resultData200) : new ElbowDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElbowDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getForearmWrist(clientId: string | null | undefined, side: number | null | undefined): Observable<ForearmWristDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetForearmWrist?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForearmWrist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForearmWrist(<any>response_);
                } catch (e) {
                    return <Observable<ForearmWristDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ForearmWristDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForearmWrist(response: HttpResponseBase): Observable<ForearmWristDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ForearmWristDto.fromJS(resultData200) : new ForearmWristDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForearmWristDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getHip(clientId: string | null | undefined, side: number | null | undefined): Observable<HipDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetHip?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHip(<any>response_);
                } catch (e) {
                    return <Observable<HipDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HipDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHip(response: HttpResponseBase): Observable<HipDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HipDto.fromJS(resultData200) : new HipDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HipDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getKnee(clientId: string | null | undefined, side: number | null | undefined): Observable<KneeDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetKnee?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKnee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKnee(<any>response_);
                } catch (e) {
                    return <Observable<KneeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KneeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetKnee(response: HttpResponseBase): Observable<KneeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? KneeDto.fromJS(resultData200) : new KneeDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KneeDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getShoulder(clientId: string | null | undefined, side: number | null | undefined): Observable<ShoulderDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetShoulder?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShoulder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShoulder(<any>response_);
                } catch (e) {
                    return <Observable<ShoulderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShoulderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShoulder(response: HttpResponseBase): Observable<ShoulderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShoulderDto.fromJS(resultData200) : new ShoulderDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShoulderDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getHand(clientId: string | null | undefined, side: number | null | undefined): Observable<ListResultDtoOfHandDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetHand?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHand(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfHandDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfHandDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHand(response: HttpResponseBase): Observable<ListResultDtoOfHandDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfHandDto.fromJS(resultData200) : new ListResultDtoOfHandDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfHandDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateAnkle(clientId: string | null | undefined, input: AnkleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateAnkle?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAnkle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAnkle(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAnkle(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateElbow(clientId: string | null | undefined, input: ElbowDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateElbow?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateElbow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateElbow(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateElbow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateForearmWrist(clientId: string | null | undefined, input: ForearmWristDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateForearmWrist?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForearmWrist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForearmWrist(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateForearmWrist(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateHip(clientId: string | null | undefined, input: HipDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateHip?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHip(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHip(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateKnee(clientId: string | null | undefined, input: KneeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateKnee?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateKnee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateKnee(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateKnee(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateShoulder(clientId: string | null | undefined, input: ShoulderDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateShoulder?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateShoulder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateShoulder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateShoulder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateHand(clientId: string | null | undefined, input: HandDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateHand?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHand(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHand(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @param position (optional) 
     * @return Success
     */
    getByFinger(clientId: string | null | undefined, side: number | null | undefined, position: number | null | undefined): Observable<HandDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetByFinger?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        if (position !== undefined)
            url_ += "position=" + encodeURIComponent("" + position) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByFinger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByFinger(<any>response_);
                } catch (e) {
                    return <Observable<HandDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByFinger(response: HttpResponseBase): Observable<HandDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HandDto.fromJS(resultData200) : new HandDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandDto>(<any>null);
    }

    /**
     * @param list (optional) 
     * @return Success
     */
    setSelected(list: RangeOfMotionSelectionDto[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/SetSelected";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(list);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetSelected(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetSelected(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetSelected(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RepetitiveFootMotionProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    create(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveFootMotionProtocol/Create?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfRepetitiveFootMotionProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveFootMotionProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRepetitiveFootMotionProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRepetitiveFootMotionProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfRepetitiveFootMotionProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRepetitiveFootMotionProtocolDto.fromJS(resultData200) : new ListResultDtoOfRepetitiveFootMotionProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRepetitiveFootMotionProtocolDto>(<any>null);
    }

    /**
     * @param parentId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getById(parentId: string | null | undefined, side: number | null | undefined): Observable<RepetitiveFootMotionOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveFootMotionProtocol/GetById?";
        if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveFootMotionOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveFootMotionOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<RepetitiveFootMotionOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveFootMotionOptionDto.fromJS(resultData200) : new RepetitiveFootMotionOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveFootMotionOptionDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRepetitiveFootMotion(clientId: string | null | undefined): Observable<RepetitiveFootMotionProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveFootMotionProtocol/GetRepetitiveFootMotion?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepetitiveFootMotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepetitiveFootMotion(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveFootMotionProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveFootMotionProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepetitiveFootMotion(response: HttpResponseBase): Observable<RepetitiveFootMotionProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveFootMotionProtocolDto.fromJS(resultData200) : new RepetitiveFootMotionProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveFootMotionProtocolDto>(<any>null);
    }

    /**
     * @param repetitiveFootMotionOptionId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(repetitiveFootMotionOptionId: string | null | undefined, input: RepetitiveFootMotionOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveFootMotionProtocol/Update?";
        if (repetitiveFootMotionOptionId !== undefined)
            url_ += "repetitiveFootMotionOptionId=" + encodeURIComponent("" + repetitiveFootMotionOptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateTestStatus(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveFootMotionProtocol/UpdateTestStatus?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTestStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTestStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTestStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RepetitiveSquattingProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: RepetitiveSquattingCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveSquattingProtocol/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRepetitiveSquatting(clientId: string | null | undefined): Observable<RepetitiveSquattingProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveSquattingProtocol/GetRepetitiveSquatting?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepetitiveSquatting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepetitiveSquatting(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveSquattingProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveSquattingProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepetitiveSquatting(response: HttpResponseBase): Observable<RepetitiveSquattingProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveSquattingProtocolDto.fromJS(resultData200) : new RepetitiveSquattingProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveSquattingProtocolDto>(<any>null);
    }

    /**
     * @param repetitiveSquattingOptionId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateOption(repetitiveSquattingOptionId: string | null | undefined, input: RepetitiveSquattingOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveSquattingProtocol/UpdateOption?";
        if (repetitiveSquattingOptionId !== undefined)
            url_ += "RepetitiveSquattingOptionId=" + encodeURIComponent("" + repetitiveSquattingOptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateTestStatus(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveSquattingProtocol/UpdateTestStatus?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTestStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTestStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTestStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfRepetitiveSquattingOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveSquattingProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRepetitiveSquattingOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRepetitiveSquattingOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfRepetitiveSquattingOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRepetitiveSquattingOptionDto.fromJS(resultData200) : new ListResultDtoOfRepetitiveSquattingOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRepetitiveSquattingOptionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRepetitiveSquattingOptionById(id: string | null | undefined): Observable<RepetitiveSquattingOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveSquattingProtocol/GetRepetitiveSquattingOptionById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepetitiveSquattingOptionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepetitiveSquattingOptionById(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveSquattingOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveSquattingOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepetitiveSquattingOptionById(response: HttpResponseBase): Observable<RepetitiveSquattingOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveSquattingOptionDto.fromJS(resultData200) : new RepetitiveSquattingOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveSquattingOptionDto>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPersonalDetails(clientId: string | null | undefined): Observable<ClientDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetPersonalDetails?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonalDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonalDetails(<any>response_);
                } catch (e) {
                    return <Observable<ClientDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonalDetails(response: HttpResponseBase): Observable<ClientDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientDetailOutput.fromJS(resultData200) : new ClientDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getWorkHistoryByClientId(input: string | null | undefined): Observable<WorkHistoryListDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetWorkHistoryByClientId?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkHistoryByClientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistoryByClientId(<any>response_);
                } catch (e) {
                    return <Observable<WorkHistoryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkHistoryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkHistoryByClientId(response: HttpResponseBase): Observable<WorkHistoryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkHistoryListDto.fromJS(resultData200) : new WorkHistoryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkHistoryListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getMedicalHistoryByClientId(input: string | null | undefined): Observable<MedicalHistoryListDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetMedicalHistoryByClientId?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedicalHistoryByClientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedicalHistoryByClientId(<any>response_);
                } catch (e) {
                    return <Observable<MedicalHistoryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicalHistoryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedicalHistoryByClientId(response: HttpResponseBase): Observable<MedicalHistoryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MedicalHistoryListDto.fromJS(resultData200) : new MedicalHistoryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicalHistoryListDto>(<any>null);
    }
}

@Injectable()
export class ReportSummaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: ReportSummaryDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReportSummary/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getByClientId(clientId: string | null | undefined): Observable<ReportSummaryDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportSummary/GetByClientId?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByClientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByClientId(<any>response_);
                } catch (e) {
                    return <Observable<ReportSummaryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportSummaryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByClientId(response: HttpResponseBase): Observable<ReportSummaryDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ReportSummaryDto.fromJS(resultData200) : new ReportSummaryDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportSummaryDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: ReportSummaryDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ReportSummary/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateRoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRolesAsync(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRolesAsync?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolesAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolesAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolesAsync(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: RoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRoleDto.fromJS(resultData200) : new PagedResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRoleDto>(<any>null);
    }
}

@Injectable()
export class SensationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateUpperExtremity(clientId: string | null | undefined, side: number | null | undefined, input: SensationOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Sensation/UpdateUpperExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUpperExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUpperExtremity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUpperExtremity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getUpperExtremity(clientId: string | null | undefined, side: number | null | undefined): Observable<ListResultDtoOfSensationOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Sensation/GetUpperExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUpperExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUpperExtremity(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUpperExtremity(response: HttpResponseBase): Observable<ListResultDtoOfSensationOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSensationOptionDto.fromJS(resultData200) : new ListResultDtoOfSensationOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSensationOptionDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateTrunkExtremity(clientId: string | null | undefined, side: number | null | undefined, input: SensationOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Sensation/UpdateTrunkExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTrunkExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTrunkExtremity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTrunkExtremity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getTrunkExtremity(clientId: string | null | undefined, side: number | null | undefined): Observable<ListResultDtoOfSensationOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Sensation/GetTrunkExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrunkExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrunkExtremity(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrunkExtremity(response: HttpResponseBase): Observable<ListResultDtoOfSensationOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSensationOptionDto.fromJS(resultData200) : new ListResultDtoOfSensationOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSensationOptionDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateLowerExtremity(clientId: string | null | undefined, side: number | null | undefined, input: SensationOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Sensation/UpdateLowerExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLowerExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLowerExtremity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLowerExtremity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getLowerExtremity(clientId: string | null | undefined, side: number | null | undefined): Observable<ListResultDtoOfSensationOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Sensation/GetLowerExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLowerExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLowerExtremity(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLowerExtremity(response: HttpResponseBase): Observable<ListResultDtoOfSensationOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSensationOptionDto.fromJS(resultData200) : new ListResultDtoOfSensationOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSensationOptionDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateSensation(input: CreateSensationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Sensation/UpdateSensation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSensation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSensation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSensation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSensation(clientId: string | null | undefined): Observable<SensationListDto> {
        let url_ = this.baseUrl + "/api/services/app/Sensation/GetSensation?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSensation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSensation(<any>response_);
                } catch (e) {
                    return <Observable<SensationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SensationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSensation(response: HttpResponseBase): Observable<SensationListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SensationListDto.fromJS(resultData200) : new SensationListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SensationListDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class SittingTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: SittingTestCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SittingTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<SittingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/SittingTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SittingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SittingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SittingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SittingTestDto.fromJS(resultData200) : new SittingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SittingTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<SittingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/SittingTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<SittingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SittingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SittingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SittingTestDto.fromJS(resultData200) : new SittingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SittingTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SittingTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sittingId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(sittingId: string | null | undefined, input: SittingTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SittingTest/Update?";
        if (sittingId !== undefined)
            url_ += "sittingId=" + encodeURIComponent("" + sittingId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class StairClimbingProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: StairClimbingCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StairClimbingProtocol/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getStairClimbingProtocol(clientId: string | null | undefined): Observable<StairClimbingProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/StairClimbingProtocol/GetStairClimbingProtocol?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStairClimbingProtocol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStairClimbingProtocol(<any>response_);
                } catch (e) {
                    return <Observable<StairClimbingProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StairClimbingProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStairClimbingProtocol(response: HttpResponseBase): Observable<StairClimbingProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StairClimbingProtocolDto.fromJS(resultData200) : new StairClimbingProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StairClimbingProtocolDto>(<any>null);
    }

    /**
     * @param stairClimbingOptionId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateOption(stairClimbingOptionId: string | null | undefined, input: StairClimbingOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StairClimbingProtocol/UpdateOption?";
        if (stairClimbingOptionId !== undefined)
            url_ += "stairClimbingOptionId=" + encodeURIComponent("" + stairClimbingOptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateTestStatus(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StairClimbingProtocol/UpdateTestStatus?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTestStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTestStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTestStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfStairClimbingOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/StairClimbingProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfStairClimbingOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfStairClimbingOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfStairClimbingOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfStairClimbingOptionDto.fromJS(resultData200) : new ListResultDtoOfStairClimbingOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfStairClimbingOptionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStairClimbingOptionById(id: string | null | undefined): Observable<StairClimbingOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/StairClimbingProtocol/GetStairClimbingOptionById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStairClimbingOptionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStairClimbingOptionById(<any>response_);
                } catch (e) {
                    return <Observable<StairClimbingOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StairClimbingOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStairClimbingOptionById(response: HttpResponseBase): Observable<StairClimbingOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StairClimbingOptionDto.fromJS(resultData200) : new StairClimbingOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StairClimbingOptionDto>(<any>null);
    }
}

@Injectable()
export class StandingTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: StandingTestCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StandingTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<StandingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/StandingTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<StandingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StandingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StandingTestDto.fromJS(resultData200) : new StandingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandingTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<StandingTestDto> {
        let url_ = this.baseUrl + "/api/services/app/StandingTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<StandingTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandingTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<StandingTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StandingTestDto.fromJS(resultData200) : new StandingTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandingTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StandingTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param standingTestId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(standingTestId: string | null | undefined, input: StandingTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StandingTest/Update?";
        if (standingTestId !== undefined)
            url_ += "standingTestId=" + encodeURIComponent("" + standingTestId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class StaticDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssessment(id: string | null | undefined): Observable<AssessmentsListListDto> {
        let url_ = this.baseUrl + "/api/services/app/StaticData/GetAssessment?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssessment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssessment(<any>response_);
                } catch (e) {
                    return <Observable<AssessmentsListListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssessmentsListListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssessment(response: HttpResponseBase): Observable<AssessmentsListListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssessmentsListListDto.fromJS(resultData200) : new AssessmentsListListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssessmentsListListDto>(<any>null);
    }

    /**
     * @param categoryId (optional) 
     * @return Success
     */
    getAssessmentsList(categoryId: string | null | undefined): Observable<AssessmentsListListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/StaticData/GetAssessmentsList?";
        if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssessmentsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssessmentsList(<any>response_);
                } catch (e) {
                    return <Observable<AssessmentsListListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssessmentsListListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssessmentsList(response: HttpResponseBase): Observable<AssessmentsListListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AssessmentsListListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssessmentsListListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCategories(): Observable<AssessmentCategoryDetailOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/StaticData/GetCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategories(<any>response_);
                } catch (e) {
                    return <Observable<AssessmentCategoryDetailOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssessmentCategoryDetailOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategories(response: HttpResponseBase): Observable<AssessmentCategoryDetailOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AssessmentCategoryDetailOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssessmentCategoryDetailOutput[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCategory(id: string | null | undefined): Observable<AssessmentCategoryDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/StaticData/GetCategory?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategory(<any>response_);
                } catch (e) {
                    return <Observable<AssessmentCategoryDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssessmentCategoryDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategory(response: HttpResponseBase): Observable<AssessmentCategoryDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssessmentCategoryDetailOutput.fromJS(resultData200) : new AssessmentCategoryDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssessmentCategoryDetailOutput>(<any>null);
    }
}

@Injectable()
export class StatusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateGripStrength(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateGripStrength?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGripStrength(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGripStrength(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGripStrength(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateBorgBalance(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateBorgBalance?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBorgBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBorgBalance(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBorgBalance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updatePosture(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdatePosture?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePosture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePosture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePosture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateRangeOfMotion(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateRangeOfMotion?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRangeOfMotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRangeOfMotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRangeOfMotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateCoordination(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateCoordination?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCoordination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCoordination(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCoordination(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param categoryId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateRepetitiveTolerance(clientId: string | null | undefined, categoryId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateRepetitiveTolerance?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRepetitiveTolerance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRepetitiveTolerance(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRepetitiveTolerance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateWalkingProtocol(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateWalkingProtocol?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWalkingProtocol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWalkingProtocol(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateWalkingProtocol(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateStairClimbingProtocol(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateStairClimbingProtocol?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStairClimbingProtocol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStairClimbingProtocol(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStairClimbingProtocol(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateBalanceProtocol(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateBalanceProtocol?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBalanceProtocol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBalanceProtocol(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBalanceProtocol(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateLadderWorkProtocol(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateLadderWorkProtocol?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLadderWorkProtocol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLadderWorkProtocol(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLadderWorkProtocol(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateRepetitiveSquattingProtocol(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateRepetitiveSquattingProtocol?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRepetitiveSquattingProtocol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRepetitiveSquattingProtocol(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRepetitiveSquattingProtocol(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateReetitiveFootMotionProtocol(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateReetitiveFootMotionProtocol?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReetitiveFootMotionProtocol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReetitiveFootMotionProtocol(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateReetitiveFootMotionProtocol(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param assessmentId (optional) 
     * @return Success
     */
    updateCrawlingProtocol(clientId: string | null | undefined, assessmentId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateCrawlingProtocol?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (assessmentId !== undefined)
            url_ += "assessmentId=" + encodeURIComponent("" + assessmentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCrawlingProtocol(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCrawlingProtocol(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCrawlingProtocol(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateLanguage(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Status/UpdateLanguage?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateTenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantDto.fromJS(resultData200) : new PagedResultDtoOfTenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: TenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UnilateralTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: UnilateralTestCreateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UnilateralTest/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfUnilateralTestDto> {
        let url_ = this.baseUrl + "/api/services/app/UnilateralTest/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUnilateralTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUnilateralTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfUnilateralTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUnilateralTestDto.fromJS(resultData200) : new ListResultDtoOfUnilateralTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUnilateralTestDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: string | null | undefined): Observable<UnilateralTestDto> {
        let url_ = this.baseUrl + "/api/services/app/UnilateralTest/GetById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<UnilateralTestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnilateralTestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<UnilateralTestDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnilateralTestDto.fromJS(resultData200) : new UnilateralTestDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnilateralTestDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getUnilateralCarry(clientId: string | null | undefined): Observable<UnilateralDto> {
        let url_ = this.baseUrl + "/api/services/app/UnilateralTest/GetUnilateralCarry?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnilateralCarry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnilateralCarry(<any>response_);
                } catch (e) {
                    return <Observable<UnilateralDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnilateralDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnilateralCarry(response: HttpResponseBase): Observable<UnilateralDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UnilateralDto.fromJS(resultData200) : new UnilateralDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnilateralDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopTest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UnilateralTest/StopTest?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStopTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param unilateralId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(unilateralId: string | null | undefined, input: UnilateralTestDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UnilateralTest/Update?";
        if (unilateralId !== undefined)
            url_ += "unilateralId=" + encodeURIComponent("" + unilateralId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateUserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: UserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<ListResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleDto.fromJS(resultData200) : new ListResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserDto.fromJS(resultData200) : new PagedResultDtoOfUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDto>(<any>null);
    }
}

@Injectable()
export class WalkingProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    create(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WalkingProtocol/Create?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<WalkingProtocolDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/WalkingProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WalkingProtocolDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<WalkingProtocolDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WalkingProtocolDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WalkingProtocolDetailOutput.fromJS(resultData200) : new WalkingProtocolDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalkingProtocolDetailOutput>(<any>null);
    }

    /**
     * @param walkingProtocolId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(walkingProtocolId: string | null | undefined, input: WalkingProtocolDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WalkingProtocol/Update?";
        if (walkingProtocolId !== undefined)
            url_ += "walkingProtocolId=" + encodeURIComponent("" + walkingProtocolId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WorkAssessmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param jobTitle (optional) 
     * @return Success
     */
    getWorkContext(jobTitle: string | null | undefined): Observable<WorkContextDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessment/GetWorkContext?";
        if (jobTitle !== undefined)
            url_ += "jobTitle=" + encodeURIComponent("" + jobTitle) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkContext(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkContext(<any>response_);
                } catch (e) {
                    return <Observable<WorkContextDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkContextDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkContext(response: HttpResponseBase): Observable<WorkContextDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WorkContextDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkContextDto[]>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    getOccpations(keyword: string | null | undefined, start: number | null | undefined, end: number | null | undefined): Observable<OccupationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessment/GetOccpations?";
        if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&"; 
        if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOccpations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOccpations(<any>response_);
                } catch (e) {
                    return <Observable<OccupationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OccupationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOccpations(response: HttpResponseBase): Observable<OccupationDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OccupationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OccupationDto[]>(<any>null);
    }

    /**
     * @param onetSocCode (optional) 
     * @return Success
     */
    getWorkContextSummary(onetSocCode: string | null | undefined): Observable<WorkContextSummaryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessment/GetWorkContextSummary?";
        if (onetSocCode !== undefined)
            url_ += "onetSocCode=" + encodeURIComponent("" + onetSocCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkContextSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkContextSummary(<any>response_);
                } catch (e) {
                    return <Observable<WorkContextSummaryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkContextSummaryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkContextSummary(response: HttpResponseBase): Observable<WorkContextSummaryDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WorkContextSummaryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkContextSummaryDto[]>(<any>null);
    }
}

@Injectable()
export class WorkAssessmentReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPositionalToleranceReport(clientId: string | null | undefined): Observable<PositionalToleranceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetPositionalToleranceReport?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPositionalToleranceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPositionalToleranceReport(<any>response_);
                } catch (e) {
                    return <Observable<PositionalToleranceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionalToleranceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPositionalToleranceReport(response: HttpResponseBase): Observable<PositionalToleranceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PositionalToleranceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionalToleranceDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getWeightedProtocolReport(clientId: string | null | undefined): Observable<WeightedProtocolDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetWeightedProtocolReport?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeightedProtocolReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeightedProtocolReport(<any>response_);
                } catch (e) {
                    return <Observable<WeightedProtocolDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightedProtocolDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeightedProtocolReport(response: HttpResponseBase): Observable<WeightedProtocolDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WeightedProtocolDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightedProtocolDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRepetitiveToleranceReport(clientId: string | null | undefined): Observable<RepetitiveToleranceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetRepetitiveToleranceReport?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepetitiveToleranceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepetitiveToleranceReport(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveToleranceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveToleranceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepetitiveToleranceReport(response: HttpResponseBase): Observable<RepetitiveToleranceDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RepetitiveToleranceDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveToleranceDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getWeightedProtocolTaskParentReport(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetWeightedProtocolTaskParentReport?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeightedProtocolTaskParentReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeightedProtocolTaskParentReport(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeightedProtocolTaskParentReport(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WorkAssessmentTasksParentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPositionalToleranceTasksParentReport(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetPositionalToleranceTasksParentReport?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPositionalToleranceTasksParentReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPositionalToleranceTasksParentReport(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPositionalToleranceTasksParentReport(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WorkAssessmentTasksParentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto[]>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getCrouchingTest(clientId: string | null | undefined): Observable<PositionalToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetCrouchingTest?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCrouchingTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCrouchingTest(<any>response_);
                } catch (e) {
                    return <Observable<PositionalToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionalToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCrouchingTest(response: HttpResponseBase): Observable<PositionalToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PositionalToleranceDto.fromJS(resultData200) : new PositionalToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionalToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getCrouching(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetCrouching?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCrouching(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCrouching(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCrouching(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkAssessmentTasksParentDto.fromJS(resultData200) : new WorkAssessmentTasksParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getKneelingTest(clientId: string | null | undefined): Observable<PositionalToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetKneelingTest?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKneelingTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKneelingTest(<any>response_);
                } catch (e) {
                    return <Observable<PositionalToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionalToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetKneelingTest(response: HttpResponseBase): Observable<PositionalToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PositionalToleranceDto.fromJS(resultData200) : new PositionalToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionalToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getKneeling(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetKneeling?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKneeling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKneeling(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetKneeling(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkAssessmentTasksParentDto.fromJS(resultData200) : new WorkAssessmentTasksParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSittingTest(clientId: string | null | undefined): Observable<PositionalToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetSittingTest?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSittingTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSittingTest(<any>response_);
                } catch (e) {
                    return <Observable<PositionalToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionalToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSittingTest(response: HttpResponseBase): Observable<PositionalToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PositionalToleranceDto.fromJS(resultData200) : new PositionalToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionalToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSitting(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetSitting?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSitting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSitting(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSitting(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkAssessmentTasksParentDto.fromJS(resultData200) : new WorkAssessmentTasksParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getStandingTest(clientId: string | null | undefined): Observable<PositionalToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetStandingTest?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStandingTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStandingTest(<any>response_);
                } catch (e) {
                    return <Observable<PositionalToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionalToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStandingTest(response: HttpResponseBase): Observable<PositionalToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PositionalToleranceDto.fromJS(resultData200) : new PositionalToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionalToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getStanding(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetStanding?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStanding(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStanding(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStanding(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkAssessmentTasksParentDto.fromJS(resultData200) : new WorkAssessmentTasksParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSustainedElevatedReachTest(clientId: string | null | undefined): Observable<PositionalToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetSustainedElevatedReachTest?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSustainedElevatedReachTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSustainedElevatedReachTest(<any>response_);
                } catch (e) {
                    return <Observable<PositionalToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionalToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSustainedElevatedReachTest(response: HttpResponseBase): Observable<PositionalToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PositionalToleranceDto.fromJS(resultData200) : new PositionalToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionalToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSustainedElevatedReach(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetSustainedElevatedReach?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSustainedElevatedReach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSustainedElevatedReach(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSustainedElevatedReach(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkAssessmentTasksParentDto.fromJS(resultData200) : new WorkAssessmentTasksParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSustainedMidLevelReachTest(clientId: string | null | undefined): Observable<PositionalToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetSustainedMidLevelReachTest?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSustainedMidLevelReachTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSustainedMidLevelReachTest(<any>response_);
                } catch (e) {
                    return <Observable<PositionalToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PositionalToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSustainedMidLevelReachTest(response: HttpResponseBase): Observable<PositionalToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PositionalToleranceDto.fromJS(resultData200) : new PositionalToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PositionalToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getSustainedMidLevelReach(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetSustainedMidLevelReach?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSustainedMidLevelReach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSustainedMidLevelReach(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSustainedMidLevelReach(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkAssessmentTasksParentDto.fromJS(resultData200) : new WorkAssessmentTasksParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getLiftingTest(clientId: string | null | undefined): Observable<WeightedProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetLiftingTest?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLiftingTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLiftingTest(<any>response_);
                } catch (e) {
                    return <Observable<WeightedProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightedProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLiftingTest(response: HttpResponseBase): Observable<WeightedProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WeightedProtocolDto.fromJS(resultData200) : new WeightedProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightedProtocolDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getUnilateralTestCarry(clientId: string | null | undefined): Observable<WeightedProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetUnilateralTestCarry?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnilateralTestCarry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnilateralTestCarry(<any>response_);
                } catch (e) {
                    return <Observable<WeightedProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightedProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnilateralTestCarry(response: HttpResponseBase): Observable<WeightedProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WeightedProtocolDto.fromJS(resultData200) : new WeightedProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightedProtocolDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getBilateralTestCarry(clientId: string | null | undefined): Observable<WeightedProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetBilateralTestCarry?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBilateralTestCarry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBilateralTestCarry(<any>response_);
                } catch (e) {
                    return <Observable<WeightedProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightedProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBilateralTestCarry(response: HttpResponseBase): Observable<WeightedProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WeightedProtocolDto.fromJS(resultData200) : new WeightedProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightedProtocolDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPushingTest(clientId: string | null | undefined): Observable<WeightedProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetPushingTest?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPushingTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPushingTest(<any>response_);
                } catch (e) {
                    return <Observable<WeightedProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightedProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPushingTest(response: HttpResponseBase): Observable<WeightedProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WeightedProtocolDto.fromJS(resultData200) : new WeightedProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightedProtocolDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPullingTest(clientId: string | null | undefined): Observable<WeightedProtocolDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetPullingTest?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPullingTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPullingTest(<any>response_);
                } catch (e) {
                    return <Observable<WeightedProtocolDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeightedProtocolDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPullingTest(response: HttpResponseBase): Observable<WeightedProtocolDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WeightedProtocolDto.fromJS(resultData200) : new WeightedProtocolDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeightedProtocolDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getLifting(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetLifting?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLifting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLifting(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLifting(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkAssessmentTasksParentDto.fromJS(resultData200) : new WorkAssessmentTasksParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getUnilateralCarry(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetUnilateralCarry?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnilateralCarry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnilateralCarry(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnilateralCarry(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkAssessmentTasksParentDto.fromJS(resultData200) : new WorkAssessmentTasksParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getBilateralCarry(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetBilateralCarry?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBilateralCarry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBilateralCarry(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBilateralCarry(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkAssessmentTasksParentDto.fromJS(resultData200) : new WorkAssessmentTasksParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPulling(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetPulling?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPulling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPulling(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPulling(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkAssessmentTasksParentDto.fromJS(resultData200) : new WorkAssessmentTasksParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPushing(clientId: string | null | undefined): Observable<WorkAssessmentTasksParentDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetPushing?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPushing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPushing(<any>response_);
                } catch (e) {
                    return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkAssessmentTasksParentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPushing(response: HttpResponseBase): Observable<WorkAssessmentTasksParentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkAssessmentTasksParentDto.fromJS(resultData200) : new WorkAssessmentTasksParentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkAssessmentTasksParentDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRepetitiveSquatting(clientId: string | null | undefined): Observable<RepetitiveToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetRepetitiveSquatting?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepetitiveSquatting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepetitiveSquatting(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepetitiveSquatting(response: HttpResponseBase): Observable<RepetitiveToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveToleranceDto.fromJS(resultData200) : new RepetitiveToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getLadderWork(clientId: string | null | undefined): Observable<RepetitiveToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetLadderWork?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLadderWork(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLadderWork(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLadderWork(response: HttpResponseBase): Observable<RepetitiveToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveToleranceDto.fromJS(resultData200) : new RepetitiveToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getBalance(clientId: string | null | undefined): Observable<RepetitiveToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetBalance?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalance(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBalance(response: HttpResponseBase): Observable<RepetitiveToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveToleranceDto.fromJS(resultData200) : new RepetitiveToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getRepetitiveFootMotion(clientId: string | null | undefined): Observable<RepetitiveToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetRepetitiveFootMotion?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepetitiveFootMotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepetitiveFootMotion(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepetitiveFootMotion(response: HttpResponseBase): Observable<RepetitiveToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveToleranceDto.fromJS(resultData200) : new RepetitiveToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getCrawling(clientId: string | null | undefined): Observable<RepetitiveToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetCrawling?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCrawling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCrawling(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCrawling(response: HttpResponseBase): Observable<RepetitiveToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveToleranceDto.fromJS(resultData200) : new RepetitiveToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getWalking(clientId: string | null | undefined): Observable<RepetitiveToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetWalking?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWalking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWalking(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWalking(response: HttpResponseBase): Observable<RepetitiveToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveToleranceDto.fromJS(resultData200) : new RepetitiveToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveToleranceDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getStairClimb(clientId: string | null | undefined): Observable<RepetitiveToleranceDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkAssessmentReport/GetStairClimb?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStairClimb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStairClimb(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveToleranceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveToleranceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStairClimb(response: HttpResponseBase): Observable<RepetitiveToleranceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveToleranceDto.fromJS(resultData200) : new RepetitiveToleranceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveToleranceDto>(<any>null);
    }
}

@Injectable()
export class WorkInformationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: WorkInformationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkInformation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getByClientId(clientId: string | null | undefined): Observable<WorkInformationDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkInformation/GetByClientId?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByClientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByClientId(<any>response_);
                } catch (e) {
                    return <Observable<WorkInformationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkInformationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByClientId(response: HttpResponseBase): Observable<WorkInformationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkInformationDto.fromJS(resultData200) : new WorkInformationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkInformationDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: WorkInformationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkInformation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class CreateActivityLogInput implements ICreateActivityLogInput {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    targetId: string | undefined;
    targetType: string | undefined;

    constructor(data?: ICreateActivityLogInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.routeUrl = data["routeUrl"];
            this.userId = data["userId"];
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
        }
    }

    static fromJS(data: any): CreateActivityLogInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityLogInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["routeUrl"] = this.routeUrl;
        data["userId"] = this.userId;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        return data; 
    }

    clone(): CreateActivityLogInput {
        const json = this.toJSON();
        let result = new CreateActivityLogInput();
        result.init(json);
        return result;
    }
}

export interface ICreateActivityLogInput {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
}

export class ActivityLogDetailOutput implements IActivityLogDetailOutput {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    user: User | undefined;
    targetId: string | undefined;
    targetType: string | undefined;

    constructor(data?: IActivityLogDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.routeUrl = data["routeUrl"];
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
        }
    }

    static fromJS(data: any): ActivityLogDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["routeUrl"] = this.routeUrl;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        return data; 
    }

    clone(): ActivityLogDetailOutput {
        const json = this.toJSON();
        let result = new ActivityLogDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IActivityLogDetailOutput {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    user: User | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
}

export class User implements IUser {
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User | undefined;
    creatorUser: User | undefined;
    lastModifierUser: User | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number | undefined;
    isLockoutEnabled: boolean | undefined;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean | undefined;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean | undefined;
    isActive: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.normalizedUserName = data["normalizedUserName"];
            this.normalizedEmailAddress = data["normalizedEmailAddress"];
            this.concurrencyStamp = data["concurrencyStamp"];
            if (data["tokens"] && data["tokens"].constructor === Array) {
                this.tokens = [];
                for (let item of data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = data["deleterUser"] ? User.fromJS(data["deleterUser"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = data["lastModifierUser"] ? User.fromJS(data["lastModifierUser"]) : <any>undefined;
            this.authenticationSource = data["authenticationSource"];
            this.userName = data["userName"];
            this.tenantId = data["tenantId"];
            this.emailAddress = data["emailAddress"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.fullName = data["fullName"];
            this.password = data["password"];
            this.emailConfirmationCode = data["emailConfirmationCode"];
            this.passwordResetCode = data["passwordResetCode"];
            this.lockoutEndDateUtc = data["lockoutEndDateUtc"] ? moment(data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = data["accessFailedCount"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.securityStamp = data["securityStamp"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            if (data["logins"] && data["logins"].constructor === Array) {
                this.logins = [];
                for (let item of data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (data["claims"] && data["claims"].constructor === Array) {
                this.claims = [];
                for (let item of data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (data["settings"] && data["settings"].constructor === Array) {
                this.settings = [];
                for (let item of data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.isActive = data["isActive"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (this.tokens && this.tokens.constructor === Array) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (this.logins && this.logins.constructor === Array) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.claims && this.claims.constructor === Array) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.settings && this.settings.constructor === Array) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User | undefined;
    creatorUser: User | undefined;
    lastModifierUser: User | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number | undefined;
    isLockoutEnabled: boolean | undefined;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean | undefined;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean | undefined;
    isActive: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserToken implements IUserToken {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.name = data["name"];
            this.value = data["value"];
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number | undefined;
}

export class UserLogin implements IUserLogin {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string;
    providerKey: string;
    id: number | undefined;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.providerKey = data["providerKey"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string;
    providerKey: string;
    id: number | undefined;
}

export class UserRole implements IUserRole {
    tenantId: number | undefined;
    userId: number | undefined;
    roleId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.roleId = data["roleId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number | undefined;
    roleId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserClaim implements IUserClaim {
    tenantId: number | undefined;
    userId: number | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.claimType = data["claimType"];
            this.claimValue = data["claimValue"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.isGranted = data["isGranted"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    userId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Setting implements ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.value = data["value"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ActivityLogListDto implements IActivityLogListDto {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    user: User | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IActivityLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.routeUrl = data["routeUrl"];
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["routeUrl"] = this.routeUrl;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityLogListDto {
        const json = this.toJSON();
        let result = new ActivityLogListDto();
        result.init(json);
        return result;
    }
}

export interface IActivityLogListDto {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    user: User | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class AffectDto implements IAffectDto {
    comment: string | undefined;
    clientId: string | undefined;
    status: number | undefined;
    isSelected: boolean | undefined;
    id: string | undefined;

    constructor(data?: IAffectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comment = data["comment"];
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.isSelected = data["isSelected"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AffectDto {
        data = typeof data === 'object' ? data : {};
        let result = new AffectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["isSelected"] = this.isSelected;
        data["id"] = this.id;
        return data; 
    }

    clone(): AffectDto {
        const json = this.toJSON();
        let result = new AffectDto();
        result.init(json);
        return result;
    }
}

export interface IAffectDto {
    comment: string | undefined;
    clientId: string | undefined;
    status: number | undefined;
    isSelected: boolean | undefined;
    id: string | undefined;
}

export class ListResultDtoOfAffectDto implements IListResultDtoOfAffectDto {
    items: AffectDto[] | undefined;

    constructor(data?: IListResultDtoOfAffectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AffectDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAffectDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAffectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfAffectDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfAffectDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfAffectDto {
    items: AffectDto[] | undefined;
}

export class AssessmentsListListDto implements IAssessmentsListListDto {
    assessmentName: string | undefined;
    assessmentCategoryId: string | undefined;
    position: number | undefined;
    identifier: number | undefined;
    id: string | undefined;

    constructor(data?: IAssessmentsListListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentName = data["assessmentName"];
            this.assessmentCategoryId = data["assessmentCategoryId"];
            this.position = data["position"];
            this.identifier = data["identifier"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssessmentsListListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentsListListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentName"] = this.assessmentName;
        data["assessmentCategoryId"] = this.assessmentCategoryId;
        data["position"] = this.position;
        data["identifier"] = this.identifier;
        data["id"] = this.id;
        return data; 
    }

    clone(): AssessmentsListListDto {
        const json = this.toJSON();
        let result = new AssessmentsListListDto();
        result.init(json);
        return result;
    }
}

export interface IAssessmentsListListDto {
    assessmentName: string | undefined;
    assessmentCategoryId: string | undefined;
    position: number | undefined;
    identifier: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfAssessmentsListListDto implements IListResultDtoOfAssessmentsListListDto {
    items: AssessmentsListListDto[] | undefined;

    constructor(data?: IListResultDtoOfAssessmentsListListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AssessmentsListListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAssessmentsListListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAssessmentsListListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfAssessmentsListListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfAssessmentsListListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfAssessmentsListListDto {
    items: AssessmentsListListDto[] | undefined;
}

export class ListResultDtoOfClientAssessmentDto implements IListResultDtoOfClientAssessmentDto {
    items: ClientAssessmentDto[] | undefined;

    constructor(data?: IListResultDtoOfClientAssessmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ClientAssessmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfClientAssessmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfClientAssessmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfClientAssessmentDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfClientAssessmentDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfClientAssessmentDto {
    items: ClientAssessmentDto[] | undefined;
}

export class ClientAssessmentDto implements IClientAssessmentDto {
    assessmentCategoryId: string | undefined;
    assessmentsListId: string | undefined;
    clientId: string | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IClientAssessmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentCategoryId = data["assessmentCategoryId"];
            this.assessmentsListId = data["assessmentsListId"];
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ClientAssessmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAssessmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentCategoryId"] = this.assessmentCategoryId;
        data["assessmentsListId"] = this.assessmentsListId;
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientAssessmentDto {
        const json = this.toJSON();
        let result = new ClientAssessmentDto();
        result.init(json);
        return result;
    }
}

export interface IClientAssessmentDto {
    assessmentCategoryId: string | undefined;
    assessmentsListId: string | undefined;
    clientId: string | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class CreateAttorneyInput implements ICreateAttorneyInput {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;

    constructor(data?: ICreateAttorneyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cellphone = data["cellphone"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.fax = data["fax"];
        }
    }

    static fromJS(data: any): CreateAttorneyInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAttorneyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cellphone"] = this.cellphone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fax"] = this.fax;
        return data; 
    }

    clone(): CreateAttorneyInput {
        const json = this.toJSON();
        let result = new CreateAttorneyInput();
        result.init(json);
        return result;
    }
}

export interface ICreateAttorneyInput {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
}

export class PagedResultDtoOfAttorneyListDto implements IPagedResultDtoOfAttorneyListDto {
    totalCount: number | undefined;
    items: AttorneyListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAttorneyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AttorneyListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAttorneyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAttorneyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAttorneyListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAttorneyListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAttorneyListDto {
    totalCount: number | undefined;
    items: AttorneyListDto[] | undefined;
}

export class AttorneyListDto implements IAttorneyListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAttorneyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cellphone = data["cellphone"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.fax = data["fax"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AttorneyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttorneyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cellphone"] = this.cellphone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fax"] = this.fax;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AttorneyListDto {
        const json = this.toJSON();
        let result = new AttorneyListDto();
        result.init(json);
        return result;
    }
}

export interface IAttorneyListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class LawFirm implements ILawFirm {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: Address | undefined;
    postalAddressId: number | undefined;
    postalAddress: Address | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    contacts: Contact[] | undefined;
    attorneys: Attorney[] | undefined;
    clients: Client[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILawFirm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.physicalAddressId = data["physicalAddressId"];
            this.physicalAddress = data["physicalAddress"] ? Address.fromJS(data["physicalAddress"]) : <any>undefined;
            this.postalAddressId = data["postalAddressId"];
            this.postalAddress = data["postalAddress"] ? Address.fromJS(data["postalAddress"]) : <any>undefined;
            this.email = data["email"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            if (data["contacts"] && data["contacts"].constructor === Array) {
                this.contacts = [];
                for (let item of data["contacts"])
                    this.contacts.push(Contact.fromJS(item));
            }
            if (data["attorneys"] && data["attorneys"].constructor === Array) {
                this.attorneys = [];
                for (let item of data["attorneys"])
                    this.attorneys.push(Attorney.fromJS(item));
            }
            if (data["clients"] && data["clients"].constructor === Array) {
                this.clients = [];
                for (let item of data["clients"])
                    this.clients.push(Client.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LawFirm {
        data = typeof data === 'object' ? data : {};
        let result = new LawFirm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["physicalAddressId"] = this.physicalAddressId;
        data["physicalAddress"] = this.physicalAddress ? this.physicalAddress.toJSON() : <any>undefined;
        data["postalAddressId"] = this.postalAddressId;
        data["postalAddress"] = this.postalAddress ? this.postalAddress.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        if (this.contacts && this.contacts.constructor === Array) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        if (this.attorneys && this.attorneys.constructor === Array) {
            data["attorneys"] = [];
            for (let item of this.attorneys)
                data["attorneys"].push(item.toJSON());
        }
        if (this.clients && this.clients.constructor === Array) {
            data["clients"] = [];
            for (let item of this.clients)
                data["clients"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LawFirm {
        const json = this.toJSON();
        let result = new LawFirm();
        result.init(json);
        return result;
    }
}

export interface ILawFirm {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: Address | undefined;
    postalAddressId: number | undefined;
    postalAddress: Address | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    contacts: Contact[] | undefined;
    attorneys: Attorney[] | undefined;
    clients: Client[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Address implements IAddress {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;
    id: number | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.city = data["city"];
            this.postalCode = data["postalCode"];
            this.province = data["province"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["province"] = this.province;
        data["id"] = this.id;
        return data; 
    }

    clone(): Address {
        const json = this.toJSON();
        let result = new Address();
        result.init(json);
        return result;
    }
}

export interface IAddress {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;
    id: number | undefined;
}

export class Contact implements IContact {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.role = data["role"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["role"] = this.role;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Contact {
        const json = this.toJSON();
        let result = new Contact();
        result.init(json);
        return result;
    }
}

export interface IContact {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Attorney implements IAttorney {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    clients: Client[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAttorney) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cellphone = data["cellphone"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.fax = data["fax"];
            if (data["clients"] && data["clients"].constructor === Array) {
                this.clients = [];
                for (let item of data["clients"])
                    this.clients.push(Client.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Attorney {
        data = typeof data === 'object' ? data : {};
        let result = new Attorney();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cellphone"] = this.cellphone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fax"] = this.fax;
        if (this.clients && this.clients.constructor === Array) {
            data["clients"] = [];
            for (let item of this.clients)
                data["clients"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Attorney {
        const json = this.toJSON();
        let result = new Attorney();
        result.init(json);
        return result;
    }
}

export interface IAttorney {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    clients: Client[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Client implements IClient {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: string | undefined;
    dob: moment.Moment | undefined;
    addressId: number | undefined;
    dateOfInjury: moment.Moment | undefined;
    address: Address | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    generalAppearance: string | undefined;
    bookings: Booking[] | undefined;
    workInformation: WorkInformation[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IClient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.attorneyId = data["attorneyId"];
            this.attorney = data["attorney"] ? Attorney.fromJS(data["attorney"]) : <any>undefined;
            this.courtDate = data["courtDate"] ? moment(data["courtDate"].toString()) : <any>undefined;
            this.caseNumber = data["caseNumber"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.title = data["title"];
            this.idNumber = data["idNumber"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.addressId = data["addressId"];
            this.dateOfInjury = data["dateOfInjury"] ? moment(data["dateOfInjury"].toString()) : <any>undefined;
            this.address = data["address"] ? Address.fromJS(data["address"]) : <any>undefined;
            this.assessmentDate = data["assessmentDate"] ? moment(data["assessmentDate"].toString()) : <any>undefined;
            this.earlyChildhood = data["earlyChildhood"];
            this.family = data["family"];
            this.homeEnvironment = data["homeEnvironment"];
            this.education = data["education"];
            this.socialHabits = data["socialHabits"];
            this.currentComplaints = data["currentComplaints"];
            this.profilePictureId = data["profilePictureId"];
            this.affect = data["affect"];
            this.jobDescription = data["jobDescription"];
            this.motivation = data["motivation"];
            this.generalAppearance = data["generalAppearance"];
            if (data["bookings"] && data["bookings"].constructor === Array) {
                this.bookings = [];
                for (let item of data["bookings"])
                    this.bookings.push(Booking.fromJS(item));
            }
            if (data["workInformation"] && data["workInformation"].constructor === Array) {
                this.workInformation = [];
                for (let item of data["workInformation"])
                    this.workInformation.push(WorkInformation.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Client {
        data = typeof data === 'object' ? data : {};
        let result = new Client();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["attorneyId"] = this.attorneyId;
        data["attorney"] = this.attorney ? this.attorney.toJSON() : <any>undefined;
        data["courtDate"] = this.courtDate ? this.courtDate.toISOString() : <any>undefined;
        data["caseNumber"] = this.caseNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["title"] = this.title;
        data["idNumber"] = this.idNumber;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        data["dateOfInjury"] = this.dateOfInjury ? this.dateOfInjury.toISOString() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["assessmentDate"] = this.assessmentDate ? this.assessmentDate.toISOString() : <any>undefined;
        data["earlyChildhood"] = this.earlyChildhood;
        data["family"] = this.family;
        data["homeEnvironment"] = this.homeEnvironment;
        data["education"] = this.education;
        data["socialHabits"] = this.socialHabits;
        data["currentComplaints"] = this.currentComplaints;
        data["profilePictureId"] = this.profilePictureId;
        data["affect"] = this.affect;
        data["jobDescription"] = this.jobDescription;
        data["motivation"] = this.motivation;
        data["generalAppearance"] = this.generalAppearance;
        if (this.bookings && this.bookings.constructor === Array) {
            data["bookings"] = [];
            for (let item of this.bookings)
                data["bookings"].push(item.toJSON());
        }
        if (this.workInformation && this.workInformation.constructor === Array) {
            data["workInformation"] = [];
            for (let item of this.workInformation)
                data["workInformation"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Client {
        const json = this.toJSON();
        let result = new Client();
        result.init(json);
        return result;
    }
}

export interface IClient {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: string | undefined;
    dob: moment.Moment | undefined;
    addressId: number | undefined;
    dateOfInjury: moment.Moment | undefined;
    address: Address | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    generalAppearance: string | undefined;
    bookings: Booking[] | undefined;
    workInformation: WorkInformation[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Booking implements IBooking {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    userId: number | undefined;
    user: User | undefined;
    eventId: number | undefined;
    event: Event | undefined;
    client: Client | undefined;
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    changed: number | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBooking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.eventId = data["eventId"];
            this.event = data["event"] ? Event.fromJS(data["event"]) : <any>undefined;
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.attorneyId = data["attorneyId"];
            this.attorney = data["attorney"] ? Attorney.fromJS(data["attorney"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.changed = data["changed"];
            this.reason = data["reason"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Booking {
        data = typeof data === 'object' ? data : {};
        let result = new Booking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["eventId"] = this.eventId;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["attorneyId"] = this.attorneyId;
        data["attorney"] = this.attorney ? this.attorney.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["changed"] = this.changed;
        data["reason"] = this.reason;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Booking {
        const json = this.toJSON();
        let result = new Booking();
        result.init(json);
        return result;
    }
}

export interface IBooking {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    userId: number | undefined;
    user: User | undefined;
    eventId: number | undefined;
    event: Event | undefined;
    client: Client | undefined;
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    changed: number | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class WorkInformation implements IWorkInformation {
    jobTitle: string | undefined;
    jobDescription: string | undefined;
    clientId: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IWorkInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.jobTitle = data["jobTitle"];
            this.jobDescription = data["jobDescription"];
            this.clientId = data["clientId"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkInformation {
        data = typeof data === 'object' ? data : {};
        let result = new WorkInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobTitle"] = this.jobTitle;
        data["jobDescription"] = this.jobDescription;
        data["clientId"] = this.clientId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WorkInformation {
        const json = this.toJSON();
        let result = new WorkInformation();
        result.init(json);
        return result;
    }
}

export interface IWorkInformation {
    jobTitle: string | undefined;
    jobDescription: string | undefined;
    clientId: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Event implements IEvent {
    name: string | undefined;
    id: number | undefined;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Event {
        data = typeof data === 'object' ? data : {};
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): Event {
        const json = this.toJSON();
        let result = new Event();
        result.init(json);
        return result;
    }
}

export interface IEvent {
    name: string | undefined;
    id: number | undefined;
}

export class AttorneyDetailOutput implements IAttorneyDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAttorneyDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cellphone = data["cellphone"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.fax = data["fax"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AttorneyDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AttorneyDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cellphone"] = this.cellphone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fax"] = this.fax;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AttorneyDetailOutput {
        const json = this.toJSON();
        let result = new AttorneyDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IAttorneyDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfAttorneyListDto implements IListResultDtoOfAttorneyListDto {
    items: AttorneyListDto[] | undefined;

    constructor(data?: IListResultDtoOfAttorneyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AttorneyListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAttorneyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAttorneyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfAttorneyListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfAttorneyListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfAttorneyListDto {
    items: AttorneyListDto[] | undefined;
}

export class ListResultDtoOfBalanceProtocolOptionListDto implements IListResultDtoOfBalanceProtocolOptionListDto {
    items: BalanceProtocolOptionListDto[] | undefined;

    constructor(data?: IListResultDtoOfBalanceProtocolOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BalanceProtocolOptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfBalanceProtocolOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfBalanceProtocolOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfBalanceProtocolOptionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfBalanceProtocolOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfBalanceProtocolOptionListDto {
    items: BalanceProtocolOptionListDto[] | undefined;
}

export class BalanceProtocolOptionListDto implements IBalanceProtocolOptionListDto {
    balanceProtocolId: string | undefined;
    direction: string | undefined;
    timeTaken: number | undefined;
    numErrors: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBalanceProtocolOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.balanceProtocolId = data["balanceProtocolId"];
            this.direction = data["direction"];
            this.timeTaken = data["timeTaken"];
            this.numErrors = data["numErrors"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BalanceProtocolOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceProtocolOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balanceProtocolId"] = this.balanceProtocolId;
        data["direction"] = this.direction;
        data["timeTaken"] = this.timeTaken;
        data["numErrors"] = this.numErrors;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BalanceProtocolOptionListDto {
        const json = this.toJSON();
        let result = new BalanceProtocolOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceProtocolOptionListDto {
    balanceProtocolId: string | undefined;
    direction: string | undefined;
    timeTaken: number | undefined;
    numErrors: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class BalanceProtocolDto implements IBalanceProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    result: string | undefined;
    otComment: string | undefined;
    options: BalanceProtocolOptionDto[] | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBalanceProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.result = data["result"];
            this.otComment = data["otComment"];
            if (data["options"] && data["options"].constructor === Array) {
                this.options = [];
                for (let item of data["options"])
                    this.options.push(BalanceProtocolOptionDto.fromJS(item));
            }
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.chosen = data["chosen"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BalanceProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["result"] = this.result;
        data["otComment"] = this.otComment;
        if (this.options && this.options.constructor === Array) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["chosen"] = this.chosen;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BalanceProtocolDto {
        const json = this.toJSON();
        let result = new BalanceProtocolDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    result: string | undefined;
    otComment: string | undefined;
    options: BalanceProtocolOptionDto[] | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class BalanceProtocolOptionDto implements IBalanceProtocolOptionDto {
    balanceProtocolId: string | undefined;
    direction: string | undefined;
    timeTaken: number | undefined;
    numErrors: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBalanceProtocolOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.balanceProtocolId = data["balanceProtocolId"];
            this.direction = data["direction"];
            this.timeTaken = data["timeTaken"];
            this.numErrors = data["numErrors"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BalanceProtocolOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceProtocolOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balanceProtocolId"] = this.balanceProtocolId;
        data["direction"] = this.direction;
        data["timeTaken"] = this.timeTaken;
        data["numErrors"] = this.numErrors;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BalanceProtocolOptionDto {
        const json = this.toJSON();
        let result = new BalanceProtocolOptionDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceProtocolOptionDto {
    balanceProtocolId: string | undefined;
    direction: string | undefined;
    timeTaken: number | undefined;
    numErrors: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class BilateralTestCreateInput implements IBilateralTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    platform: string | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    distance: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    painLevel: number | undefined;

    constructor(data?: IBilateralTestCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.timeTaken = data["timeTaken"];
            this.platform = data["platform"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.weight = data["weight"];
            this.distance = data["distance"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.painLevel = data["painLevel"];
        }
    }

    static fromJS(data: any): BilateralTestCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new BilateralTestCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["timeTaken"] = this.timeTaken;
        data["platform"] = this.platform;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["weight"] = this.weight;
        data["distance"] = this.distance;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["painLevel"] = this.painLevel;
        return data; 
    }

    clone(): BilateralTestCreateInput {
        const json = this.toJSON();
        let result = new BilateralTestCreateInput();
        result.init(json);
        return result;
    }
}

export interface IBilateralTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    platform: string | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    distance: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    painLevel: number | undefined;
}

export class ListResultDtoOfBilateralTestDto implements IListResultDtoOfBilateralTestDto {
    items: BilateralTestDto[] | undefined;

    constructor(data?: IListResultDtoOfBilateralTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BilateralTestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfBilateralTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfBilateralTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfBilateralTestDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfBilateralTestDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfBilateralTestDto {
    items: BilateralTestDto[] | undefined;
}

export class BilateralTestDto implements IBilateralTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    platform: string | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    distance: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    bilateralId: string | undefined;
    painLevel: number | undefined;
    id: string | undefined;

    constructor(data?: IBilateralTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.timeTaken = data["timeTaken"];
            this.platform = data["platform"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.weight = data["weight"];
            this.distance = data["distance"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.bilateralId = data["bilateralId"];
            this.painLevel = data["painLevel"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BilateralTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new BilateralTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["timeTaken"] = this.timeTaken;
        data["platform"] = this.platform;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["weight"] = this.weight;
        data["distance"] = this.distance;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["bilateralId"] = this.bilateralId;
        data["painLevel"] = this.painLevel;
        data["id"] = this.id;
        return data; 
    }

    clone(): BilateralTestDto {
        const json = this.toJSON();
        let result = new BilateralTestDto();
        result.init(json);
        return result;
    }
}

export interface IBilateralTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    platform: string | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    distance: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    bilateralId: string | undefined;
    painLevel: number | undefined;
    id: string | undefined;
}

export class BilateralDto implements IBilateralDto {
    bilateralTests: BilateralTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBilateralDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["bilateralTests"] && data["bilateralTests"].constructor === Array) {
                this.bilateralTests = [];
                for (let item of data["bilateralTests"])
                    this.bilateralTests.push(BilateralTestDto.fromJS(item));
            }
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BilateralDto {
        data = typeof data === 'object' ? data : {};
        let result = new BilateralDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.bilateralTests && this.bilateralTests.constructor === Array) {
            data["bilateralTests"] = [];
            for (let item of this.bilateralTests)
                data["bilateralTests"].push(item.toJSON());
        }
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BilateralDto {
        const json = this.toJSON();
        let result = new BilateralDto();
        result.init(json);
        return result;
    }
}

export interface IBilateralDto {
    bilateralTests: BilateralTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateBookingInput implements ICreateBookingInput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    userId: number | undefined;
    lawFirmId: string | undefined;
    eventId: number | undefined;
    attorneyId: string | undefined;
    contactId: string | undefined;
    reason: string | undefined;

    constructor(data?: ICreateBookingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.userId = data["userId"];
            this.lawFirmId = data["lawFirmId"];
            this.eventId = data["eventId"];
            this.attorneyId = data["attorneyId"];
            this.contactId = data["contactId"];
            this.reason = data["reason"];
        }
    }

    static fromJS(data: any): CreateBookingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBookingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["userId"] = this.userId;
        data["lawFirmId"] = this.lawFirmId;
        data["eventId"] = this.eventId;
        data["attorneyId"] = this.attorneyId;
        data["contactId"] = this.contactId;
        data["reason"] = this.reason;
        return data; 
    }

    clone(): CreateBookingInput {
        const json = this.toJSON();
        let result = new CreateBookingInput();
        result.init(json);
        return result;
    }
}

export interface ICreateBookingInput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    userId: number | undefined;
    lawFirmId: string | undefined;
    eventId: number | undefined;
    attorneyId: string | undefined;
    contactId: string | undefined;
    reason: string | undefined;
}

export class BookingDetailOutput implements IBookingDetailOutput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    userId: number | undefined;
    user: User | undefined;
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    eventId: number | undefined;
    event: Event | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    changed: number | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBookingDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.eventId = data["eventId"];
            this.event = data["event"] ? Event.fromJS(data["event"]) : <any>undefined;
            this.attorneyId = data["attorneyId"];
            this.attorney = data["attorney"] ? Attorney.fromJS(data["attorney"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.changed = data["changed"];
            this.reason = data["reason"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BookingDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BookingDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["eventId"] = this.eventId;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["attorneyId"] = this.attorneyId;
        data["attorney"] = this.attorney ? this.attorney.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["changed"] = this.changed;
        data["reason"] = this.reason;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BookingDetailOutput {
        const json = this.toJSON();
        let result = new BookingDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IBookingDetailOutput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    userId: number | undefined;
    user: User | undefined;
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    eventId: number | undefined;
    event: Event | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    changed: number | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class BookingListDto implements IBookingListDto {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    userId: number | undefined;
    user: User | undefined;
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    eventId: number | undefined;
    attorneyId: string | undefined;
    event: Event | undefined;
    attorney: Attorney | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    changed: number | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBookingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.eventId = data["eventId"];
            this.attorneyId = data["attorneyId"];
            this.event = data["event"] ? Event.fromJS(data["event"]) : <any>undefined;
            this.attorney = data["attorney"] ? Attorney.fromJS(data["attorney"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.changed = data["changed"];
            this.reason = data["reason"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BookingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["eventId"] = this.eventId;
        data["attorneyId"] = this.attorneyId;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["attorney"] = this.attorney ? this.attorney.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["changed"] = this.changed;
        data["reason"] = this.reason;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BookingListDto {
        const json = this.toJSON();
        let result = new BookingListDto();
        result.init(json);
        return result;
    }
}

export interface IBookingListDto {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    userId: number | undefined;
    user: User | undefined;
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    eventId: number | undefined;
    attorneyId: string | undefined;
    event: Event | undefined;
    attorney: Attorney | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    changed: number | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfBookingListDto implements IListResultDtoOfBookingListDto {
    items: BookingListDto[] | undefined;

    constructor(data?: IListResultDtoOfBookingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BookingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfBookingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfBookingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfBookingListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfBookingListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfBookingListDto {
    items: BookingListDto[] | undefined;
}

export class CreateEventInput implements ICreateEventInput {
    name: string | undefined;

    constructor(data?: ICreateEventInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateEventInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEventInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateEventInput {
        const json = this.toJSON();
        let result = new CreateEventInput();
        result.init(json);
        return result;
    }
}

export interface ICreateEventInput {
    name: string | undefined;
}

export class ListResultDtoOfEventListDto implements IListResultDtoOfEventListDto {
    items: EventListDto[] | undefined;

    constructor(data?: IListResultDtoOfEventListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EventListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEventListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEventListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfEventListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfEventListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfEventListDto {
    items: EventListDto[] | undefined;
}

export class EventListDto implements IEventListDto {
    name: string | undefined;
    id: number | undefined;

    constructor(data?: IEventListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EventListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): EventListDto {
        const json = this.toJSON();
        let result = new EventListDto();
        result.init(json);
        return result;
    }
}

export interface IEventListDto {
    name: string | undefined;
    id: number | undefined;
}

export class EventDetailOutput implements IEventDetailOutput {
    name: string | undefined;
    id: number | undefined;

    constructor(data?: IEventDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EventDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EventDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): EventDetailOutput {
        const json = this.toJSON();
        let result = new EventDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IEventDetailOutput {
    name: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfBookingListDto implements IPagedResultDtoOfBookingListDto {
    totalCount: number | undefined;
    items: BookingListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBookingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BookingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBookingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBookingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfBookingListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfBookingListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfBookingListDto {
    totalCount: number | undefined;
    items: BookingListDto[] | undefined;
}

export class BorgBalanceOptionDto implements IBorgBalanceOptionDto {
    name: string | undefined;
    borgBalanceId: string | undefined;
    borgBalanceOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;

    constructor(data?: IBorgBalanceOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.borgBalanceId = data["borgBalanceId"];
            this.borgBalanceOptionScore = data["borgBalanceOptionScore"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): BorgBalanceOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorgBalanceOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["borgBalanceId"] = this.borgBalanceId;
        data["borgBalanceOptionScore"] = this.borgBalanceOptionScore;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        return data; 
    }

    clone(): BorgBalanceOptionDto {
        const json = this.toJSON();
        let result = new BorgBalanceOptionDto();
        result.init(json);
        return result;
    }
}

export interface IBorgBalanceOptionDto {
    name: string | undefined;
    borgBalanceId: string | undefined;
    borgBalanceOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
}

export class ListResultDtoOfBorgBalanceOptionListDto implements IListResultDtoOfBorgBalanceOptionListDto {
    items: BorgBalanceOptionListDto[] | undefined;

    constructor(data?: IListResultDtoOfBorgBalanceOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BorgBalanceOptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfBorgBalanceOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfBorgBalanceOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfBorgBalanceOptionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfBorgBalanceOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfBorgBalanceOptionListDto {
    items: BorgBalanceOptionListDto[] | undefined;
}

export class BorgBalanceOptionListDto implements IBorgBalanceOptionListDto {
    name: string | undefined;
    borgBalanceId: string | undefined;
    borgBalanceOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IBorgBalanceOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.borgBalanceId = data["borgBalanceId"];
            this.borgBalanceOptionScore = data["borgBalanceOptionScore"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BorgBalanceOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorgBalanceOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["borgBalanceId"] = this.borgBalanceId;
        data["borgBalanceOptionScore"] = this.borgBalanceOptionScore;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): BorgBalanceOptionListDto {
        const json = this.toJSON();
        let result = new BorgBalanceOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IBorgBalanceOptionListDto {
    name: string | undefined;
    borgBalanceId: string | undefined;
    borgBalanceOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class AssessmentResult implements IAssessmentResult {
    result: number | undefined;
    comment: string | undefined;

    constructor(data?: IAssessmentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): AssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): AssessmentResult {
        const json = this.toJSON();
        let result = new AssessmentResult();
        result.init(json);
        return result;
    }
}

export interface IAssessmentResult {
    result: number | undefined;
    comment: string | undefined;
}

export class CreateClientInput implements ICreateClientInput {
    lawFirmId: string | undefined;
    contactId: string | undefined;
    attorneyId: string | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: string | undefined;
    dob: moment.Moment | undefined;
    addressId: number | undefined;
    dateOfInjury: moment.Moment | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    generalAppearance: string | undefined;
    address: CreateAddressInput | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;

    constructor(data?: ICreateClientInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.contactId = data["contactId"];
            this.attorneyId = data["attorneyId"];
            this.courtDate = data["courtDate"] ? moment(data["courtDate"].toString()) : <any>undefined;
            this.caseNumber = data["caseNumber"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.title = data["title"];
            this.idNumber = data["idNumber"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.addressId = data["addressId"];
            this.dateOfInjury = data["dateOfInjury"] ? moment(data["dateOfInjury"].toString()) : <any>undefined;
            this.assessmentDate = data["assessmentDate"] ? moment(data["assessmentDate"].toString()) : <any>undefined;
            this.earlyChildhood = data["earlyChildhood"];
            this.family = data["family"];
            this.homeEnvironment = data["homeEnvironment"];
            this.education = data["education"];
            this.socialHabits = data["socialHabits"];
            this.currentComplaints = data["currentComplaints"];
            this.profilePictureId = data["profilePictureId"];
            this.affect = data["affect"];
            this.jobDescription = data["jobDescription"];
            this.motivation = data["motivation"];
            this.generalAppearance = data["generalAppearance"];
            this.address = data["address"] ? CreateAddressInput.fromJS(data["address"]) : <any>undefined;
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateClientInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["contactId"] = this.contactId;
        data["attorneyId"] = this.attorneyId;
        data["courtDate"] = this.courtDate ? this.courtDate.toISOString() : <any>undefined;
        data["caseNumber"] = this.caseNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["title"] = this.title;
        data["idNumber"] = this.idNumber;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        data["dateOfInjury"] = this.dateOfInjury ? this.dateOfInjury.toISOString() : <any>undefined;
        data["assessmentDate"] = this.assessmentDate ? this.assessmentDate.toISOString() : <any>undefined;
        data["earlyChildhood"] = this.earlyChildhood;
        data["family"] = this.family;
        data["homeEnvironment"] = this.homeEnvironment;
        data["education"] = this.education;
        data["socialHabits"] = this.socialHabits;
        data["currentComplaints"] = this.currentComplaints;
        data["profilePictureId"] = this.profilePictureId;
        data["affect"] = this.affect;
        data["jobDescription"] = this.jobDescription;
        data["motivation"] = this.motivation;
        data["generalAppearance"] = this.generalAppearance;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CreateClientInput {
        const json = this.toJSON();
        let result = new CreateClientInput();
        result.init(json);
        return result;
    }
}

export interface ICreateClientInput {
    lawFirmId: string | undefined;
    contactId: string | undefined;
    attorneyId: string | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: string | undefined;
    dob: moment.Moment | undefined;
    addressId: number | undefined;
    dateOfInjury: moment.Moment | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    generalAppearance: string | undefined;
    address: CreateAddressInput | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class CreateAddressInput implements ICreateAddressInput {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;

    constructor(data?: ICreateAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.city = data["city"];
            this.postalCode = data["postalCode"];
            this.province = data["province"];
        }
    }

    static fromJS(data: any): CreateAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["province"] = this.province;
        return data; 
    }

    clone(): CreateAddressInput {
        const json = this.toJSON();
        let result = new CreateAddressInput();
        result.init(json);
        return result;
    }
}

export interface ICreateAddressInput {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;
}

export class ClientDetailOutput implements IClientDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: string | undefined;
    dob: moment.Moment | undefined;
    dateOfInjury: moment.Moment | undefined;
    addressId: number | undefined;
    address: CreateAddressInput | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    generalAppearance: string | undefined;
    bookings: Booking[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IClientDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.attorneyId = data["attorneyId"];
            this.attorney = data["attorney"] ? Attorney.fromJS(data["attorney"]) : <any>undefined;
            this.courtDate = data["courtDate"] ? moment(data["courtDate"].toString()) : <any>undefined;
            this.caseNumber = data["caseNumber"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.title = data["title"];
            this.idNumber = data["idNumber"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.dateOfInjury = data["dateOfInjury"] ? moment(data["dateOfInjury"].toString()) : <any>undefined;
            this.addressId = data["addressId"];
            this.address = data["address"] ? CreateAddressInput.fromJS(data["address"]) : <any>undefined;
            this.assessmentDate = data["assessmentDate"] ? moment(data["assessmentDate"].toString()) : <any>undefined;
            this.earlyChildhood = data["earlyChildhood"];
            this.family = data["family"];
            this.homeEnvironment = data["homeEnvironment"];
            this.education = data["education"];
            this.socialHabits = data["socialHabits"];
            this.currentComplaints = data["currentComplaints"];
            this.profilePictureId = data["profilePictureId"];
            this.affect = data["affect"];
            this.jobDescription = data["jobDescription"];
            this.motivation = data["motivation"];
            this.generalAppearance = data["generalAppearance"];
            if (data["bookings"] && data["bookings"].constructor === Array) {
                this.bookings = [];
                for (let item of data["bookings"])
                    this.bookings.push(Booking.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ClientDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["attorneyId"] = this.attorneyId;
        data["attorney"] = this.attorney ? this.attorney.toJSON() : <any>undefined;
        data["courtDate"] = this.courtDate ? this.courtDate.toISOString() : <any>undefined;
        data["caseNumber"] = this.caseNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["title"] = this.title;
        data["idNumber"] = this.idNumber;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["dateOfInjury"] = this.dateOfInjury ? this.dateOfInjury.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["assessmentDate"] = this.assessmentDate ? this.assessmentDate.toISOString() : <any>undefined;
        data["earlyChildhood"] = this.earlyChildhood;
        data["family"] = this.family;
        data["homeEnvironment"] = this.homeEnvironment;
        data["education"] = this.education;
        data["socialHabits"] = this.socialHabits;
        data["currentComplaints"] = this.currentComplaints;
        data["profilePictureId"] = this.profilePictureId;
        data["affect"] = this.affect;
        data["jobDescription"] = this.jobDescription;
        data["motivation"] = this.motivation;
        data["generalAppearance"] = this.generalAppearance;
        if (this.bookings && this.bookings.constructor === Array) {
            data["bookings"] = [];
            for (let item of this.bookings)
                data["bookings"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientDetailOutput {
        const json = this.toJSON();
        let result = new ClientDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IClientDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: string | undefined;
    dob: moment.Moment | undefined;
    dateOfInjury: moment.Moment | undefined;
    addressId: number | undefined;
    address: CreateAddressInput | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    generalAppearance: string | undefined;
    bookings: Booking[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfClientListDto implements IPagedResultDtoOfClientListDto {
    totalCount: number | undefined;
    items: ClientListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfClientListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ClientListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfClientListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfClientListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfClientListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfClientListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfClientListDto {
    totalCount: number | undefined;
    items: ClientListDto[] | undefined;
}

export class ClientListDto implements IClientListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirmDto | undefined;
    contactId: string | undefined;
    contact: ContactDto | undefined;
    attorneyId: string | undefined;
    attorney: AttorneyDto | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: string | undefined;
    dob: moment.Moment | undefined;
    dateOfInjury: moment.Moment | undefined;
    address: Address | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    generalAppearance: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IClientListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirmDto.fromJS(data["lawFirm"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? ContactDto.fromJS(data["contact"]) : <any>undefined;
            this.attorneyId = data["attorneyId"];
            this.attorney = data["attorney"] ? AttorneyDto.fromJS(data["attorney"]) : <any>undefined;
            this.courtDate = data["courtDate"] ? moment(data["courtDate"].toString()) : <any>undefined;
            this.caseNumber = data["caseNumber"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.title = data["title"];
            this.idNumber = data["idNumber"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.dateOfInjury = data["dateOfInjury"] ? moment(data["dateOfInjury"].toString()) : <any>undefined;
            this.address = data["address"] ? Address.fromJS(data["address"]) : <any>undefined;
            this.assessmentDate = data["assessmentDate"] ? moment(data["assessmentDate"].toString()) : <any>undefined;
            this.earlyChildhood = data["earlyChildhood"];
            this.family = data["family"];
            this.homeEnvironment = data["homeEnvironment"];
            this.education = data["education"];
            this.socialHabits = data["socialHabits"];
            this.currentComplaints = data["currentComplaints"];
            this.profilePictureId = data["profilePictureId"];
            this.affect = data["affect"];
            this.jobDescription = data["jobDescription"];
            this.motivation = data["motivation"];
            this.generalAppearance = data["generalAppearance"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ClientListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["attorneyId"] = this.attorneyId;
        data["attorney"] = this.attorney ? this.attorney.toJSON() : <any>undefined;
        data["courtDate"] = this.courtDate ? this.courtDate.toISOString() : <any>undefined;
        data["caseNumber"] = this.caseNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["title"] = this.title;
        data["idNumber"] = this.idNumber;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["dateOfInjury"] = this.dateOfInjury ? this.dateOfInjury.toISOString() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["assessmentDate"] = this.assessmentDate ? this.assessmentDate.toISOString() : <any>undefined;
        data["earlyChildhood"] = this.earlyChildhood;
        data["family"] = this.family;
        data["homeEnvironment"] = this.homeEnvironment;
        data["education"] = this.education;
        data["socialHabits"] = this.socialHabits;
        data["currentComplaints"] = this.currentComplaints;
        data["profilePictureId"] = this.profilePictureId;
        data["affect"] = this.affect;
        data["jobDescription"] = this.jobDescription;
        data["motivation"] = this.motivation;
        data["generalAppearance"] = this.generalAppearance;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientListDto {
        const json = this.toJSON();
        let result = new ClientListDto();
        result.init(json);
        return result;
    }
}

export interface IClientListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirmDto | undefined;
    contactId: string | undefined;
    contact: ContactDto | undefined;
    attorneyId: string | undefined;
    attorney: AttorneyDto | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: string | undefined;
    dob: moment.Moment | undefined;
    dateOfInjury: moment.Moment | undefined;
    address: Address | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    generalAppearance: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class LawFirmDto implements ILawFirmDto {
    companyName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;

    constructor(data?: ILawFirmDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.fax = data["fax"];
        }
    }

    static fromJS(data: any): LawFirmDto {
        data = typeof data === 'object' ? data : {};
        let result = new LawFirmDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        return data; 
    }

    clone(): LawFirmDto {
        const json = this.toJSON();
        let result = new LawFirmDto();
        result.init(json);
        return result;
    }
}

export interface ILawFirmDto {
    companyName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
}

export class ContactDto implements IContactDto {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.role = data["role"];
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["role"] = this.role;
        return data; 
    }

    clone(): ContactDto {
        const json = this.toJSON();
        let result = new ContactDto();
        result.init(json);
        return result;
    }
}

export interface IContactDto {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
}

export class AttorneyDto implements IAttorneyDto {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;

    constructor(data?: IAttorneyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cellphone = data["cellphone"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.fax = data["fax"];
        }
    }

    static fromJS(data: any): AttorneyDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttorneyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cellphone"] = this.cellphone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fax"] = this.fax;
        return data; 
    }

    clone(): AttorneyDto {
        const json = this.toJSON();
        let result = new AttorneyDto();
        result.init(json);
        return result;
    }
}

export interface IAttorneyDto {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
}

export class ListResultDtoOfClientListDto implements IListResultDtoOfClientListDto {
    items: ClientListDto[] | undefined;

    constructor(data?: IListResultDtoOfClientListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ClientListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfClientListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfClientListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfClientListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfClientListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfClientListDto {
    items: ClientListDto[] | undefined;
}

export class CreateWorkHistoryInput implements ICreateWorkHistoryInput {
    clientId: string | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;

    constructor(data?: ICreateWorkHistoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.premorbid = data["premorbid"];
            this.postMorbid = data["postMorbid"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): CreateWorkHistoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkHistoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["premorbid"] = this.premorbid;
        data["postMorbid"] = this.postMorbid;
        data["description"] = this.description;
        return data; 
    }

    clone(): CreateWorkHistoryInput {
        const json = this.toJSON();
        let result = new CreateWorkHistoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateWorkHistoryInput {
    clientId: string | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;
}

export class WorkHistoryDetailOutput implements IWorkHistoryDetailOutput {
    clientId: string | undefined;
    client: Client | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;
    id: string | undefined;

    constructor(data?: IWorkHistoryDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.premorbid = data["premorbid"];
            this.postMorbid = data["postMorbid"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkHistoryDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WorkHistoryDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["premorbid"] = this.premorbid;
        data["postMorbid"] = this.postMorbid;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): WorkHistoryDetailOutput {
        const json = this.toJSON();
        let result = new WorkHistoryDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IWorkHistoryDetailOutput {
    clientId: string | undefined;
    client: Client | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;
    id: string | undefined;
}

export class WorkHistoryListDto implements IWorkHistoryListDto {
    clientId: string | undefined;
    client: Client | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;
    id: string | undefined;

    constructor(data?: IWorkHistoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.premorbid = data["premorbid"];
            this.postMorbid = data["postMorbid"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkHistoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkHistoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["premorbid"] = this.premorbid;
        data["postMorbid"] = this.postMorbid;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): WorkHistoryListDto {
        const json = this.toJSON();
        let result = new WorkHistoryListDto();
        result.init(json);
        return result;
    }
}

export interface IWorkHistoryListDto {
    clientId: string | undefined;
    client: Client | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;
    id: string | undefined;
}

export class CreateMedicalHistoryInput implements ICreateMedicalHistoryInput {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    clinicalObservation: string | undefined;
    medication: string | undefined;

    constructor(data?: ICreateMedicalHistoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.previousInjuries = data["previousInjuries"];
            this.clientId = data["clientId"];
            this.medicalConditions = data["medicalConditions"];
            this.currentHistory = data["currentHistory"];
            this.clinicalObservation = data["clinicalObservation"];
            this.medication = data["medication"];
        }
    }

    static fromJS(data: any): CreateMedicalHistoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMedicalHistoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["previousInjuries"] = this.previousInjuries;
        data["clientId"] = this.clientId;
        data["medicalConditions"] = this.medicalConditions;
        data["currentHistory"] = this.currentHistory;
        data["clinicalObservation"] = this.clinicalObservation;
        data["medication"] = this.medication;
        return data; 
    }

    clone(): CreateMedicalHistoryInput {
        const json = this.toJSON();
        let result = new CreateMedicalHistoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateMedicalHistoryInput {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    clinicalObservation: string | undefined;
    medication: string | undefined;
}

export class MedicalHistoryDetailOutput implements IMedicalHistoryDetailOutput {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    clinicalObservation: string | undefined;
    medication: string | undefined;
    id: string | undefined;

    constructor(data?: IMedicalHistoryDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.previousInjuries = data["previousInjuries"];
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.medicalConditions = data["medicalConditions"];
            this.currentHistory = data["currentHistory"];
            this.clinicalObservation = data["clinicalObservation"];
            this.medication = data["medication"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MedicalHistoryDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MedicalHistoryDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["previousInjuries"] = this.previousInjuries;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["medicalConditions"] = this.medicalConditions;
        data["currentHistory"] = this.currentHistory;
        data["clinicalObservation"] = this.clinicalObservation;
        data["medication"] = this.medication;
        data["id"] = this.id;
        return data; 
    }

    clone(): MedicalHistoryDetailOutput {
        const json = this.toJSON();
        let result = new MedicalHistoryDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IMedicalHistoryDetailOutput {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    clinicalObservation: string | undefined;
    medication: string | undefined;
    id: string | undefined;
}

export class MedicalHistoryListDto implements IMedicalHistoryListDto {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    clinicalObservation: string | undefined;
    medication: string | undefined;
    id: string | undefined;

    constructor(data?: IMedicalHistoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.previousInjuries = data["previousInjuries"];
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.medicalConditions = data["medicalConditions"];
            this.currentHistory = data["currentHistory"];
            this.clinicalObservation = data["clinicalObservation"];
            this.medication = data["medication"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MedicalHistoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicalHistoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["previousInjuries"] = this.previousInjuries;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["medicalConditions"] = this.medicalConditions;
        data["currentHistory"] = this.currentHistory;
        data["clinicalObservation"] = this.clinicalObservation;
        data["medication"] = this.medication;
        data["id"] = this.id;
        return data; 
    }

    clone(): MedicalHistoryListDto {
        const json = this.toJSON();
        let result = new MedicalHistoryListDto();
        result.init(json);
        return result;
    }
}

export interface IMedicalHistoryListDto {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    clinicalObservation: string | undefined;
    medication: string | undefined;
    id: string | undefined;
}

export class AssessmentReportDto implements IAssessmentReportDto {
    reportGripStrength: ReportGripStrength | undefined;
    reportRoMAnkle: ReportRoMAnkleDto[] | undefined;
    reportRoMForearmWrist: ReportRoMForearmWristDto[] | undefined;
    reportRoMHand: ReportRoMHandDto[] | undefined;
    reportRoMHip: ReportRoMHipDto[] | undefined;
    reportRoMKnee: ReportRoMKneeDto[] | undefined;
    reportRoMShoulder: ReportRoMShoulderDto[] | undefined;
    reportRoMElbow: ReportRoMElbowDto[] | undefined;
    balanceProtocolReport: string | undefined;
    borgBalanceReport: string | undefined;
    coordinationReport: string | undefined;
    crawlingProtocolReport: string | undefined;
    gaitReport: string | undefined;
    gripStrengthReport: string | undefined;
    ladderWorkProtocolReport: string | undefined;
    musclePowerReport: string | undefined;
    postureReport: string | undefined;
    repetitiveFootMotionProtocolReport: string | undefined;
    repetitiveSquattingProtocolReport: string | undefined;
    roMAnkleReport: string | undefined;
    roMElbowReport: string | undefined;
    roMForearmWristReport: string | undefined;
    roMHandReport: string | undefined;
    roMHipReport: string | undefined;
    roMKneeReport: string | undefined;
    roMShoulderReport: string | undefined;
    sensationLowerReport: string | undefined;
    sensationTrunkReport: string | undefined;
    sensationUpperReport: string | undefined;
    stairClimbingProtocolReport: string | undefined;
    walkingProtocolReport: string | undefined;
    attentionAndConcentration: CogntiveReportDto | undefined;
    shortTermMemory: CogntiveReportDto | undefined;
    longTermMemory: CogntiveReportDto | undefined;
    reading: CogntiveReportDto | undefined;
    insight: CogntiveReportDto | undefined;
    speech: CogntiveReportDto | undefined;
    writing: CogntiveReportDto | undefined;
    visualPerception: CogntiveReportDto | undefined;
    personalCare: string | undefined;
    sleeping: string | undefined;
    homeManagement: string | undefined;
    leisure: string | undefined;
    driving: string | undefined;

    constructor(data?: IAssessmentReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportGripStrength = data["reportGripStrength"] ? ReportGripStrength.fromJS(data["reportGripStrength"]) : <any>undefined;
            if (data["reportRoMAnkle"] && data["reportRoMAnkle"].constructor === Array) {
                this.reportRoMAnkle = [];
                for (let item of data["reportRoMAnkle"])
                    this.reportRoMAnkle.push(ReportRoMAnkleDto.fromJS(item));
            }
            if (data["reportRoMForearmWrist"] && data["reportRoMForearmWrist"].constructor === Array) {
                this.reportRoMForearmWrist = [];
                for (let item of data["reportRoMForearmWrist"])
                    this.reportRoMForearmWrist.push(ReportRoMForearmWristDto.fromJS(item));
            }
            if (data["reportRoMHand"] && data["reportRoMHand"].constructor === Array) {
                this.reportRoMHand = [];
                for (let item of data["reportRoMHand"])
                    this.reportRoMHand.push(ReportRoMHandDto.fromJS(item));
            }
            if (data["reportRoMHip"] && data["reportRoMHip"].constructor === Array) {
                this.reportRoMHip = [];
                for (let item of data["reportRoMHip"])
                    this.reportRoMHip.push(ReportRoMHipDto.fromJS(item));
            }
            if (data["reportRoMKnee"] && data["reportRoMKnee"].constructor === Array) {
                this.reportRoMKnee = [];
                for (let item of data["reportRoMKnee"])
                    this.reportRoMKnee.push(ReportRoMKneeDto.fromJS(item));
            }
            if (data["reportRoMShoulder"] && data["reportRoMShoulder"].constructor === Array) {
                this.reportRoMShoulder = [];
                for (let item of data["reportRoMShoulder"])
                    this.reportRoMShoulder.push(ReportRoMShoulderDto.fromJS(item));
            }
            if (data["reportRoMElbow"] && data["reportRoMElbow"].constructor === Array) {
                this.reportRoMElbow = [];
                for (let item of data["reportRoMElbow"])
                    this.reportRoMElbow.push(ReportRoMElbowDto.fromJS(item));
            }
            this.balanceProtocolReport = data["balanceProtocolReport"];
            this.borgBalanceReport = data["borgBalanceReport"];
            this.coordinationReport = data["coordinationReport"];
            this.crawlingProtocolReport = data["crawlingProtocolReport"];
            this.gaitReport = data["gaitReport"];
            this.gripStrengthReport = data["gripStrengthReport"];
            this.ladderWorkProtocolReport = data["ladderWorkProtocolReport"];
            this.musclePowerReport = data["musclePowerReport"];
            this.postureReport = data["postureReport"];
            this.repetitiveFootMotionProtocolReport = data["repetitiveFootMotionProtocolReport"];
            this.repetitiveSquattingProtocolReport = data["repetitiveSquattingProtocolReport"];
            this.roMAnkleReport = data["roMAnkleReport"];
            this.roMElbowReport = data["roMElbowReport"];
            this.roMForearmWristReport = data["roMForearmWristReport"];
            this.roMHandReport = data["roMHandReport"];
            this.roMHipReport = data["roMHipReport"];
            this.roMKneeReport = data["roMKneeReport"];
            this.roMShoulderReport = data["roMShoulderReport"];
            this.sensationLowerReport = data["sensationLowerReport"];
            this.sensationTrunkReport = data["sensationTrunkReport"];
            this.sensationUpperReport = data["sensationUpperReport"];
            this.stairClimbingProtocolReport = data["stairClimbingProtocolReport"];
            this.walkingProtocolReport = data["walkingProtocolReport"];
            this.attentionAndConcentration = data["attentionAndConcentration"] ? CogntiveReportDto.fromJS(data["attentionAndConcentration"]) : <any>undefined;
            this.shortTermMemory = data["shortTermMemory"] ? CogntiveReportDto.fromJS(data["shortTermMemory"]) : <any>undefined;
            this.longTermMemory = data["longTermMemory"] ? CogntiveReportDto.fromJS(data["longTermMemory"]) : <any>undefined;
            this.reading = data["reading"] ? CogntiveReportDto.fromJS(data["reading"]) : <any>undefined;
            this.insight = data["insight"] ? CogntiveReportDto.fromJS(data["insight"]) : <any>undefined;
            this.speech = data["speech"] ? CogntiveReportDto.fromJS(data["speech"]) : <any>undefined;
            this.writing = data["writing"] ? CogntiveReportDto.fromJS(data["writing"]) : <any>undefined;
            this.visualPerception = data["visualPerception"] ? CogntiveReportDto.fromJS(data["visualPerception"]) : <any>undefined;
            this.personalCare = data["personalCare"];
            this.sleeping = data["sleeping"];
            this.homeManagement = data["homeManagement"];
            this.leisure = data["leisure"];
            this.driving = data["driving"];
        }
    }

    static fromJS(data: any): AssessmentReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportGripStrength"] = this.reportGripStrength ? this.reportGripStrength.toJSON() : <any>undefined;
        if (this.reportRoMAnkle && this.reportRoMAnkle.constructor === Array) {
            data["reportRoMAnkle"] = [];
            for (let item of this.reportRoMAnkle)
                data["reportRoMAnkle"].push(item.toJSON());
        }
        if (this.reportRoMForearmWrist && this.reportRoMForearmWrist.constructor === Array) {
            data["reportRoMForearmWrist"] = [];
            for (let item of this.reportRoMForearmWrist)
                data["reportRoMForearmWrist"].push(item.toJSON());
        }
        if (this.reportRoMHand && this.reportRoMHand.constructor === Array) {
            data["reportRoMHand"] = [];
            for (let item of this.reportRoMHand)
                data["reportRoMHand"].push(item.toJSON());
        }
        if (this.reportRoMHip && this.reportRoMHip.constructor === Array) {
            data["reportRoMHip"] = [];
            for (let item of this.reportRoMHip)
                data["reportRoMHip"].push(item.toJSON());
        }
        if (this.reportRoMKnee && this.reportRoMKnee.constructor === Array) {
            data["reportRoMKnee"] = [];
            for (let item of this.reportRoMKnee)
                data["reportRoMKnee"].push(item.toJSON());
        }
        if (this.reportRoMShoulder && this.reportRoMShoulder.constructor === Array) {
            data["reportRoMShoulder"] = [];
            for (let item of this.reportRoMShoulder)
                data["reportRoMShoulder"].push(item.toJSON());
        }
        if (this.reportRoMElbow && this.reportRoMElbow.constructor === Array) {
            data["reportRoMElbow"] = [];
            for (let item of this.reportRoMElbow)
                data["reportRoMElbow"].push(item.toJSON());
        }
        data["balanceProtocolReport"] = this.balanceProtocolReport;
        data["borgBalanceReport"] = this.borgBalanceReport;
        data["coordinationReport"] = this.coordinationReport;
        data["crawlingProtocolReport"] = this.crawlingProtocolReport;
        data["gaitReport"] = this.gaitReport;
        data["gripStrengthReport"] = this.gripStrengthReport;
        data["ladderWorkProtocolReport"] = this.ladderWorkProtocolReport;
        data["musclePowerReport"] = this.musclePowerReport;
        data["postureReport"] = this.postureReport;
        data["repetitiveFootMotionProtocolReport"] = this.repetitiveFootMotionProtocolReport;
        data["repetitiveSquattingProtocolReport"] = this.repetitiveSquattingProtocolReport;
        data["roMAnkleReport"] = this.roMAnkleReport;
        data["roMElbowReport"] = this.roMElbowReport;
        data["roMForearmWristReport"] = this.roMForearmWristReport;
        data["roMHandReport"] = this.roMHandReport;
        data["roMHipReport"] = this.roMHipReport;
        data["roMKneeReport"] = this.roMKneeReport;
        data["roMShoulderReport"] = this.roMShoulderReport;
        data["sensationLowerReport"] = this.sensationLowerReport;
        data["sensationTrunkReport"] = this.sensationTrunkReport;
        data["sensationUpperReport"] = this.sensationUpperReport;
        data["stairClimbingProtocolReport"] = this.stairClimbingProtocolReport;
        data["walkingProtocolReport"] = this.walkingProtocolReport;
        data["attentionAndConcentration"] = this.attentionAndConcentration ? this.attentionAndConcentration.toJSON() : <any>undefined;
        data["shortTermMemory"] = this.shortTermMemory ? this.shortTermMemory.toJSON() : <any>undefined;
        data["longTermMemory"] = this.longTermMemory ? this.longTermMemory.toJSON() : <any>undefined;
        data["reading"] = this.reading ? this.reading.toJSON() : <any>undefined;
        data["insight"] = this.insight ? this.insight.toJSON() : <any>undefined;
        data["speech"] = this.speech ? this.speech.toJSON() : <any>undefined;
        data["writing"] = this.writing ? this.writing.toJSON() : <any>undefined;
        data["visualPerception"] = this.visualPerception ? this.visualPerception.toJSON() : <any>undefined;
        data["personalCare"] = this.personalCare;
        data["sleeping"] = this.sleeping;
        data["homeManagement"] = this.homeManagement;
        data["leisure"] = this.leisure;
        data["driving"] = this.driving;
        return data; 
    }

    clone(): AssessmentReportDto {
        const json = this.toJSON();
        let result = new AssessmentReportDto();
        result.init(json);
        return result;
    }
}

export interface IAssessmentReportDto {
    reportGripStrength: ReportGripStrength | undefined;
    reportRoMAnkle: ReportRoMAnkleDto[] | undefined;
    reportRoMForearmWrist: ReportRoMForearmWristDto[] | undefined;
    reportRoMHand: ReportRoMHandDto[] | undefined;
    reportRoMHip: ReportRoMHipDto[] | undefined;
    reportRoMKnee: ReportRoMKneeDto[] | undefined;
    reportRoMShoulder: ReportRoMShoulderDto[] | undefined;
    reportRoMElbow: ReportRoMElbowDto[] | undefined;
    balanceProtocolReport: string | undefined;
    borgBalanceReport: string | undefined;
    coordinationReport: string | undefined;
    crawlingProtocolReport: string | undefined;
    gaitReport: string | undefined;
    gripStrengthReport: string | undefined;
    ladderWorkProtocolReport: string | undefined;
    musclePowerReport: string | undefined;
    postureReport: string | undefined;
    repetitiveFootMotionProtocolReport: string | undefined;
    repetitiveSquattingProtocolReport: string | undefined;
    roMAnkleReport: string | undefined;
    roMElbowReport: string | undefined;
    roMForearmWristReport: string | undefined;
    roMHandReport: string | undefined;
    roMHipReport: string | undefined;
    roMKneeReport: string | undefined;
    roMShoulderReport: string | undefined;
    sensationLowerReport: string | undefined;
    sensationTrunkReport: string | undefined;
    sensationUpperReport: string | undefined;
    stairClimbingProtocolReport: string | undefined;
    walkingProtocolReport: string | undefined;
    attentionAndConcentration: CogntiveReportDto | undefined;
    shortTermMemory: CogntiveReportDto | undefined;
    longTermMemory: CogntiveReportDto | undefined;
    reading: CogntiveReportDto | undefined;
    insight: CogntiveReportDto | undefined;
    speech: CogntiveReportDto | undefined;
    writing: CogntiveReportDto | undefined;
    visualPerception: CogntiveReportDto | undefined;
    personalCare: string | undefined;
    sleeping: string | undefined;
    homeManagement: string | undefined;
    leisure: string | undefined;
    driving: string | undefined;
}

export class ReportGripStrength implements IReportGripStrength {
    rightHandMachineTest: number | undefined;
    leftHandMachineTest: number | undefined;
    normRight: number | undefined;
    normLeft: number | undefined;
    chosen: boolean | undefined;

    constructor(data?: IReportGripStrength) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rightHandMachineTest = data["rightHandMachineTest"];
            this.leftHandMachineTest = data["leftHandMachineTest"];
            this.normRight = data["normRight"];
            this.normLeft = data["normLeft"];
            this.chosen = data["chosen"];
        }
    }

    static fromJS(data: any): ReportGripStrength {
        data = typeof data === 'object' ? data : {};
        let result = new ReportGripStrength();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rightHandMachineTest"] = this.rightHandMachineTest;
        data["leftHandMachineTest"] = this.leftHandMachineTest;
        data["normRight"] = this.normRight;
        data["normLeft"] = this.normLeft;
        data["chosen"] = this.chosen;
        return data; 
    }

    clone(): ReportGripStrength {
        const json = this.toJSON();
        let result = new ReportGripStrength();
        result.init(json);
        return result;
    }
}

export interface IReportGripStrength {
    rightHandMachineTest: number | undefined;
    leftHandMachineTest: number | undefined;
    normRight: number | undefined;
    normLeft: number | undefined;
    chosen: boolean | undefined;
}

export class ReportRoMAnkleDto implements IReportRoMAnkleDto {
    dorsiflexion: string | undefined;
    plantarFlexion: string | undefined;
    dorsiMusclePower: number | undefined;
    plantarMusclePower: number | undefined;
    inversion: string | undefined;
    invMusclePower: number | undefined;
    eversion: string | undefined;
    evMusclePower: number | undefined;
    rangeOfMotionId: string | undefined;
    chosen: boolean | undefined;
    side: number | undefined;

    constructor(data?: IReportRoMAnkleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dorsiflexion = data["dorsiflexion"];
            this.plantarFlexion = data["plantarFlexion"];
            this.dorsiMusclePower = data["dorsiMusclePower"];
            this.plantarMusclePower = data["plantarMusclePower"];
            this.inversion = data["inversion"];
            this.invMusclePower = data["invMusclePower"];
            this.eversion = data["eversion"];
            this.evMusclePower = data["evMusclePower"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.chosen = data["chosen"];
            this.side = data["side"];
        }
    }

    static fromJS(data: any): ReportRoMAnkleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportRoMAnkleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dorsiflexion"] = this.dorsiflexion;
        data["plantarFlexion"] = this.plantarFlexion;
        data["dorsiMusclePower"] = this.dorsiMusclePower;
        data["plantarMusclePower"] = this.plantarMusclePower;
        data["inversion"] = this.inversion;
        data["invMusclePower"] = this.invMusclePower;
        data["eversion"] = this.eversion;
        data["evMusclePower"] = this.evMusclePower;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["chosen"] = this.chosen;
        data["side"] = this.side;
        return data; 
    }

    clone(): ReportRoMAnkleDto {
        const json = this.toJSON();
        let result = new ReportRoMAnkleDto();
        result.init(json);
        return result;
    }
}

export interface IReportRoMAnkleDto {
    dorsiflexion: string | undefined;
    plantarFlexion: string | undefined;
    dorsiMusclePower: number | undefined;
    plantarMusclePower: number | undefined;
    inversion: string | undefined;
    invMusclePower: number | undefined;
    eversion: string | undefined;
    evMusclePower: number | undefined;
    rangeOfMotionId: string | undefined;
    chosen: boolean | undefined;
    side: number | undefined;
}

export class ReportRoMForearmWristDto implements IReportRoMForearmWristDto {
    extension: string | undefined;
    flexion: string | undefined;
    pronation: string | undefined;
    supination: string | undefined;
    radialDeviation: string | undefined;
    ulnarDeviation: string | undefined;
    extMusclePower: number | undefined;
    flexMusclePower: number | undefined;
    proMusclePower: number | undefined;
    supMusclePower: number | undefined;
    radMusclePower: number | undefined;
    ulnMusclePower: number | undefined;
    rangeOfMotionId: string | undefined;
    chosen: boolean | undefined;
    side: number | undefined;

    constructor(data?: IReportRoMForearmWristDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.extension = data["extension"];
            this.flexion = data["flexion"];
            this.pronation = data["pronation"];
            this.supination = data["supination"];
            this.radialDeviation = data["radialDeviation"];
            this.ulnarDeviation = data["ulnarDeviation"];
            this.extMusclePower = data["extMusclePower"];
            this.flexMusclePower = data["flexMusclePower"];
            this.proMusclePower = data["proMusclePower"];
            this.supMusclePower = data["supMusclePower"];
            this.radMusclePower = data["radMusclePower"];
            this.ulnMusclePower = data["ulnMusclePower"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.chosen = data["chosen"];
            this.side = data["side"];
        }
    }

    static fromJS(data: any): ReportRoMForearmWristDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportRoMForearmWristDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["extension"] = this.extension;
        data["flexion"] = this.flexion;
        data["pronation"] = this.pronation;
        data["supination"] = this.supination;
        data["radialDeviation"] = this.radialDeviation;
        data["ulnarDeviation"] = this.ulnarDeviation;
        data["extMusclePower"] = this.extMusclePower;
        data["flexMusclePower"] = this.flexMusclePower;
        data["proMusclePower"] = this.proMusclePower;
        data["supMusclePower"] = this.supMusclePower;
        data["radMusclePower"] = this.radMusclePower;
        data["ulnMusclePower"] = this.ulnMusclePower;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["chosen"] = this.chosen;
        data["side"] = this.side;
        return data; 
    }

    clone(): ReportRoMForearmWristDto {
        const json = this.toJSON();
        let result = new ReportRoMForearmWristDto();
        result.init(json);
        return result;
    }
}

export interface IReportRoMForearmWristDto {
    extension: string | undefined;
    flexion: string | undefined;
    pronation: string | undefined;
    supination: string | undefined;
    radialDeviation: string | undefined;
    ulnarDeviation: string | undefined;
    extMusclePower: number | undefined;
    flexMusclePower: number | undefined;
    proMusclePower: number | undefined;
    supMusclePower: number | undefined;
    radMusclePower: number | undefined;
    ulnMusclePower: number | undefined;
    rangeOfMotionId: string | undefined;
    chosen: boolean | undefined;
    side: number | undefined;
}

export class ReportRoMHandDto implements IReportRoMHandDto {
    mpFlexion: number | undefined;
    pipFlexionExtension: number | undefined;
    dipFlexionExtension: number | undefined;
    mpHyperExtension: number | undefined;
    abduction: number | undefined;
    adduction: number | undefined;
    opposition: number | undefined;
    painLevel: number | undefined;
    position: number | undefined;
    comment: string | undefined;
    cmExtension: number | undefined;
    cmFlexion: number | undefined;
    ipFlexionExtension: number | undefined;
    ringFingerScore: number | undefined;
    rangeOfMotionId: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    id: string | undefined;

    constructor(data?: IReportRoMHandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mpFlexion = data["mpFlexion"];
            this.pipFlexionExtension = data["pipFlexionExtension"];
            this.dipFlexionExtension = data["dipFlexionExtension"];
            this.mpHyperExtension = data["mpHyperExtension"];
            this.abduction = data["abduction"];
            this.adduction = data["adduction"];
            this.opposition = data["opposition"];
            this.painLevel = data["painLevel"];
            this.position = data["position"];
            this.comment = data["comment"];
            this.cmExtension = data["cmExtension"];
            this.cmFlexion = data["cmFlexion"];
            this.ipFlexionExtension = data["ipFlexionExtension"];
            this.ringFingerScore = data["ringFingerScore"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.side = data["side"];
            this.chosen = data["chosen"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ReportRoMHandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportRoMHandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mpFlexion"] = this.mpFlexion;
        data["pipFlexionExtension"] = this.pipFlexionExtension;
        data["dipFlexionExtension"] = this.dipFlexionExtension;
        data["mpHyperExtension"] = this.mpHyperExtension;
        data["abduction"] = this.abduction;
        data["adduction"] = this.adduction;
        data["opposition"] = this.opposition;
        data["painLevel"] = this.painLevel;
        data["position"] = this.position;
        data["comment"] = this.comment;
        data["cmExtension"] = this.cmExtension;
        data["cmFlexion"] = this.cmFlexion;
        data["ipFlexionExtension"] = this.ipFlexionExtension;
        data["ringFingerScore"] = this.ringFingerScore;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["side"] = this.side;
        data["chosen"] = this.chosen;
        data["id"] = this.id;
        return data; 
    }

    clone(): ReportRoMHandDto {
        const json = this.toJSON();
        let result = new ReportRoMHandDto();
        result.init(json);
        return result;
    }
}

export interface IReportRoMHandDto {
    mpFlexion: number | undefined;
    pipFlexionExtension: number | undefined;
    dipFlexionExtension: number | undefined;
    mpHyperExtension: number | undefined;
    abduction: number | undefined;
    adduction: number | undefined;
    opposition: number | undefined;
    painLevel: number | undefined;
    position: number | undefined;
    comment: string | undefined;
    cmExtension: number | undefined;
    cmFlexion: number | undefined;
    ipFlexionExtension: number | undefined;
    ringFingerScore: number | undefined;
    rangeOfMotionId: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    id: string | undefined;
}

export class ReportRoMHipDto implements IReportRoMHipDto {
    extension: string | undefined;
    flexion: string | undefined;
    abduction: string | undefined;
    adduction: string | undefined;
    extMusclePower: number | undefined;
    flexMusclePower: number | undefined;
    abdMusclePower: number | undefined;
    addMusclePower: number | undefined;
    internalRotation: string | undefined;
    irMusclePower: number | undefined;
    externalRotation: string | undefined;
    erMusclePower: number | undefined;
    rangeOfMotionId: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;

    constructor(data?: IReportRoMHipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.extension = data["extension"];
            this.flexion = data["flexion"];
            this.abduction = data["abduction"];
            this.adduction = data["adduction"];
            this.extMusclePower = data["extMusclePower"];
            this.flexMusclePower = data["flexMusclePower"];
            this.abdMusclePower = data["abdMusclePower"];
            this.addMusclePower = data["addMusclePower"];
            this.internalRotation = data["internalRotation"];
            this.irMusclePower = data["irMusclePower"];
            this.externalRotation = data["externalRotation"];
            this.erMusclePower = data["erMusclePower"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.side = data["side"];
            this.chosen = data["chosen"];
        }
    }

    static fromJS(data: any): ReportRoMHipDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportRoMHipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["extension"] = this.extension;
        data["flexion"] = this.flexion;
        data["abduction"] = this.abduction;
        data["adduction"] = this.adduction;
        data["extMusclePower"] = this.extMusclePower;
        data["flexMusclePower"] = this.flexMusclePower;
        data["abdMusclePower"] = this.abdMusclePower;
        data["addMusclePower"] = this.addMusclePower;
        data["internalRotation"] = this.internalRotation;
        data["irMusclePower"] = this.irMusclePower;
        data["externalRotation"] = this.externalRotation;
        data["erMusclePower"] = this.erMusclePower;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["side"] = this.side;
        data["chosen"] = this.chosen;
        return data; 
    }

    clone(): ReportRoMHipDto {
        const json = this.toJSON();
        let result = new ReportRoMHipDto();
        result.init(json);
        return result;
    }
}

export interface IReportRoMHipDto {
    extension: string | undefined;
    flexion: string | undefined;
    abduction: string | undefined;
    adduction: string | undefined;
    extMusclePower: number | undefined;
    flexMusclePower: number | undefined;
    abdMusclePower: number | undefined;
    addMusclePower: number | undefined;
    internalRotation: string | undefined;
    irMusclePower: number | undefined;
    externalRotation: string | undefined;
    erMusclePower: number | undefined;
    rangeOfMotionId: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
}

export class ReportRoMKneeDto implements IReportRoMKneeDto {
    extension: string | undefined;
    flexion: string | undefined;
    extMusclePower: number | undefined;
    flexMusclePower: number | undefined;
    rangeOfMotionId: string | undefined;
    chosen: boolean | undefined;
    side: number | undefined;

    constructor(data?: IReportRoMKneeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.extension = data["extension"];
            this.flexion = data["flexion"];
            this.extMusclePower = data["extMusclePower"];
            this.flexMusclePower = data["flexMusclePower"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.chosen = data["chosen"];
            this.side = data["side"];
        }
    }

    static fromJS(data: any): ReportRoMKneeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportRoMKneeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["extension"] = this.extension;
        data["flexion"] = this.flexion;
        data["extMusclePower"] = this.extMusclePower;
        data["flexMusclePower"] = this.flexMusclePower;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["chosen"] = this.chosen;
        data["side"] = this.side;
        return data; 
    }

    clone(): ReportRoMKneeDto {
        const json = this.toJSON();
        let result = new ReportRoMKneeDto();
        result.init(json);
        return result;
    }
}

export interface IReportRoMKneeDto {
    extension: string | undefined;
    flexion: string | undefined;
    extMusclePower: number | undefined;
    flexMusclePower: number | undefined;
    rangeOfMotionId: string | undefined;
    chosen: boolean | undefined;
    side: number | undefined;
}

export class ReportRoMShoulderDto implements IReportRoMShoulderDto {
    extension: string | undefined;
    flexion: string | undefined;
    abduction: string | undefined;
    adduction: string | undefined;
    internalRotation: string | undefined;
    extMusclePower: number | undefined;
    flexMusclePower: number | undefined;
    abdMusclePower: number | undefined;
    addMusclePower: number | undefined;
    irMusclePower: number | undefined;
    externalRotation: string | undefined;
    erMusclePower: number | undefined;
    rangeOfMotionId: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;

    constructor(data?: IReportRoMShoulderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.extension = data["extension"];
            this.flexion = data["flexion"];
            this.abduction = data["abduction"];
            this.adduction = data["adduction"];
            this.internalRotation = data["internalRotation"];
            this.extMusclePower = data["extMusclePower"];
            this.flexMusclePower = data["flexMusclePower"];
            this.abdMusclePower = data["abdMusclePower"];
            this.addMusclePower = data["addMusclePower"];
            this.irMusclePower = data["irMusclePower"];
            this.externalRotation = data["externalRotation"];
            this.erMusclePower = data["erMusclePower"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.side = data["side"];
            this.chosen = data["chosen"];
        }
    }

    static fromJS(data: any): ReportRoMShoulderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportRoMShoulderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["extension"] = this.extension;
        data["flexion"] = this.flexion;
        data["abduction"] = this.abduction;
        data["adduction"] = this.adduction;
        data["internalRotation"] = this.internalRotation;
        data["extMusclePower"] = this.extMusclePower;
        data["flexMusclePower"] = this.flexMusclePower;
        data["abdMusclePower"] = this.abdMusclePower;
        data["addMusclePower"] = this.addMusclePower;
        data["irMusclePower"] = this.irMusclePower;
        data["externalRotation"] = this.externalRotation;
        data["erMusclePower"] = this.erMusclePower;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["side"] = this.side;
        data["chosen"] = this.chosen;
        return data; 
    }

    clone(): ReportRoMShoulderDto {
        const json = this.toJSON();
        let result = new ReportRoMShoulderDto();
        result.init(json);
        return result;
    }
}

export interface IReportRoMShoulderDto {
    extension: string | undefined;
    flexion: string | undefined;
    abduction: string | undefined;
    adduction: string | undefined;
    internalRotation: string | undefined;
    extMusclePower: number | undefined;
    flexMusclePower: number | undefined;
    abdMusclePower: number | undefined;
    addMusclePower: number | undefined;
    irMusclePower: number | undefined;
    externalRotation: string | undefined;
    erMusclePower: number | undefined;
    rangeOfMotionId: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
}

export class ReportRoMElbowDto implements IReportRoMElbowDto {
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    pronation: string | undefined;
    supination: string | undefined;
    extMusclePower: number | undefined;
    flexMusclePower: number | undefined;
    proMusclePower: number | undefined;
    supMusclePower: number | undefined;
    chosen: boolean | undefined;
    side: number | undefined;

    constructor(data?: IReportRoMElbowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.extension = data["extension"];
            this.flexion = data["flexion"];
            this.pronation = data["pronation"];
            this.supination = data["supination"];
            this.extMusclePower = data["extMusclePower"];
            this.flexMusclePower = data["flexMusclePower"];
            this.proMusclePower = data["proMusclePower"];
            this.supMusclePower = data["supMusclePower"];
            this.chosen = data["chosen"];
            this.side = data["side"];
        }
    }

    static fromJS(data: any): ReportRoMElbowDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportRoMElbowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["extension"] = this.extension;
        data["flexion"] = this.flexion;
        data["pronation"] = this.pronation;
        data["supination"] = this.supination;
        data["extMusclePower"] = this.extMusclePower;
        data["flexMusclePower"] = this.flexMusclePower;
        data["proMusclePower"] = this.proMusclePower;
        data["supMusclePower"] = this.supMusclePower;
        data["chosen"] = this.chosen;
        data["side"] = this.side;
        return data; 
    }

    clone(): ReportRoMElbowDto {
        const json = this.toJSON();
        let result = new ReportRoMElbowDto();
        result.init(json);
        return result;
    }
}

export interface IReportRoMElbowDto {
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    pronation: string | undefined;
    supination: string | undefined;
    extMusclePower: number | undefined;
    flexMusclePower: number | undefined;
    proMusclePower: number | undefined;
    supMusclePower: number | undefined;
    chosen: boolean | undefined;
    side: number | undefined;
}

export class CogntiveReportDto implements ICogntiveReportDto {
    status: number | undefined;
    score: number | undefined;
    totalScore: number | undefined;
    comment: string | undefined;
    memoryAssessmentType: string | undefined;
    clientId: string | undefined;
    id: string | undefined;

    constructor(data?: ICogntiveReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.score = data["score"];
            this.totalScore = data["totalScore"];
            this.comment = data["comment"];
            this.memoryAssessmentType = data["memoryAssessmentType"];
            this.clientId = data["clientId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CogntiveReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CogntiveReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["score"] = this.score;
        data["totalScore"] = this.totalScore;
        data["comment"] = this.comment;
        data["memoryAssessmentType"] = this.memoryAssessmentType;
        data["clientId"] = this.clientId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CogntiveReportDto {
        const json = this.toJSON();
        let result = new CogntiveReportDto();
        result.init(json);
        return result;
    }
}

export interface ICogntiveReportDto {
    status: number | undefined;
    score: number | undefined;
    totalScore: number | undefined;
    comment: string | undefined;
    memoryAssessmentType: string | undefined;
    clientId: string | undefined;
    id: string | undefined;
}

export class CognitiveParentDto implements ICognitiveParentDto {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    status: number | undefined;
    comment: string | undefined;
    isSelected: boolean | undefined;
    identifier: number | undefined;
    options: ListResultDtoOfOptionListDto | undefined;
    id: string | undefined;

    constructor(data?: ICognitiveParentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.comment = data["comment"];
            this.isSelected = data["isSelected"];
            this.identifier = data["identifier"];
            this.options = data["options"] ? ListResultDtoOfOptionListDto.fromJS(data["options"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CognitiveParentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CognitiveParentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["isSelected"] = this.isSelected;
        data["identifier"] = this.identifier;
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CognitiveParentDto {
        const json = this.toJSON();
        let result = new CognitiveParentDto();
        result.init(json);
        return result;
    }
}

export interface ICognitiveParentDto {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    status: number | undefined;
    comment: string | undefined;
    isSelected: boolean | undefined;
    identifier: number | undefined;
    options: ListResultDtoOfOptionListDto | undefined;
    id: string | undefined;
}

export class Assessment implements IAssessment {
    name: string | undefined;
    categoryId: string | undefined;
    category: AssessmentCategory | undefined;
    clientId: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAssessment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.categoryId = data["categoryId"];
            this.category = data["category"] ? AssessmentCategory.fromJS(data["category"]) : <any>undefined;
            this.clientId = data["clientId"];
            this.side = data["side"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Assessment {
        data = typeof data === 'object' ? data : {};
        let result = new Assessment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["clientId"] = this.clientId;
        data["side"] = this.side;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Assessment {
        const json = this.toJSON();
        let result = new Assessment();
        result.init(json);
        return result;
    }
}

export interface IAssessment {
    name: string | undefined;
    categoryId: string | undefined;
    category: AssessmentCategory | undefined;
    clientId: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfOptionListDto implements IListResultDtoOfOptionListDto {
    items: OptionListDto[] | undefined;

    constructor(data?: IListResultDtoOfOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfOptionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfOptionListDto {
    items: OptionListDto[] | undefined;
}

export class AssessmentCategory implements IAssessmentCategory {
    name: string | undefined;
    position: number | undefined;
    assessments: Assessment[] | undefined;
    status: number | undefined;
    assessmentsLists: AssessmentsList[] | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAssessmentCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.position = data["position"];
            if (data["assessments"] && data["assessments"].constructor === Array) {
                this.assessments = [];
                for (let item of data["assessments"])
                    this.assessments.push(Assessment.fromJS(item));
            }
            this.status = data["status"];
            if (data["assessmentsLists"] && data["assessmentsLists"].constructor === Array) {
                this.assessmentsLists = [];
                for (let item of data["assessmentsLists"])
                    this.assessmentsLists.push(AssessmentsList.fromJS(item));
            }
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssessmentCategory {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["position"] = this.position;
        if (this.assessments && this.assessments.constructor === Array) {
            data["assessments"] = [];
            for (let item of this.assessments)
                data["assessments"].push(item.toJSON());
        }
        data["status"] = this.status;
        if (this.assessmentsLists && this.assessmentsLists.constructor === Array) {
            data["assessmentsLists"] = [];
            for (let item of this.assessmentsLists)
                data["assessmentsLists"].push(item.toJSON());
        }
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AssessmentCategory {
        const json = this.toJSON();
        let result = new AssessmentCategory();
        result.init(json);
        return result;
    }
}

export interface IAssessmentCategory {
    name: string | undefined;
    position: number | undefined;
    assessments: Assessment[] | undefined;
    status: number | undefined;
    assessmentsLists: AssessmentsList[] | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class OptionListDto implements IOptionListDto {
    instruction: string | undefined;
    score: number | undefined;
    position: number | undefined;
    targetId: string | undefined;
    identifier: number | undefined;
    id: string | undefined;

    constructor(data?: IOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.instruction = data["instruction"];
            this.score = data["score"];
            this.position = data["position"];
            this.targetId = data["targetId"];
            this.identifier = data["identifier"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["instruction"] = this.instruction;
        data["score"] = this.score;
        data["position"] = this.position;
        data["targetId"] = this.targetId;
        data["identifier"] = this.identifier;
        data["id"] = this.id;
        return data; 
    }

    clone(): OptionListDto {
        const json = this.toJSON();
        let result = new OptionListDto();
        result.init(json);
        return result;
    }
}

export interface IOptionListDto {
    instruction: string | undefined;
    score: number | undefined;
    position: number | undefined;
    targetId: string | undefined;
    identifier: number | undefined;
    id: string | undefined;
}

export class AssessmentsList implements IAssessmentsList {
    assessmentCategoryId: string | undefined;
    position: number | undefined;
    assessmentName: string | undefined;
    identifier: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAssessmentsList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentCategoryId = data["assessmentCategoryId"];
            this.position = data["position"];
            this.assessmentName = data["assessmentName"];
            this.identifier = data["identifier"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssessmentsList {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentsList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentCategoryId"] = this.assessmentCategoryId;
        data["position"] = this.position;
        data["assessmentName"] = this.assessmentName;
        data["identifier"] = this.identifier;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AssessmentsList {
        const json = this.toJSON();
        let result = new AssessmentsList();
        result.init(json);
        return result;
    }
}

export interface IAssessmentsList {
    assessmentCategoryId: string | undefined;
    position: number | undefined;
    assessmentName: string | undefined;
    identifier: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class OptionDto implements IOptionDto {
    instruction: string | undefined;
    score: number | undefined;
    position: number | undefined;
    targetId: string | undefined;
    identifier: number | undefined;
    id: string | undefined;

    constructor(data?: IOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.instruction = data["instruction"];
            this.score = data["score"];
            this.position = data["position"];
            this.targetId = data["targetId"];
            this.identifier = data["identifier"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["instruction"] = this.instruction;
        data["score"] = this.score;
        data["position"] = this.position;
        data["targetId"] = this.targetId;
        data["identifier"] = this.identifier;
        data["id"] = this.id;
        return data; 
    }

    clone(): OptionDto {
        const json = this.toJSON();
        let result = new OptionDto();
        result.init(json);
        return result;
    }
}

export interface IOptionDto {
    instruction: string | undefined;
    score: number | undefined;
    position: number | undefined;
    targetId: string | undefined;
    identifier: number | undefined;
    id: string | undefined;
}

export class CreateCommentInput implements ICreateCommentInput {
    userId: number | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICreateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.text = data["text"];
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["text"] = this.text;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateCommentInput {
        const json = this.toJSON();
        let result = new CreateCommentInput();
        result.init(json);
        return result;
    }
}

export interface ICreateCommentInput {
    userId: number | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CommentListDto implements ICommentListDto {
    userId: number | undefined;
    user: User | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICommentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.text = data["text"];
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CommentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CommentListDto {
        const json = this.toJSON();
        let result = new CommentListDto();
        result.init(json);
        return result;
    }
}

export interface ICommentListDto {
    userId: number | undefined;
    user: User | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CommentDetailOutput implements ICommentDetailOutput {
    userId: number | undefined;
    user: User | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICommentDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.text = data["text"];
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CommentDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CommentDetailOutput {
        const json = this.toJSON();
        let result = new CommentDetailOutput();
        result.init(json);
        return result;
    }
}

export interface ICommentDetailOutput {
    userId: number | undefined;
    user: User | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfCommentListDto implements IPagedResultDtoOfCommentListDto {
    totalCount: number | undefined;
    items: CommentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCommentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CommentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCommentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCommentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCommentListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCommentListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCommentListDto {
    totalCount: number | undefined;
    items: CommentListDto[] | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class CreateContactInput implements ICreateContactInput {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;

    constructor(data?: ICreateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.role = data["role"];
        }
    }

    static fromJS(data: any): CreateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["role"] = this.role;
        return data; 
    }

    clone(): CreateContactInput {
        const json = this.toJSON();
        let result = new CreateContactInput();
        result.init(json);
        return result;
    }
}

export interface ICreateContactInput {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
}

export class ContactDetailOutput implements IContactDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IContactDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.role = data["role"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["role"] = this.role;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ContactDetailOutput {
        const json = this.toJSON();
        let result = new ContactDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IContactDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ContactListDto implements IContactListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IContactListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.role = data["role"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["role"] = this.role;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ContactListDto {
        const json = this.toJSON();
        let result = new ContactListDto();
        result.init(json);
        return result;
    }
}

export interface IContactListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfContactListDto implements IListResultDtoOfContactListDto {
    items: ContactListDto[] | undefined;

    constructor(data?: IListResultDtoOfContactListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContactListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfContactListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfContactListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfContactListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfContactListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfContactListDto {
    items: ContactListDto[] | undefined;
}

export class PagedResultDtoOfContactListDto implements IPagedResultDtoOfContactListDto {
    totalCount: number | undefined;
    items: ContactListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContactListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfContactListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfContactListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfContactListDto {
    totalCount: number | undefined;
    items: ContactListDto[] | undefined;
}

export class CoordinationOptionDto implements ICoordinationOptionDto {
    index: number | undefined;
    name: string | undefined;
    coordinationId: string | undefined;
    time: number | undefined;
    workRate: number | undefined;
    result: string | undefined;
    numPieces: number | undefined;
    status: number | undefined;
    comment: string | undefined;
    id: string | undefined;

    constructor(data?: ICoordinationOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.index = data["index"];
            this.name = data["name"];
            this.coordinationId = data["coordinationId"];
            this.time = data["time"];
            this.workRate = data["workRate"];
            this.result = data["result"];
            this.numPieces = data["numPieces"];
            this.status = data["status"];
            this.comment = data["comment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CoordinationOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinationOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["name"] = this.name;
        data["coordinationId"] = this.coordinationId;
        data["time"] = this.time;
        data["workRate"] = this.workRate;
        data["result"] = this.result;
        data["numPieces"] = this.numPieces;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data; 
    }

    clone(): CoordinationOptionDto {
        const json = this.toJSON();
        let result = new CoordinationOptionDto();
        result.init(json);
        return result;
    }
}

export interface ICoordinationOptionDto {
    index: number | undefined;
    name: string | undefined;
    coordinationId: string | undefined;
    time: number | undefined;
    workRate: number | undefined;
    result: string | undefined;
    numPieces: number | undefined;
    status: number | undefined;
    comment: string | undefined;
    id: string | undefined;
}

export class ListResultDtoOfCoordinationOptionListDto implements IListResultDtoOfCoordinationOptionListDto {
    items: CoordinationOptionListDto[] | undefined;

    constructor(data?: IListResultDtoOfCoordinationOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CoordinationOptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCoordinationOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCoordinationOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfCoordinationOptionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfCoordinationOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfCoordinationOptionListDto {
    items: CoordinationOptionListDto[] | undefined;
}

export class CoordinationOptionListDto implements ICoordinationOptionListDto {
    index: number | undefined;
    name: string | undefined;
    coordinationId: string | undefined;
    time: number | undefined;
    workRate: number | undefined;
    result: string | undefined;
    numPieces: number | undefined;
    status: number | undefined;
    comment: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICoordinationOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.index = data["index"];
            this.name = data["name"];
            this.coordinationId = data["coordinationId"];
            this.time = data["time"];
            this.workRate = data["workRate"];
            this.result = data["result"];
            this.numPieces = data["numPieces"];
            this.status = data["status"];
            this.comment = data["comment"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CoordinationOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinationOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["name"] = this.name;
        data["coordinationId"] = this.coordinationId;
        data["time"] = this.time;
        data["workRate"] = this.workRate;
        data["result"] = this.result;
        data["numPieces"] = this.numPieces;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CoordinationOptionListDto {
        const json = this.toJSON();
        let result = new CoordinationOptionListDto();
        result.init(json);
        return result;
    }
}

export interface ICoordinationOptionListDto {
    index: number | undefined;
    name: string | undefined;
    coordinationId: string | undefined;
    time: number | undefined;
    workRate: number | undefined;
    result: string | undefined;
    numPieces: number | undefined;
    status: number | undefined;
    comment: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CoordinationIncompleteDto implements ICoordinationIncompleteDto {
    clientId: string | undefined;
    completedPieces: number | undefined;
    timeTaken: number | undefined;
    holeType: number | undefined;
    mtm: number | undefined;
    status: number | undefined;
    side: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICoordinationIncompleteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.completedPieces = data["completedPieces"];
            this.timeTaken = data["timeTaken"];
            this.holeType = data["holeType"];
            this.mtm = data["mtm"];
            this.status = data["status"];
            this.side = data["side"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CoordinationIncompleteDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinationIncompleteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["completedPieces"] = this.completedPieces;
        data["timeTaken"] = this.timeTaken;
        data["holeType"] = this.holeType;
        data["mtm"] = this.mtm;
        data["status"] = this.status;
        data["side"] = this.side;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CoordinationIncompleteDto {
        const json = this.toJSON();
        let result = new CoordinationIncompleteDto();
        result.init(json);
        return result;
    }
}

export interface ICoordinationIncompleteDto {
    clientId: string | undefined;
    completedPieces: number | undefined;
    timeTaken: number | undefined;
    holeType: number | undefined;
    mtm: number | undefined;
    status: number | undefined;
    side: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CrawlingProtocolDetailOutput implements ICrawlingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    numTests: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICrawlingProtocolDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.numTests = data["numTests"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.chosen = data["chosen"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CrawlingProtocolDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CrawlingProtocolDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["numTests"] = this.numTests;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["chosen"] = this.chosen;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CrawlingProtocolDetailOutput {
        const json = this.toJSON();
        let result = new CrawlingProtocolDetailOutput();
        result.init(json);
        return result;
    }
}

export interface ICrawlingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    numTests: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CrawlingProtocolDto implements ICrawlingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    numTests: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICrawlingProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.numTests = data["numTests"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.chosen = data["chosen"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CrawlingProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrawlingProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["numTests"] = this.numTests;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["chosen"] = this.chosen;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CrawlingProtocolDto {
        const json = this.toJSON();
        let result = new CrawlingProtocolDto();
        result.init(json);
        return result;
    }
}

export interface ICrawlingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    numTests: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CrouchingTestCreateInput implements ICrouchingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;

    constructor(data?: ICrouchingTestCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): CrouchingTestCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CrouchingTestCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): CrouchingTestCreateInput {
        const json = this.toJSON();
        let result = new CrouchingTestCreateInput();
        result.init(json);
        return result;
    }
}

export interface ICrouchingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
}

export class ListResultDtoOfCrouchingTestDto implements IListResultDtoOfCrouchingTestDto {
    items: CrouchingTestDto[] | undefined;

    constructor(data?: IListResultDtoOfCrouchingTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CrouchingTestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCrouchingTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCrouchingTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfCrouchingTestDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfCrouchingTestDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfCrouchingTestDto {
    items: CrouchingTestDto[] | undefined;
}

export class CrouchingTestDto implements ICrouchingTestDto {
    crouchingId: string | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    id: string | undefined;

    constructor(data?: ICrouchingTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.crouchingId = data["crouchingId"];
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CrouchingTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrouchingTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["crouchingId"] = this.crouchingId;
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data; 
    }

    clone(): CrouchingTestDto {
        const json = this.toJSON();
        let result = new CrouchingTestDto();
        result.init(json);
        return result;
    }
}

export interface ICrouchingTestDto {
    crouchingId: string | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    id: string | undefined;
}

export class CrouchingDto implements ICrouchingDto {
    crouchingTests: CrouchingTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    taskType: string | undefined;
    chosen: boolean | undefined;
    rating: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICrouchingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["crouchingTests"] && data["crouchingTests"].constructor === Array) {
                this.crouchingTests = [];
                for (let item of data["crouchingTests"])
                    this.crouchingTests.push(CrouchingTestDto.fromJS(item));
            }
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.taskType = data["taskType"];
            this.chosen = data["chosen"];
            this.rating = data["rating"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CrouchingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrouchingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.crouchingTests && this.crouchingTests.constructor === Array) {
            data["crouchingTests"] = [];
            for (let item of this.crouchingTests)
                data["crouchingTests"].push(item.toJSON());
        }
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["taskType"] = this.taskType;
        data["chosen"] = this.chosen;
        data["rating"] = this.rating;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CrouchingDto {
        const json = this.toJSON();
        let result = new CrouchingDto();
        result.init(json);
        return result;
    }
}

export interface ICrouchingDto {
    crouchingTests: CrouchingTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    taskType: string | undefined;
    chosen: boolean | undefined;
    rating: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfAssessmentsDto implements IListResultDtoOfAssessmentsDto {
    items: AssessmentsDto[] | undefined;

    constructor(data?: IListResultDtoOfAssessmentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AssessmentsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAssessmentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAssessmentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfAssessmentsDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfAssessmentsDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfAssessmentsDto {
    items: AssessmentsDto[] | undefined;
}

export class AssessmentsDto implements IAssessmentsDto {
    month: number | undefined;
    value: number | undefined;

    constructor(data?: IAssessmentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.month = data["month"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): AssessmentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["value"] = this.value;
        return data; 
    }

    clone(): AssessmentsDto {
        const json = this.toJSON();
        let result = new AssessmentsDto();
        result.init(json);
        return result;
    }
}

export interface IAssessmentsDto {
    month: number | undefined;
    value: number | undefined;
}

export class CreateDocumentInput implements ICreateDocumentInput {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    contactId: string | undefined;
    parentDocId: number | undefined;
    userId: number | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;

    constructor(data?: ICreateDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.authorName = data["authorName"];
            this.authorDate = data["authorDate"] ? moment(data["authorDate"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.contactId = data["contactId"];
            this.parentDocId = data["parentDocId"];
            this.userId = data["userId"];
            this.fileUrl = data["fileUrl"];
            this.identifier = data["identifier"];
        }
    }

    static fromJS(data: any): CreateDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["authorName"] = this.authorName;
        data["authorDate"] = this.authorDate ? this.authorDate.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["contactId"] = this.contactId;
        data["parentDocId"] = this.parentDocId;
        data["userId"] = this.userId;
        data["fileUrl"] = this.fileUrl;
        data["identifier"] = this.identifier;
        return data; 
    }

    clone(): CreateDocumentInput {
        const json = this.toJSON();
        let result = new CreateDocumentInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDocumentInput {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    contactId: string | undefined;
    parentDocId: number | undefined;
    userId: number | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;
}

export class DocumentDetailOutput implements IDocumentDetailOutput {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    parentDocId: number | undefined;
    client: Client | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    userId: number | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDocumentDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.authorName = data["authorName"];
            this.authorDate = data["authorDate"] ? moment(data["authorDate"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.parentDocId = data["parentDocId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.userId = data["userId"];
            this.fileUrl = data["fileUrl"];
            this.identifier = data["identifier"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DocumentDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["authorName"] = this.authorName;
        data["authorDate"] = this.authorDate ? this.authorDate.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["parentDocId"] = this.parentDocId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["fileUrl"] = this.fileUrl;
        data["identifier"] = this.identifier;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DocumentDetailOutput {
        const json = this.toJSON();
        let result = new DocumentDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IDocumentDetailOutput {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    parentDocId: number | undefined;
    client: Client | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    userId: number | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ListResultDtoOfDocumentListDto implements IListResultDtoOfDocumentListDto {
    items: DocumentListDto[] | undefined;

    constructor(data?: IListResultDtoOfDocumentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DocumentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDocumentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDocumentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfDocumentListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfDocumentListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfDocumentListDto {
    items: DocumentListDto[] | undefined;
}

export class DocumentListDto implements IDocumentListDto {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    contactId: string | undefined;
    parentDocId: number | undefined;
    contact: Contact | undefined;
    userId: number | undefined;
    user: User | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDocumentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.authorName = data["authorName"];
            this.authorDate = data["authorDate"] ? moment(data["authorDate"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.parentDocId = data["parentDocId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.fileUrl = data["fileUrl"];
            this.identifier = data["identifier"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DocumentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["authorName"] = this.authorName;
        data["authorDate"] = this.authorDate ? this.authorDate.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["parentDocId"] = this.parentDocId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["fileUrl"] = this.fileUrl;
        data["identifier"] = this.identifier;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DocumentListDto {
        const json = this.toJSON();
        let result = new DocumentListDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentListDto {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    contactId: string | undefined;
    parentDocId: number | undefined;
    contact: Contact | undefined;
    userId: number | undefined;
    user: User | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDocumentListDto implements IPagedResultDtoOfDocumentListDto {
    totalCount: number | undefined;
    items: DocumentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDocumentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DocumentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDocumentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDocumentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDocumentListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDocumentListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDocumentListDto {
    totalCount: number | undefined;
    items: DocumentListDto[] | undefined;
}

export class ElevatedReachTestCreateInput implements IElevatedReachTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    side: number | undefined;
    position: number | undefined;
    comment: string | undefined;

    constructor(data?: IElevatedReachTestCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.side = data["side"];
            this.position = data["position"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): ElevatedReachTestCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ElevatedReachTestCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["side"] = this.side;
        data["position"] = this.position;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): ElevatedReachTestCreateInput {
        const json = this.toJSON();
        let result = new ElevatedReachTestCreateInput();
        result.init(json);
        return result;
    }
}

export interface IElevatedReachTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    side: number | undefined;
    position: number | undefined;
    comment: string | undefined;
}

export class ListResultDtoOfElevatedReachTestDto implements IListResultDtoOfElevatedReachTestDto {
    items: ElevatedReachTestDto[] | undefined;

    constructor(data?: IListResultDtoOfElevatedReachTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ElevatedReachTestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfElevatedReachTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfElevatedReachTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfElevatedReachTestDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfElevatedReachTestDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfElevatedReachTestDto {
    items: ElevatedReachTestDto[] | undefined;
}

export class ElevatedReachTestDto implements IElevatedReachTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    side: number | undefined;
    position: number | undefined;
    comment: string | undefined;
    elevatedReachId: string | undefined;
    id: string | undefined;

    constructor(data?: IElevatedReachTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.side = data["side"];
            this.position = data["position"];
            this.comment = data["comment"];
            this.elevatedReachId = data["elevatedReachId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ElevatedReachTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ElevatedReachTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["side"] = this.side;
        data["position"] = this.position;
        data["comment"] = this.comment;
        data["elevatedReachId"] = this.elevatedReachId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ElevatedReachTestDto {
        const json = this.toJSON();
        let result = new ElevatedReachTestDto();
        result.init(json);
        return result;
    }
}

export interface IElevatedReachTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    side: number | undefined;
    position: number | undefined;
    comment: string | undefined;
    elevatedReachId: string | undefined;
    id: string | undefined;
}

export class ElevatedReachDto implements IElevatedReachDto {
    elevatedReachTests: ElevatedReachTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    taskType: string | undefined;
    chosen: boolean | undefined;
    rating: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IElevatedReachDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["elevatedReachTests"] && data["elevatedReachTests"].constructor === Array) {
                this.elevatedReachTests = [];
                for (let item of data["elevatedReachTests"])
                    this.elevatedReachTests.push(ElevatedReachTestDto.fromJS(item));
            }
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.taskType = data["taskType"];
            this.chosen = data["chosen"];
            this.rating = data["rating"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ElevatedReachDto {
        data = typeof data === 'object' ? data : {};
        let result = new ElevatedReachDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.elevatedReachTests && this.elevatedReachTests.constructor === Array) {
            data["elevatedReachTests"] = [];
            for (let item of this.elevatedReachTests)
                data["elevatedReachTests"].push(item.toJSON());
        }
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["taskType"] = this.taskType;
        data["chosen"] = this.chosen;
        data["rating"] = this.rating;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ElevatedReachDto {
        const json = this.toJSON();
        let result = new ElevatedReachDto();
        result.init(json);
        return result;
    }
}

export interface IElevatedReachDto {
    elevatedReachTests: ElevatedReachTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    taskType: string | undefined;
    chosen: boolean | undefined;
    rating: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ClientAnswerListDto implements IClientAnswerListDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    questionId: string | undefined;
    questionOptionId: string | undefined;
    optionScore: number | undefined;
    answer: string | undefined;
    type: number | undefined;

    constructor(data?: IClientAnswerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.questionId = data["questionId"];
            this.questionOptionId = data["questionOptionId"];
            this.optionScore = data["optionScore"];
            this.answer = data["answer"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): ClientAnswerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAnswerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["questionId"] = this.questionId;
        data["questionOptionId"] = this.questionOptionId;
        data["optionScore"] = this.optionScore;
        data["answer"] = this.answer;
        data["type"] = this.type;
        return data; 
    }

    clone(): ClientAnswerListDto {
        const json = this.toJSON();
        let result = new ClientAnswerListDto();
        result.init(json);
        return result;
    }
}

export interface IClientAnswerListDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    questionId: string | undefined;
    questionOptionId: string | undefined;
    optionScore: number | undefined;
    answer: string | undefined;
    type: number | undefined;
}

export class ListResultDtoOfClientAnswerListDto implements IListResultDtoOfClientAnswerListDto {
    items: ClientAnswerListDto[] | undefined;

    constructor(data?: IListResultDtoOfClientAnswerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ClientAnswerListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfClientAnswerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfClientAnswerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfClientAnswerListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfClientAnswerListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfClientAnswerListDto {
    items: ClientAnswerListDto[] | undefined;
}

export class ListResultDtoOfQuestionListDto implements IListResultDtoOfQuestionListDto {
    items: QuestionListDto[] | undefined;

    constructor(data?: IListResultDtoOfQuestionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfQuestionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfQuestionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfQuestionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfQuestionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfQuestionListDto {
    items: QuestionListDto[] | undefined;
}

export class QuestionListDto implements IQuestionListDto {
    title: string | undefined;
    type: number | undefined;
    position: number | undefined;
    options: QuestionOptionListDto[] | undefined;
    id: string | undefined;

    constructor(data?: IQuestionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.type = data["type"];
            this.position = data["position"];
            if (data["options"] && data["options"].constructor === Array) {
                this.options = [];
                for (let item of data["options"])
                    this.options.push(QuestionOptionListDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["type"] = this.type;
        data["position"] = this.position;
        if (this.options && this.options.constructor === Array) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): QuestionListDto {
        const json = this.toJSON();
        let result = new QuestionListDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionListDto {
    title: string | undefined;
    type: number | undefined;
    position: number | undefined;
    options: QuestionOptionListDto[] | undefined;
    id: string | undefined;
}

export class QuestionOptionListDto implements IQuestionOptionListDto {
    title: string | undefined;
    position: number | undefined;
    questionId: string | undefined;
    id: string | undefined;

    constructor(data?: IQuestionOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.position = data["position"];
            this.questionId = data["questionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["position"] = this.position;
        data["questionId"] = this.questionId;
        data["id"] = this.id;
        return data; 
    }

    clone(): QuestionOptionListDto {
        const json = this.toJSON();
        let result = new QuestionOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionOptionListDto {
    title: string | undefined;
    position: number | undefined;
    questionId: string | undefined;
    id: string | undefined;
}

export class ListResultDtoOfQuestionnaireDto implements IListResultDtoOfQuestionnaireDto {
    items: QuestionnaireDto[] | undefined;

    constructor(data?: IListResultDtoOfQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(QuestionnaireDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfQuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfQuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfQuestionnaireDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfQuestionnaireDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfQuestionnaireDto {
    items: QuestionnaireDto[] | undefined;
}

export class QuestionnaireDto implements IQuestionnaireDto {
    assessment: AssessmentDto | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    status: number | undefined;
    type: number | undefined;
    id: string | undefined;

    constructor(data?: IQuestionnaireDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? AssessmentDto.fromJS(data["assessment"]) : <any>undefined;
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.type = data["type"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionnaireDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["type"] = this.type;
        data["id"] = this.id;
        return data; 
    }

    clone(): QuestionnaireDto {
        const json = this.toJSON();
        let result = new QuestionnaireDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionnaireDto {
    assessment: AssessmentDto | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    status: number | undefined;
    type: number | undefined;
    id: string | undefined;
}

export class AssessmentDto implements IAssessmentDto {
    name: string | undefined;
    position: number | undefined;
    id: string | undefined;

    constructor(data?: IAssessmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.position = data["position"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssessmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["position"] = this.position;
        data["id"] = this.id;
        return data; 
    }

    clone(): AssessmentDto {
        const json = this.toJSON();
        let result = new AssessmentDto();
        result.init(json);
        return result;
    }
}

export interface IAssessmentDto {
    name: string | undefined;
    position: number | undefined;
    id: string | undefined;
}

export class QuestionDto implements IQuestionDto {
    clientId: string | undefined;
    score: number | undefined;
    title: string | undefined;
    type: number | undefined;
    position: number | undefined;
    answer: string | undefined;
    options: QuestionOptionDto[] | undefined;
    id: string | undefined;

    constructor(data?: IQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.score = data["score"];
            this.title = data["title"];
            this.type = data["type"];
            this.position = data["position"];
            this.answer = data["answer"];
            if (data["options"] && data["options"].constructor === Array) {
                this.options = [];
                for (let item of data["options"])
                    this.options.push(QuestionOptionDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["score"] = this.score;
        data["title"] = this.title;
        data["type"] = this.type;
        data["position"] = this.position;
        data["answer"] = this.answer;
        if (this.options && this.options.constructor === Array) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): QuestionDto {
        const json = this.toJSON();
        let result = new QuestionDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionDto {
    clientId: string | undefined;
    score: number | undefined;
    title: string | undefined;
    type: number | undefined;
    position: number | undefined;
    answer: string | undefined;
    options: QuestionOptionDto[] | undefined;
    id: string | undefined;
}

export class QuestionOptionDto implements IQuestionOptionDto {
    title: string | undefined;
    position: number | undefined;
    optionScore: number | undefined;
    answer: string | undefined;
    questionId: string | undefined;
    id: string | undefined;

    constructor(data?: IQuestionOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.position = data["position"];
            this.optionScore = data["optionScore"];
            this.answer = data["answer"];
            this.questionId = data["questionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuestionOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["position"] = this.position;
        data["optionScore"] = this.optionScore;
        data["answer"] = this.answer;
        data["questionId"] = this.questionId;
        data["id"] = this.id;
        return data; 
    }

    clone(): QuestionOptionDto {
        const json = this.toJSON();
        let result = new QuestionOptionDto();
        result.init(json);
        return result;
    }
}

export interface IQuestionOptionDto {
    title: string | undefined;
    position: number | undefined;
    optionScore: number | undefined;
    answer: string | undefined;
    questionId: string | undefined;
    id: string | undefined;
}

export class GaitDto implements IGaitDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    timeRecorded: number | undefined;
    walkingTime: string | undefined;
    painLevel: string | undefined;
    comment: string | undefined;
    videoUrl: string | undefined;
    otObservationComments: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGaitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.timeRecorded = data["timeRecorded"];
            this.walkingTime = data["walkingTime"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.videoUrl = data["videoUrl"];
            this.otObservationComments = data["otObservationComments"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GaitDto {
        data = typeof data === 'object' ? data : {};
        let result = new GaitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["timeRecorded"] = this.timeRecorded;
        data["walkingTime"] = this.walkingTime;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["videoUrl"] = this.videoUrl;
        data["otObservationComments"] = this.otObservationComments;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GaitDto {
        const json = this.toJSON();
        let result = new GaitDto();
        result.init(json);
        return result;
    }
}

export interface IGaitDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    timeRecorded: number | undefined;
    walkingTime: string | undefined;
    painLevel: string | undefined;
    comment: string | undefined;
    videoUrl: string | undefined;
    otObservationComments: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GripStrengthDto implements IGripStrengthDto {
    age: number | undefined;
    weight: number | undefined;
    gender: number | undefined;
    machineTest: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IGripStrengthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.age = data["age"];
            this.weight = data["weight"];
            this.gender = data["gender"];
            this.machineTest = data["machineTest"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.side = data["side"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GripStrengthDto {
        data = typeof data === 'object' ? data : {};
        let result = new GripStrengthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["age"] = this.age;
        data["weight"] = this.weight;
        data["gender"] = this.gender;
        data["machineTest"] = this.machineTest;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["side"] = this.side;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): GripStrengthDto {
        const json = this.toJSON();
        let result = new GripStrengthDto();
        result.init(json);
        return result;
    }
}

export interface IGripStrengthDto {
    age: number | undefined;
    weight: number | undefined;
    gender: number | undefined;
    machineTest: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class GripStrengthDetailOutput implements IGripStrengthDetailOutput {
    assessment: Assessment | undefined;
    age: number | undefined;
    weight: number | undefined;
    gender: number | undefined;
    machineTest: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IGripStrengthDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.age = data["age"];
            this.weight = data["weight"];
            this.gender = data["gender"];
            this.machineTest = data["machineTest"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.side = data["side"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GripStrengthDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GripStrengthDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["age"] = this.age;
        data["weight"] = this.weight;
        data["gender"] = this.gender;
        data["machineTest"] = this.machineTest;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["side"] = this.side;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): GripStrengthDetailOutput {
        const json = this.toJSON();
        let result = new GripStrengthDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IGripStrengthDetailOutput {
    assessment: Assessment | undefined;
    age: number | undefined;
    weight: number | undefined;
    gender: number | undefined;
    machineTest: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class CreateJobDescriptionInput implements ICreateJobDescriptionInput {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;
    elementId: string | undefined;
    elementName: string | undefined;
    dataValue: number | undefined;
    category: number | undefined;
    lowerCIBound: number | undefined;
    upperCIBound: number | undefined;
    liftingJobDemand: string | undefined;
    unilateralCarryJobDemand: string | undefined;
    bilateralCarryJobDemand: string | undefined;
    pushPullJobDemand: string | undefined;
    kneelingJobDemand: string | undefined;
    crouchingJobDemand: string | undefined;
    midLevelReachJobDemand: string | undefined;
    elevatedReachJobDemand: string | undefined;
    sittingJobDemand: string | undefined;
    standingJobDemand: string | undefined;
    crawlingJobDemand: string | undefined;
    repFootMotionJobDemand: string | undefined;
    stairClimbingJobDemand: string | undefined;
    walkingJobDemand: string | undefined;
    balanceJobDemand: string | undefined;
    ladderWorkJobDemand: string | undefined;
    squattingJobDemand: string | undefined;

    constructor(data?: ICreateJobDescriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.description = data["description"];
            this.title = data["title"];
            this.elementId = data["elementId"];
            this.elementName = data["elementName"];
            this.dataValue = data["dataValue"];
            this.category = data["category"];
            this.lowerCIBound = data["lowerCIBound"];
            this.upperCIBound = data["upperCIBound"];
            this.liftingJobDemand = data["liftingJobDemand"];
            this.unilateralCarryJobDemand = data["unilateralCarryJobDemand"];
            this.bilateralCarryJobDemand = data["bilateralCarryJobDemand"];
            this.pushPullJobDemand = data["pushPullJobDemand"];
            this.kneelingJobDemand = data["kneelingJobDemand"];
            this.crouchingJobDemand = data["crouchingJobDemand"];
            this.midLevelReachJobDemand = data["midLevelReachJobDemand"];
            this.elevatedReachJobDemand = data["elevatedReachJobDemand"];
            this.sittingJobDemand = data["sittingJobDemand"];
            this.standingJobDemand = data["standingJobDemand"];
            this.crawlingJobDemand = data["crawlingJobDemand"];
            this.repFootMotionJobDemand = data["repFootMotionJobDemand"];
            this.stairClimbingJobDemand = data["stairClimbingJobDemand"];
            this.walkingJobDemand = data["walkingJobDemand"];
            this.balanceJobDemand = data["balanceJobDemand"];
            this.ladderWorkJobDemand = data["ladderWorkJobDemand"];
            this.squattingJobDemand = data["squattingJobDemand"];
        }
    }

    static fromJS(data: any): CreateJobDescriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobDescriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["title"] = this.title;
        data["elementId"] = this.elementId;
        data["elementName"] = this.elementName;
        data["dataValue"] = this.dataValue;
        data["category"] = this.category;
        data["lowerCIBound"] = this.lowerCIBound;
        data["upperCIBound"] = this.upperCIBound;
        data["liftingJobDemand"] = this.liftingJobDemand;
        data["unilateralCarryJobDemand"] = this.unilateralCarryJobDemand;
        data["bilateralCarryJobDemand"] = this.bilateralCarryJobDemand;
        data["pushPullJobDemand"] = this.pushPullJobDemand;
        data["kneelingJobDemand"] = this.kneelingJobDemand;
        data["crouchingJobDemand"] = this.crouchingJobDemand;
        data["midLevelReachJobDemand"] = this.midLevelReachJobDemand;
        data["elevatedReachJobDemand"] = this.elevatedReachJobDemand;
        data["sittingJobDemand"] = this.sittingJobDemand;
        data["standingJobDemand"] = this.standingJobDemand;
        data["crawlingJobDemand"] = this.crawlingJobDemand;
        data["repFootMotionJobDemand"] = this.repFootMotionJobDemand;
        data["stairClimbingJobDemand"] = this.stairClimbingJobDemand;
        data["walkingJobDemand"] = this.walkingJobDemand;
        data["balanceJobDemand"] = this.balanceJobDemand;
        data["ladderWorkJobDemand"] = this.ladderWorkJobDemand;
        data["squattingJobDemand"] = this.squattingJobDemand;
        return data; 
    }

    clone(): CreateJobDescriptionInput {
        const json = this.toJSON();
        let result = new CreateJobDescriptionInput();
        result.init(json);
        return result;
    }
}

export interface ICreateJobDescriptionInput {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;
    elementId: string | undefined;
    elementName: string | undefined;
    dataValue: number | undefined;
    category: number | undefined;
    lowerCIBound: number | undefined;
    upperCIBound: number | undefined;
    liftingJobDemand: string | undefined;
    unilateralCarryJobDemand: string | undefined;
    bilateralCarryJobDemand: string | undefined;
    pushPullJobDemand: string | undefined;
    kneelingJobDemand: string | undefined;
    crouchingJobDemand: string | undefined;
    midLevelReachJobDemand: string | undefined;
    elevatedReachJobDemand: string | undefined;
    sittingJobDemand: string | undefined;
    standingJobDemand: string | undefined;
    crawlingJobDemand: string | undefined;
    repFootMotionJobDemand: string | undefined;
    stairClimbingJobDemand: string | undefined;
    walkingJobDemand: string | undefined;
    balanceJobDemand: string | undefined;
    ladderWorkJobDemand: string | undefined;
    squattingJobDemand: string | undefined;
}

export class JobDescriptionDetailOutput implements IJobDescriptionDetailOutput {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;
    elementId: string | undefined;
    elementName: string | undefined;
    dataValue: number | undefined;
    category: number | undefined;
    lowerCIBound: number | undefined;
    upperCIBound: number | undefined;
    liftingJobDemand: string | undefined;
    unilateralCarryJobDemand: string | undefined;
    bilateralCarryJobDemand: string | undefined;
    pushPullJobDemand: string | undefined;
    kneelingJobDemand: string | undefined;
    crouchingJobDemand: string | undefined;
    midLevelReachJobDemand: string | undefined;
    elevatedReachJobDemand: string | undefined;
    sittingJobDemand: string | undefined;
    standingJobDemand: string | undefined;
    crawlingJobDemand: string | undefined;
    repFootMotionJobDemand: string | undefined;
    stairClimbingJobDemand: string | undefined;
    walkingJobDemand: string | undefined;
    balanceJobDemand: string | undefined;
    ladderWorkJobDemand: string | undefined;
    squattingJobDemand: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IJobDescriptionDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.description = data["description"];
            this.title = data["title"];
            this.elementId = data["elementId"];
            this.elementName = data["elementName"];
            this.dataValue = data["dataValue"];
            this.category = data["category"];
            this.lowerCIBound = data["lowerCIBound"];
            this.upperCIBound = data["upperCIBound"];
            this.liftingJobDemand = data["liftingJobDemand"];
            this.unilateralCarryJobDemand = data["unilateralCarryJobDemand"];
            this.bilateralCarryJobDemand = data["bilateralCarryJobDemand"];
            this.pushPullJobDemand = data["pushPullJobDemand"];
            this.kneelingJobDemand = data["kneelingJobDemand"];
            this.crouchingJobDemand = data["crouchingJobDemand"];
            this.midLevelReachJobDemand = data["midLevelReachJobDemand"];
            this.elevatedReachJobDemand = data["elevatedReachJobDemand"];
            this.sittingJobDemand = data["sittingJobDemand"];
            this.standingJobDemand = data["standingJobDemand"];
            this.crawlingJobDemand = data["crawlingJobDemand"];
            this.repFootMotionJobDemand = data["repFootMotionJobDemand"];
            this.stairClimbingJobDemand = data["stairClimbingJobDemand"];
            this.walkingJobDemand = data["walkingJobDemand"];
            this.balanceJobDemand = data["balanceJobDemand"];
            this.ladderWorkJobDemand = data["ladderWorkJobDemand"];
            this.squattingJobDemand = data["squattingJobDemand"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): JobDescriptionDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new JobDescriptionDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["title"] = this.title;
        data["elementId"] = this.elementId;
        data["elementName"] = this.elementName;
        data["dataValue"] = this.dataValue;
        data["category"] = this.category;
        data["lowerCIBound"] = this.lowerCIBound;
        data["upperCIBound"] = this.upperCIBound;
        data["liftingJobDemand"] = this.liftingJobDemand;
        data["unilateralCarryJobDemand"] = this.unilateralCarryJobDemand;
        data["bilateralCarryJobDemand"] = this.bilateralCarryJobDemand;
        data["pushPullJobDemand"] = this.pushPullJobDemand;
        data["kneelingJobDemand"] = this.kneelingJobDemand;
        data["crouchingJobDemand"] = this.crouchingJobDemand;
        data["midLevelReachJobDemand"] = this.midLevelReachJobDemand;
        data["elevatedReachJobDemand"] = this.elevatedReachJobDemand;
        data["sittingJobDemand"] = this.sittingJobDemand;
        data["standingJobDemand"] = this.standingJobDemand;
        data["crawlingJobDemand"] = this.crawlingJobDemand;
        data["repFootMotionJobDemand"] = this.repFootMotionJobDemand;
        data["stairClimbingJobDemand"] = this.stairClimbingJobDemand;
        data["walkingJobDemand"] = this.walkingJobDemand;
        data["balanceJobDemand"] = this.balanceJobDemand;
        data["ladderWorkJobDemand"] = this.ladderWorkJobDemand;
        data["squattingJobDemand"] = this.squattingJobDemand;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): JobDescriptionDetailOutput {
        const json = this.toJSON();
        let result = new JobDescriptionDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IJobDescriptionDetailOutput {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;
    elementId: string | undefined;
    elementName: string | undefined;
    dataValue: number | undefined;
    category: number | undefined;
    lowerCIBound: number | undefined;
    upperCIBound: number | undefined;
    liftingJobDemand: string | undefined;
    unilateralCarryJobDemand: string | undefined;
    bilateralCarryJobDemand: string | undefined;
    pushPullJobDemand: string | undefined;
    kneelingJobDemand: string | undefined;
    crouchingJobDemand: string | undefined;
    midLevelReachJobDemand: string | undefined;
    elevatedReachJobDemand: string | undefined;
    sittingJobDemand: string | undefined;
    standingJobDemand: string | undefined;
    crawlingJobDemand: string | undefined;
    repFootMotionJobDemand: string | undefined;
    stairClimbingJobDemand: string | undefined;
    walkingJobDemand: string | undefined;
    balanceJobDemand: string | undefined;
    ladderWorkJobDemand: string | undefined;
    squattingJobDemand: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class JobDescriptionListDto implements IJobDescriptionListDto {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;
    elementId: string | undefined;
    elementName: string | undefined;
    dataValue: number | undefined;
    category: number | undefined;
    lowerCIBound: number | undefined;
    upperCIBound: number | undefined;
    liftingJobDemand: string | undefined;
    unilateralCarryJobDemand: string | undefined;
    bilateralCarryJobDemand: string | undefined;
    pushPullJobDemand: string | undefined;
    kneelingJobDemand: string | undefined;
    crouchingJobDemand: string | undefined;
    midLevelReachJobDemand: string | undefined;
    elevatedReachJobDemand: string | undefined;
    sittingJobDemand: string | undefined;
    standingJobDemand: string | undefined;
    crawlingJobDemand: string | undefined;
    repFootMotionJobDemand: string | undefined;
    stairClimbingJobDemand: string | undefined;
    walkingJobDemand: string | undefined;
    balanceJobDemand: string | undefined;
    ladderWorkJobDemand: string | undefined;
    squattingJobDemand: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IJobDescriptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.description = data["description"];
            this.title = data["title"];
            this.elementId = data["elementId"];
            this.elementName = data["elementName"];
            this.dataValue = data["dataValue"];
            this.category = data["category"];
            this.lowerCIBound = data["lowerCIBound"];
            this.upperCIBound = data["upperCIBound"];
            this.liftingJobDemand = data["liftingJobDemand"];
            this.unilateralCarryJobDemand = data["unilateralCarryJobDemand"];
            this.bilateralCarryJobDemand = data["bilateralCarryJobDemand"];
            this.pushPullJobDemand = data["pushPullJobDemand"];
            this.kneelingJobDemand = data["kneelingJobDemand"];
            this.crouchingJobDemand = data["crouchingJobDemand"];
            this.midLevelReachJobDemand = data["midLevelReachJobDemand"];
            this.elevatedReachJobDemand = data["elevatedReachJobDemand"];
            this.sittingJobDemand = data["sittingJobDemand"];
            this.standingJobDemand = data["standingJobDemand"];
            this.crawlingJobDemand = data["crawlingJobDemand"];
            this.repFootMotionJobDemand = data["repFootMotionJobDemand"];
            this.stairClimbingJobDemand = data["stairClimbingJobDemand"];
            this.walkingJobDemand = data["walkingJobDemand"];
            this.balanceJobDemand = data["balanceJobDemand"];
            this.ladderWorkJobDemand = data["ladderWorkJobDemand"];
            this.squattingJobDemand = data["squattingJobDemand"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): JobDescriptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobDescriptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["title"] = this.title;
        data["elementId"] = this.elementId;
        data["elementName"] = this.elementName;
        data["dataValue"] = this.dataValue;
        data["category"] = this.category;
        data["lowerCIBound"] = this.lowerCIBound;
        data["upperCIBound"] = this.upperCIBound;
        data["liftingJobDemand"] = this.liftingJobDemand;
        data["unilateralCarryJobDemand"] = this.unilateralCarryJobDemand;
        data["bilateralCarryJobDemand"] = this.bilateralCarryJobDemand;
        data["pushPullJobDemand"] = this.pushPullJobDemand;
        data["kneelingJobDemand"] = this.kneelingJobDemand;
        data["crouchingJobDemand"] = this.crouchingJobDemand;
        data["midLevelReachJobDemand"] = this.midLevelReachJobDemand;
        data["elevatedReachJobDemand"] = this.elevatedReachJobDemand;
        data["sittingJobDemand"] = this.sittingJobDemand;
        data["standingJobDemand"] = this.standingJobDemand;
        data["crawlingJobDemand"] = this.crawlingJobDemand;
        data["repFootMotionJobDemand"] = this.repFootMotionJobDemand;
        data["stairClimbingJobDemand"] = this.stairClimbingJobDemand;
        data["walkingJobDemand"] = this.walkingJobDemand;
        data["balanceJobDemand"] = this.balanceJobDemand;
        data["ladderWorkJobDemand"] = this.ladderWorkJobDemand;
        data["squattingJobDemand"] = this.squattingJobDemand;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): JobDescriptionListDto {
        const json = this.toJSON();
        let result = new JobDescriptionListDto();
        result.init(json);
        return result;
    }
}

export interface IJobDescriptionListDto {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;
    elementId: string | undefined;
    elementName: string | undefined;
    dataValue: number | undefined;
    category: number | undefined;
    lowerCIBound: number | undefined;
    upperCIBound: number | undefined;
    liftingJobDemand: string | undefined;
    unilateralCarryJobDemand: string | undefined;
    bilateralCarryJobDemand: string | undefined;
    pushPullJobDemand: string | undefined;
    kneelingJobDemand: string | undefined;
    crouchingJobDemand: string | undefined;
    midLevelReachJobDemand: string | undefined;
    elevatedReachJobDemand: string | undefined;
    sittingJobDemand: string | undefined;
    standingJobDemand: string | undefined;
    crawlingJobDemand: string | undefined;
    repFootMotionJobDemand: string | undefined;
    stairClimbingJobDemand: string | undefined;
    walkingJobDemand: string | undefined;
    balanceJobDemand: string | undefined;
    ladderWorkJobDemand: string | undefined;
    squattingJobDemand: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfJobDescriptionListDto implements IPagedResultDtoOfJobDescriptionListDto {
    totalCount: number | undefined;
    items: JobDescriptionListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobDescriptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(JobDescriptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobDescriptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobDescriptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfJobDescriptionListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfJobDescriptionListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfJobDescriptionListDto {
    totalCount: number | undefined;
    items: JobDescriptionListDto[] | undefined;
}

export class KneelingTestCreateInput implements IKneelingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;

    constructor(data?: IKneelingTestCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): KneelingTestCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new KneelingTestCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): KneelingTestCreateInput {
        const json = this.toJSON();
        let result = new KneelingTestCreateInput();
        result.init(json);
        return result;
    }
}

export interface IKneelingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
}

export class ListResultDtoOfKneelingTestDto implements IListResultDtoOfKneelingTestDto {
    items: KneelingTestDto[] | undefined;

    constructor(data?: IListResultDtoOfKneelingTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(KneelingTestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfKneelingTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfKneelingTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfKneelingTestDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfKneelingTestDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfKneelingTestDto {
    items: KneelingTestDto[] | undefined;
}

export class KneelingTestDto implements IKneelingTestDto {
    kneelingId: string | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    id: string | undefined;

    constructor(data?: IKneelingTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.kneelingId = data["kneelingId"];
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): KneelingTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new KneelingTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kneelingId"] = this.kneelingId;
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data; 
    }

    clone(): KneelingTestDto {
        const json = this.toJSON();
        let result = new KneelingTestDto();
        result.init(json);
        return result;
    }
}

export interface IKneelingTestDto {
    kneelingId: string | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    id: string | undefined;
}

export class KneelingDto implements IKneelingDto {
    kneelingTests: KneelingTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    taskType: string | undefined;
    chosen: boolean | undefined;
    rating: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IKneelingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["kneelingTests"] && data["kneelingTests"].constructor === Array) {
                this.kneelingTests = [];
                for (let item of data["kneelingTests"])
                    this.kneelingTests.push(KneelingTestDto.fromJS(item));
            }
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.taskType = data["taskType"];
            this.chosen = data["chosen"];
            this.rating = data["rating"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): KneelingDto {
        data = typeof data === 'object' ? data : {};
        let result = new KneelingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.kneelingTests && this.kneelingTests.constructor === Array) {
            data["kneelingTests"] = [];
            for (let item of this.kneelingTests)
                data["kneelingTests"].push(item.toJSON());
        }
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["taskType"] = this.taskType;
        data["chosen"] = this.chosen;
        data["rating"] = this.rating;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): KneelingDto {
        const json = this.toJSON();
        let result = new KneelingDto();
        result.init(json);
        return result;
    }
}

export interface IKneelingDto {
    kneelingTests: KneelingTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    taskType: string | undefined;
    chosen: boolean | undefined;
    rating: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class LadderWorkCreateInput implements ILadderWorkCreateInput {
    clientId: string | undefined;
    timeTaken: number | undefined;
    numTests: number | undefined;
    numSets: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;

    constructor(data?: ILadderWorkCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.numTests = data["numTests"];
            this.numSets = data["numSets"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.chosen = data["chosen"];
        }
    }

    static fromJS(data: any): LadderWorkCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new LadderWorkCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["numTests"] = this.numTests;
        data["numSets"] = this.numSets;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["chosen"] = this.chosen;
        return data; 
    }

    clone(): LadderWorkCreateInput {
        const json = this.toJSON();
        let result = new LadderWorkCreateInput();
        result.init(json);
        return result;
    }
}

export interface ILadderWorkCreateInput {
    clientId: string | undefined;
    timeTaken: number | undefined;
    numTests: number | undefined;
    numSets: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
}

export class LadderWorkProtocolDto implements ILadderWorkProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    chosen: boolean | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    ladderWorkOptions: LadderWorkOptionDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILadderWorkProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.chosen = data["chosen"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            if (data["ladderWorkOptions"] && data["ladderWorkOptions"].constructor === Array) {
                this.ladderWorkOptions = [];
                for (let item of data["ladderWorkOptions"])
                    this.ladderWorkOptions.push(LadderWorkOptionDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LadderWorkProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new LadderWorkProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["chosen"] = this.chosen;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        if (this.ladderWorkOptions && this.ladderWorkOptions.constructor === Array) {
            data["ladderWorkOptions"] = [];
            for (let item of this.ladderWorkOptions)
                data["ladderWorkOptions"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LadderWorkProtocolDto {
        const json = this.toJSON();
        let result = new LadderWorkProtocolDto();
        result.init(json);
        return result;
    }
}

export interface ILadderWorkProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    chosen: boolean | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    ladderWorkOptions: LadderWorkOptionDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class LadderWorkOptionDto implements ILadderWorkOptionDto {
    ladderWorkProtocolId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    numTests: number | undefined;
    numSets: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILadderWorkOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ladderWorkProtocolId = data["ladderWorkProtocolId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.numTests = data["numTests"];
            this.numSets = data["numSets"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LadderWorkOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new LadderWorkOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ladderWorkProtocolId"] = this.ladderWorkProtocolId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["numTests"] = this.numTests;
        data["numSets"] = this.numSets;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LadderWorkOptionDto {
        const json = this.toJSON();
        let result = new LadderWorkOptionDto();
        result.init(json);
        return result;
    }
}

export interface ILadderWorkOptionDto {
    ladderWorkProtocolId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    numTests: number | undefined;
    numSets: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfLadderWorkOptionDto implements IListResultDtoOfLadderWorkOptionDto {
    items: LadderWorkOptionDto[] | undefined;

    constructor(data?: IListResultDtoOfLadderWorkOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LadderWorkOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLadderWorkOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLadderWorkOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfLadderWorkOptionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfLadderWorkOptionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfLadderWorkOptionDto {
    items: LadderWorkOptionDto[] | undefined;
}

export class CreateLawFirmInput implements ICreateLawFirmInput {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: CreateAddressInput | undefined;
    postalAddressId: number | undefined;
    postalAddress: CreateAddressInput | undefined;
    sameAddress: boolean | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;

    constructor(data?: ICreateLawFirmInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.physicalAddressId = data["physicalAddressId"];
            this.physicalAddress = data["physicalAddress"] ? CreateAddressInput.fromJS(data["physicalAddress"]) : <any>undefined;
            this.postalAddressId = data["postalAddressId"];
            this.postalAddress = data["postalAddress"] ? CreateAddressInput.fromJS(data["postalAddress"]) : <any>undefined;
            this.sameAddress = data["sameAddress"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.fax = data["fax"];
        }
    }

    static fromJS(data: any): CreateLawFirmInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLawFirmInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["physicalAddressId"] = this.physicalAddressId;
        data["physicalAddress"] = this.physicalAddress ? this.physicalAddress.toJSON() : <any>undefined;
        data["postalAddressId"] = this.postalAddressId;
        data["postalAddress"] = this.postalAddress ? this.postalAddress.toJSON() : <any>undefined;
        data["sameAddress"] = this.sameAddress;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        return data; 
    }

    clone(): CreateLawFirmInput {
        const json = this.toJSON();
        let result = new CreateLawFirmInput();
        result.init(json);
        return result;
    }
}

export interface ICreateLawFirmInput {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: CreateAddressInput | undefined;
    postalAddressId: number | undefined;
    postalAddress: CreateAddressInput | undefined;
    sameAddress: boolean | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
}

export class LawFirmDetailOutput implements ILawFirmDetailOutput {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: AddressDetailOutput | undefined;
    postalAddressId: number | undefined;
    postalAddress: AddressDetailOutput | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    sameAddress: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILawFirmDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.physicalAddressId = data["physicalAddressId"];
            this.physicalAddress = data["physicalAddress"] ? AddressDetailOutput.fromJS(data["physicalAddress"]) : <any>undefined;
            this.postalAddressId = data["postalAddressId"];
            this.postalAddress = data["postalAddress"] ? AddressDetailOutput.fromJS(data["postalAddress"]) : <any>undefined;
            this.email = data["email"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.sameAddress = data["sameAddress"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LawFirmDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LawFirmDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["physicalAddressId"] = this.physicalAddressId;
        data["physicalAddress"] = this.physicalAddress ? this.physicalAddress.toJSON() : <any>undefined;
        data["postalAddressId"] = this.postalAddressId;
        data["postalAddress"] = this.postalAddress ? this.postalAddress.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["sameAddress"] = this.sameAddress;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LawFirmDetailOutput {
        const json = this.toJSON();
        let result = new LawFirmDetailOutput();
        result.init(json);
        return result;
    }
}

export interface ILawFirmDetailOutput {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: AddressDetailOutput | undefined;
    postalAddressId: number | undefined;
    postalAddress: AddressDetailOutput | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    sameAddress: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class AddressDetailOutput implements IAddressDetailOutput {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;
    id: number | undefined;

    constructor(data?: IAddressDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.city = data["city"];
            this.postalCode = data["postalCode"];
            this.province = data["province"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AddressDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["province"] = this.province;
        data["id"] = this.id;
        return data; 
    }

    clone(): AddressDetailOutput {
        const json = this.toJSON();
        let result = new AddressDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IAddressDetailOutput {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;
    id: number | undefined;
}

export class LawFirmListDto implements ILawFirmListDto {
    companyName: string | undefined;
    physicalAddress: Address | undefined;
    postalAddress: Address | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILawFirmListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.physicalAddress = data["physicalAddress"] ? Address.fromJS(data["physicalAddress"]) : <any>undefined;
            this.postalAddress = data["postalAddress"] ? Address.fromJS(data["postalAddress"]) : <any>undefined;
            this.email = data["email"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LawFirmListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LawFirmListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["physicalAddress"] = this.physicalAddress ? this.physicalAddress.toJSON() : <any>undefined;
        data["postalAddress"] = this.postalAddress ? this.postalAddress.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LawFirmListDto {
        const json = this.toJSON();
        let result = new LawFirmListDto();
        result.init(json);
        return result;
    }
}

export interface ILawFirmListDto {
    companyName: string | undefined;
    physicalAddress: Address | undefined;
    postalAddress: Address | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfLawFirmListDto implements IListResultDtoOfLawFirmListDto {
    items: LawFirmListDto[] | undefined;

    constructor(data?: IListResultDtoOfLawFirmListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LawFirmListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLawFirmListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLawFirmListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfLawFirmListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfLawFirmListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfLawFirmListDto {
    items: LawFirmListDto[] | undefined;
}

export class PagedResultDtoOfLawFirmListDto implements IPagedResultDtoOfLawFirmListDto {
    totalCount: number | undefined;
    items: LawFirmListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLawFirmListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LawFirmListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLawFirmListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLawFirmListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLawFirmListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLawFirmListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLawFirmListDto {
    totalCount: number | undefined;
    items: LawFirmListDto[] | undefined;
}

export class LiftingTestCreateInput implements ILiftingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;

    constructor(data?: ILiftingTestCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): LiftingTestCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new LiftingTestCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): LiftingTestCreateInput {
        const json = this.toJSON();
        let result = new LiftingTestCreateInput();
        result.init(json);
        return result;
    }
}

export interface ILiftingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
}

export class LiftingTestDetailOutput implements ILiftingTestDetailOutput {
    liftingId: string | undefined;
    clientId: string | undefined;
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    client: Client | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILiftingTestDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.liftingId = data["liftingId"];
            this.clientId = data["clientId"];
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LiftingTestDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LiftingTestDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["liftingId"] = this.liftingId;
        data["clientId"] = this.clientId;
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LiftingTestDetailOutput {
        const json = this.toJSON();
        let result = new LiftingTestDetailOutput();
        result.init(json);
        return result;
    }
}

export interface ILiftingTestDetailOutput {
    liftingId: string | undefined;
    clientId: string | undefined;
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    client: Client | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class LiftingTestDto implements ILiftingTestDto {
    liftingId: string | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    id: string | undefined;

    constructor(data?: ILiftingTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.liftingId = data["liftingId"];
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LiftingTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new LiftingTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["liftingId"] = this.liftingId;
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data; 
    }

    clone(): LiftingTestDto {
        const json = this.toJSON();
        let result = new LiftingTestDto();
        result.init(json);
        return result;
    }
}

export interface ILiftingTestDto {
    liftingId: string | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    id: string | undefined;
}

export class LiftWaistTestCreateInput implements ILiftWaistTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    position: string | undefined;
    noOfCompletions: number | undefined;
    maxWeight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    type: number | undefined;
    painLevel: number | undefined;

    constructor(data?: ILiftWaistTestCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.timeTaken = data["timeTaken"];
            this.position = data["position"];
            this.noOfCompletions = data["noOfCompletions"];
            this.maxWeight = data["maxWeight"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.type = data["type"];
            this.painLevel = data["painLevel"];
        }
    }

    static fromJS(data: any): LiftWaistTestCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new LiftWaistTestCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["timeTaken"] = this.timeTaken;
        data["position"] = this.position;
        data["noOfCompletions"] = this.noOfCompletions;
        data["maxWeight"] = this.maxWeight;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["type"] = this.type;
        data["painLevel"] = this.painLevel;
        return data; 
    }

    clone(): LiftWaistTestCreateInput {
        const json = this.toJSON();
        let result = new LiftWaistTestCreateInput();
        result.init(json);
        return result;
    }
}

export interface ILiftWaistTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    position: string | undefined;
    noOfCompletions: number | undefined;
    maxWeight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    type: number | undefined;
    painLevel: number | undefined;
}

export class ListResultDtoOfLiftWaistTestDto implements IListResultDtoOfLiftWaistTestDto {
    items: LiftWaistTestDto[] | undefined;

    constructor(data?: IListResultDtoOfLiftWaistTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LiftWaistTestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLiftWaistTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLiftWaistTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfLiftWaistTestDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfLiftWaistTestDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfLiftWaistTestDto {
    items: LiftWaistTestDto[] | undefined;
}

export class LiftWaistTestDto implements ILiftWaistTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    position: string | undefined;
    noOfCompletions: number | undefined;
    maxWeight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    liftWaistId: string | undefined;
    painLevel: number | undefined;
    type: number | undefined;
    id: string | undefined;

    constructor(data?: ILiftWaistTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.timeTaken = data["timeTaken"];
            this.position = data["position"];
            this.noOfCompletions = data["noOfCompletions"];
            this.maxWeight = data["maxWeight"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.liftWaistId = data["liftWaistId"];
            this.painLevel = data["painLevel"];
            this.type = data["type"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LiftWaistTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new LiftWaistTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["timeTaken"] = this.timeTaken;
        data["position"] = this.position;
        data["noOfCompletions"] = this.noOfCompletions;
        data["maxWeight"] = this.maxWeight;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["liftWaistId"] = this.liftWaistId;
        data["painLevel"] = this.painLevel;
        data["type"] = this.type;
        data["id"] = this.id;
        return data; 
    }

    clone(): LiftWaistTestDto {
        const json = this.toJSON();
        let result = new LiftWaistTestDto();
        result.init(json);
        return result;
    }
}

export interface ILiftWaistTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    position: string | undefined;
    noOfCompletions: number | undefined;
    maxWeight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    liftWaistId: string | undefined;
    painLevel: number | undefined;
    type: number | undefined;
    id: string | undefined;
}

export class LiftWaistDto implements ILiftWaistDto {
    liftWaistTests: LiftWaistTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILiftWaistDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["liftWaistTests"] && data["liftWaistTests"].constructor === Array) {
                this.liftWaistTests = [];
                for (let item of data["liftWaistTests"])
                    this.liftWaistTests.push(LiftWaistTestDto.fromJS(item));
            }
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LiftWaistDto {
        data = typeof data === 'object' ? data : {};
        let result = new LiftWaistDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.liftWaistTests && this.liftWaistTests.constructor === Array) {
            data["liftWaistTests"] = [];
            for (let item of this.liftWaistTests)
                data["liftWaistTests"].push(item.toJSON());
        }
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LiftWaistDto {
        const json = this.toJSON();
        let result = new LiftWaistDto();
        result.init(json);
        return result;
    }
}

export interface ILiftWaistDto {
    liftWaistTests: LiftWaistTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class MidLevelReachCreateInput implements IMidLevelReachCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    side: number | undefined;
    position: number | undefined;
    comment: string | undefined;

    constructor(data?: IMidLevelReachCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.side = data["side"];
            this.position = data["position"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): MidLevelReachCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new MidLevelReachCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["side"] = this.side;
        data["position"] = this.position;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): MidLevelReachCreateInput {
        const json = this.toJSON();
        let result = new MidLevelReachCreateInput();
        result.init(json);
        return result;
    }
}

export interface IMidLevelReachCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    side: number | undefined;
    position: number | undefined;
    comment: string | undefined;
}

export class ListResultDtoOfMidLevelReachTestDto implements IListResultDtoOfMidLevelReachTestDto {
    items: MidLevelReachTestDto[] | undefined;

    constructor(data?: IListResultDtoOfMidLevelReachTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MidLevelReachTestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfMidLevelReachTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfMidLevelReachTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfMidLevelReachTestDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfMidLevelReachTestDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfMidLevelReachTestDto {
    items: MidLevelReachTestDto[] | undefined;
}

export class MidLevelReachTestDto implements IMidLevelReachTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    side: number | undefined;
    position: number | undefined;
    comment: string | undefined;
    midLevelReachId: string | undefined;
    id: string | undefined;

    constructor(data?: IMidLevelReachTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.side = data["side"];
            this.position = data["position"];
            this.comment = data["comment"];
            this.midLevelReachId = data["midLevelReachId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MidLevelReachTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new MidLevelReachTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["side"] = this.side;
        data["position"] = this.position;
        data["comment"] = this.comment;
        data["midLevelReachId"] = this.midLevelReachId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MidLevelReachTestDto {
        const json = this.toJSON();
        let result = new MidLevelReachTestDto();
        result.init(json);
        return result;
    }
}

export interface IMidLevelReachTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    side: number | undefined;
    position: number | undefined;
    comment: string | undefined;
    midLevelReachId: string | undefined;
    id: string | undefined;
}

export class MidLevelReachDto implements IMidLevelReachDto {
    midLevelReachTests: MidLevelReachTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    taskType: string | undefined;
    chosen: boolean | undefined;
    rating: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IMidLevelReachDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["midLevelReachTests"] && data["midLevelReachTests"].constructor === Array) {
                this.midLevelReachTests = [];
                for (let item of data["midLevelReachTests"])
                    this.midLevelReachTests.push(MidLevelReachTestDto.fromJS(item));
            }
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.taskType = data["taskType"];
            this.chosen = data["chosen"];
            this.rating = data["rating"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MidLevelReachDto {
        data = typeof data === 'object' ? data : {};
        let result = new MidLevelReachDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.midLevelReachTests && this.midLevelReachTests.constructor === Array) {
            data["midLevelReachTests"] = [];
            for (let item of this.midLevelReachTests)
                data["midLevelReachTests"].push(item.toJSON());
        }
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["taskType"] = this.taskType;
        data["chosen"] = this.chosen;
        data["rating"] = this.rating;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MidLevelReachDto {
        const json = this.toJSON();
        let result = new MidLevelReachDto();
        result.init(json);
        return result;
    }
}

export interface IMidLevelReachDto {
    midLevelReachTests: MidLevelReachTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    taskType: string | undefined;
    chosen: boolean | undefined;
    rating: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class MobilityDto implements IMobilityDto {
    comment: string | undefined;
    clientId: string | undefined;
    status: number | undefined;
    chosen: boolean | undefined;
    isSelected: boolean | undefined;
    id: string | undefined;

    constructor(data?: IMobilityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comment = data["comment"];
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.chosen = data["chosen"];
            this.isSelected = data["isSelected"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobilityDto {
        data = typeof data === 'object' ? data : {};
        let result = new MobilityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["chosen"] = this.chosen;
        data["isSelected"] = this.isSelected;
        data["id"] = this.id;
        return data; 
    }

    clone(): MobilityDto {
        const json = this.toJSON();
        let result = new MobilityDto();
        result.init(json);
        return result;
    }
}

export interface IMobilityDto {
    comment: string | undefined;
    clientId: string | undefined;
    status: number | undefined;
    chosen: boolean | undefined;
    isSelected: boolean | undefined;
    id: string | undefined;
}

export class ListResultDtoOfMobilityDto implements IListResultDtoOfMobilityDto {
    items: MobilityDto[] | undefined;

    constructor(data?: IListResultDtoOfMobilityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MobilityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfMobilityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfMobilityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfMobilityDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfMobilityDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfMobilityDto {
    items: MobilityDto[] | undefined;
}

export class MusclePowerDto implements IMusclePowerDto {
    leftArmResult: number | undefined;
    rightArmResult: number | undefined;
    leftLegResult: number | undefined;
    rightLegResult: number | undefined;
    leftPainLevel: number | undefined;
    rightPainLevel: number | undefined;
    leftSideComment: string | undefined;
    rightSideComment: string | undefined;
    type: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IMusclePowerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leftArmResult = data["leftArmResult"];
            this.rightArmResult = data["rightArmResult"];
            this.leftLegResult = data["leftLegResult"];
            this.rightLegResult = data["rightLegResult"];
            this.leftPainLevel = data["leftPainLevel"];
            this.rightPainLevel = data["rightPainLevel"];
            this.leftSideComment = data["leftSideComment"];
            this.rightSideComment = data["rightSideComment"];
            this.type = data["type"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MusclePowerDto {
        data = typeof data === 'object' ? data : {};
        let result = new MusclePowerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leftArmResult"] = this.leftArmResult;
        data["rightArmResult"] = this.rightArmResult;
        data["leftLegResult"] = this.leftLegResult;
        data["rightLegResult"] = this.rightLegResult;
        data["leftPainLevel"] = this.leftPainLevel;
        data["rightPainLevel"] = this.rightPainLevel;
        data["leftSideComment"] = this.leftSideComment;
        data["rightSideComment"] = this.rightSideComment;
        data["type"] = this.type;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): MusclePowerDto {
        const json = this.toJSON();
        let result = new MusclePowerDto();
        result.init(json);
        return result;
    }
}

export interface IMusclePowerDto {
    leftArmResult: number | undefined;
    rightArmResult: number | undefined;
    leftLegResult: number | undefined;
    rightLegResult: number | undefined;
    leftPainLevel: number | undefined;
    rightPainLevel: number | undefined;
    leftSideComment: string | undefined;
    rightSideComment: string | undefined;
    type: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class MusclePowerOptionDto implements IMusclePowerOptionDto {
    name: string | undefined;
    optionResult: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    musclePowerId: string | undefined;
    comment: string | undefined;
    type: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IMusclePowerOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.optionResult = data["optionResult"];
            this.side = data["side"];
            this.painLevel = data["painLevel"];
            this.musclePowerId = data["musclePowerId"];
            this.comment = data["comment"];
            this.type = data["type"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MusclePowerOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MusclePowerOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["optionResult"] = this.optionResult;
        data["side"] = this.side;
        data["painLevel"] = this.painLevel;
        data["musclePowerId"] = this.musclePowerId;
        data["comment"] = this.comment;
        data["type"] = this.type;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): MusclePowerOptionDto {
        const json = this.toJSON();
        let result = new MusclePowerOptionDto();
        result.init(json);
        return result;
    }
}

export interface IMusclePowerOptionDto {
    name: string | undefined;
    optionResult: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    musclePowerId: string | undefined;
    comment: string | undefined;
    type: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class PostureOptionDto implements IPostureOptionDto {
    name: string | undefined;
    postureOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IPostureOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.postureOptionScore = data["postureOptionScore"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PostureOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostureOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["postureOptionScore"] = this.postureOptionScore;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): PostureOptionDto {
        const json = this.toJSON();
        let result = new PostureOptionDto();
        result.init(json);
        return result;
    }
}

export interface IPostureOptionDto {
    name: string | undefined;
    postureOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfPostureOptionListDto implements IListResultDtoOfPostureOptionListDto {
    items: PostureOptionListDto[] | undefined;

    constructor(data?: IListResultDtoOfPostureOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PostureOptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPostureOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPostureOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfPostureOptionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfPostureOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPostureOptionListDto {
    items: PostureOptionListDto[] | undefined;
}

export class PostureOptionListDto implements IPostureOptionListDto {
    name: string | undefined;
    postureId: string | undefined;
    postureOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IPostureOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.postureId = data["postureId"];
            this.postureOptionScore = data["postureOptionScore"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PostureOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostureOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["postureId"] = this.postureId;
        data["postureOptionScore"] = this.postureOptionScore;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): PostureOptionListDto {
        const json = this.toJSON();
        let result = new PostureOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IPostureOptionListDto {
    name: string | undefined;
    postureId: string | undefined;
    postureOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class ProfileDto implements IProfileDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;

    constructor(data?: IProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
        }
    }

    static fromJS(data: any): ProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data; 
    }

    clone(): ProfileDto {
        const json = this.toJSON();
        let result = new ProfileDto();
        result.init(json);
        return result;
    }
}

export interface IProfileDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
}

export class PullingTestCreateInput implements IPullingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    painLevel: number | undefined;

    constructor(data?: IPullingTestCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.timeTaken = data["timeTaken"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.weight = data["weight"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.painLevel = data["painLevel"];
        }
    }

    static fromJS(data: any): PullingTestCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new PullingTestCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["timeTaken"] = this.timeTaken;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["weight"] = this.weight;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["painLevel"] = this.painLevel;
        return data; 
    }

    clone(): PullingTestCreateInput {
        const json = this.toJSON();
        let result = new PullingTestCreateInput();
        result.init(json);
        return result;
    }
}

export interface IPullingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    painLevel: number | undefined;
}

export class ListResultDtoOfPullingTestDto implements IListResultDtoOfPullingTestDto {
    items: PullingTestDto[] | undefined;

    constructor(data?: IListResultDtoOfPullingTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PullingTestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPullingTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPullingTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfPullingTestDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfPullingTestDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPullingTestDto {
    items: PullingTestDto[] | undefined;
}

export class PullingTestDto implements IPullingTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    painLevel: number | undefined;
    pullingId: string | undefined;
    id: string | undefined;

    constructor(data?: IPullingTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.timeTaken = data["timeTaken"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.weight = data["weight"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.painLevel = data["painLevel"];
            this.pullingId = data["pullingId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PullingTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PullingTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["timeTaken"] = this.timeTaken;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["weight"] = this.weight;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["painLevel"] = this.painLevel;
        data["pullingId"] = this.pullingId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PullingTestDto {
        const json = this.toJSON();
        let result = new PullingTestDto();
        result.init(json);
        return result;
    }
}

export interface IPullingTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    painLevel: number | undefined;
    pullingId: string | undefined;
    id: string | undefined;
}

export class PullingDto implements IPullingDto {
    pullingTests: PullingTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPullingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["pullingTests"] && data["pullingTests"].constructor === Array) {
                this.pullingTests = [];
                for (let item of data["pullingTests"])
                    this.pullingTests.push(PullingTestDto.fromJS(item));
            }
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PullingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PullingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.pullingTests && this.pullingTests.constructor === Array) {
            data["pullingTests"] = [];
            for (let item of this.pullingTests)
                data["pullingTests"].push(item.toJSON());
        }
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PullingDto {
        const json = this.toJSON();
        let result = new PullingDto();
        result.init(json);
        return result;
    }
}

export interface IPullingDto {
    pullingTests: PullingTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PushingTestCreateInput implements IPushingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    painLevel: number | undefined;

    constructor(data?: IPushingTestCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.timeTaken = data["timeTaken"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.weight = data["weight"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.painLevel = data["painLevel"];
        }
    }

    static fromJS(data: any): PushingTestCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new PushingTestCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["timeTaken"] = this.timeTaken;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["weight"] = this.weight;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["painLevel"] = this.painLevel;
        return data; 
    }

    clone(): PushingTestCreateInput {
        const json = this.toJSON();
        let result = new PushingTestCreateInput();
        result.init(json);
        return result;
    }
}

export interface IPushingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    painLevel: number | undefined;
}

export class ListResultDtoOfPushingTestDto implements IListResultDtoOfPushingTestDto {
    items: PushingTestDto[] | undefined;

    constructor(data?: IListResultDtoOfPushingTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PushingTestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPushingTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPushingTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfPushingTestDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfPushingTestDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPushingTestDto {
    items: PushingTestDto[] | undefined;
}

export class PushingTestDto implements IPushingTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    attempt: number | undefined;
    weight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    painLevel: number | undefined;
    pushingId: string | undefined;
    id: string | undefined;

    constructor(data?: IPushingTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.timeTaken = data["timeTaken"];
            this.attempt = data["attempt"];
            this.weight = data["weight"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.painLevel = data["painLevel"];
            this.pushingId = data["pushingId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PushingTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PushingTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["timeTaken"] = this.timeTaken;
        data["attempt"] = this.attempt;
        data["weight"] = this.weight;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["painLevel"] = this.painLevel;
        data["pushingId"] = this.pushingId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PushingTestDto {
        const json = this.toJSON();
        let result = new PushingTestDto();
        result.init(json);
        return result;
    }
}

export interface IPushingTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    attempt: number | undefined;
    weight: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    painLevel: number | undefined;
    pushingId: string | undefined;
    id: string | undefined;
}

export class PushingDto implements IPushingDto {
    pushingTests: PushingTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPushingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["pushingTests"] && data["pushingTests"].constructor === Array) {
                this.pushingTests = [];
                for (let item of data["pushingTests"])
                    this.pushingTests.push(PushingTestDto.fromJS(item));
            }
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PushingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PushingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.pushingTests && this.pushingTests.constructor === Array) {
            data["pushingTests"] = [];
            for (let item of this.pushingTests)
                data["pushingTests"].push(item.toJSON());
        }
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PushingDto {
        const json = this.toJSON();
        let result = new PushingDto();
        result.init(json);
        return result;
    }
}

export interface IPushingDto {
    pushingTests: PushingTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateAssessmentListInput implements ICreateAssessmentListInput {
    clientId: string | undefined;
    userId: number | undefined;

    constructor(data?: ICreateAssessmentListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): CreateAssessmentListInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAssessmentListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): CreateAssessmentListInput {
        const json = this.toJSON();
        let result = new CreateAssessmentListInput();
        result.init(json);
        return result;
    }
}

export interface ICreateAssessmentListInput {
    clientId: string | undefined;
    userId: number | undefined;
}

export class RangeOfMotionDto implements IRangeOfMotionDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRangeOfMotionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RangeOfMotionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RangeOfMotionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RangeOfMotionDto {
        const json = this.toJSON();
        let result = new RangeOfMotionDto();
        result.init(json);
        return result;
    }
}

export interface IRangeOfMotionDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class AnkleDto implements IAnkleDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    dorsiflexion: string | undefined;
    dorsiMusclePower: number | undefined;
    plantarFlexion: string | undefined;
    plantarMusclePower: number | undefined;
    inversion: string | undefined;
    invMusclePower: number | undefined;
    eversion: string | undefined;
    evMusclePower: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAnkleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.dorsiflexion = data["dorsiflexion"];
            this.dorsiMusclePower = data["dorsiMusclePower"];
            this.plantarFlexion = data["plantarFlexion"];
            this.plantarMusclePower = data["plantarMusclePower"];
            this.inversion = data["inversion"];
            this.invMusclePower = data["invMusclePower"];
            this.eversion = data["eversion"];
            this.evMusclePower = data["evMusclePower"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AnkleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnkleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["dorsiflexion"] = this.dorsiflexion;
        data["dorsiMusclePower"] = this.dorsiMusclePower;
        data["plantarFlexion"] = this.plantarFlexion;
        data["plantarMusclePower"] = this.plantarMusclePower;
        data["inversion"] = this.inversion;
        data["invMusclePower"] = this.invMusclePower;
        data["eversion"] = this.eversion;
        data["evMusclePower"] = this.evMusclePower;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AnkleDto {
        const json = this.toJSON();
        let result = new AnkleDto();
        result.init(json);
        return result;
    }
}

export interface IAnkleDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    dorsiflexion: string | undefined;
    dorsiMusclePower: number | undefined;
    plantarFlexion: string | undefined;
    plantarMusclePower: number | undefined;
    inversion: string | undefined;
    invMusclePower: number | undefined;
    eversion: string | undefined;
    evMusclePower: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ElbowDto implements IElbowDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    extMusclePower: number | undefined;
    flexion: string | undefined;
    flexMusclePower: number | undefined;
    pronation: string | undefined;
    proMusclePower: number | undefined;
    supination: string | undefined;
    supMusclePower: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IElbowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.extension = data["extension"];
            this.extMusclePower = data["extMusclePower"];
            this.flexion = data["flexion"];
            this.flexMusclePower = data["flexMusclePower"];
            this.pronation = data["pronation"];
            this.proMusclePower = data["proMusclePower"];
            this.supination = data["supination"];
            this.supMusclePower = data["supMusclePower"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ElbowDto {
        data = typeof data === 'object' ? data : {};
        let result = new ElbowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["extension"] = this.extension;
        data["extMusclePower"] = this.extMusclePower;
        data["flexion"] = this.flexion;
        data["flexMusclePower"] = this.flexMusclePower;
        data["pronation"] = this.pronation;
        data["proMusclePower"] = this.proMusclePower;
        data["supination"] = this.supination;
        data["supMusclePower"] = this.supMusclePower;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ElbowDto {
        const json = this.toJSON();
        let result = new ElbowDto();
        result.init(json);
        return result;
    }
}

export interface IElbowDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    extMusclePower: number | undefined;
    flexion: string | undefined;
    flexMusclePower: number | undefined;
    pronation: string | undefined;
    proMusclePower: number | undefined;
    supination: string | undefined;
    supMusclePower: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ForearmWristDto implements IForearmWristDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    extMusclePower: number | undefined;
    flexion: string | undefined;
    flexMusclePower: number | undefined;
    pronation: string | undefined;
    proMusclePower: number | undefined;
    supination: string | undefined;
    supMusclePower: number | undefined;
    radialDeviation: string | undefined;
    radMusclePower: number | undefined;
    ulnarDeviation: string | undefined;
    ulnMusclePower: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IForearmWristDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.extension = data["extension"];
            this.extMusclePower = data["extMusclePower"];
            this.flexion = data["flexion"];
            this.flexMusclePower = data["flexMusclePower"];
            this.pronation = data["pronation"];
            this.proMusclePower = data["proMusclePower"];
            this.supination = data["supination"];
            this.supMusclePower = data["supMusclePower"];
            this.radialDeviation = data["radialDeviation"];
            this.radMusclePower = data["radMusclePower"];
            this.ulnarDeviation = data["ulnarDeviation"];
            this.ulnMusclePower = data["ulnMusclePower"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ForearmWristDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForearmWristDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["extension"] = this.extension;
        data["extMusclePower"] = this.extMusclePower;
        data["flexion"] = this.flexion;
        data["flexMusclePower"] = this.flexMusclePower;
        data["pronation"] = this.pronation;
        data["proMusclePower"] = this.proMusclePower;
        data["supination"] = this.supination;
        data["supMusclePower"] = this.supMusclePower;
        data["radialDeviation"] = this.radialDeviation;
        data["radMusclePower"] = this.radMusclePower;
        data["ulnarDeviation"] = this.ulnarDeviation;
        data["ulnMusclePower"] = this.ulnMusclePower;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ForearmWristDto {
        const json = this.toJSON();
        let result = new ForearmWristDto();
        result.init(json);
        return result;
    }
}

export interface IForearmWristDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    extMusclePower: number | undefined;
    flexion: string | undefined;
    flexMusclePower: number | undefined;
    pronation: string | undefined;
    proMusclePower: number | undefined;
    supination: string | undefined;
    supMusclePower: number | undefined;
    radialDeviation: string | undefined;
    radMusclePower: number | undefined;
    ulnarDeviation: string | undefined;
    ulnMusclePower: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class HipDto implements IHipDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    extMusclePower: number | undefined;
    flexion: string | undefined;
    flexMusclePower: number | undefined;
    abduction: string | undefined;
    abdMusclePower: number | undefined;
    adduction: string | undefined;
    addMusclePower: number | undefined;
    internalRotation: string | undefined;
    irMusclePower: number | undefined;
    externalRotation: string | undefined;
    erMusclePower: number | undefined;
    painLevel: number | undefined;
    chosen: boolean | undefined;
    comment: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IHipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.extension = data["extension"];
            this.extMusclePower = data["extMusclePower"];
            this.flexion = data["flexion"];
            this.flexMusclePower = data["flexMusclePower"];
            this.abduction = data["abduction"];
            this.abdMusclePower = data["abdMusclePower"];
            this.adduction = data["adduction"];
            this.addMusclePower = data["addMusclePower"];
            this.internalRotation = data["internalRotation"];
            this.irMusclePower = data["irMusclePower"];
            this.externalRotation = data["externalRotation"];
            this.erMusclePower = data["erMusclePower"];
            this.painLevel = data["painLevel"];
            this.chosen = data["chosen"];
            this.comment = data["comment"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HipDto {
        data = typeof data === 'object' ? data : {};
        let result = new HipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["extension"] = this.extension;
        data["extMusclePower"] = this.extMusclePower;
        data["flexion"] = this.flexion;
        data["flexMusclePower"] = this.flexMusclePower;
        data["abduction"] = this.abduction;
        data["abdMusclePower"] = this.abdMusclePower;
        data["adduction"] = this.adduction;
        data["addMusclePower"] = this.addMusclePower;
        data["internalRotation"] = this.internalRotation;
        data["irMusclePower"] = this.irMusclePower;
        data["externalRotation"] = this.externalRotation;
        data["erMusclePower"] = this.erMusclePower;
        data["painLevel"] = this.painLevel;
        data["chosen"] = this.chosen;
        data["comment"] = this.comment;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): HipDto {
        const json = this.toJSON();
        let result = new HipDto();
        result.init(json);
        return result;
    }
}

export interface IHipDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    extMusclePower: number | undefined;
    flexion: string | undefined;
    flexMusclePower: number | undefined;
    abduction: string | undefined;
    abdMusclePower: number | undefined;
    adduction: string | undefined;
    addMusclePower: number | undefined;
    internalRotation: string | undefined;
    irMusclePower: number | undefined;
    externalRotation: string | undefined;
    erMusclePower: number | undefined;
    painLevel: number | undefined;
    chosen: boolean | undefined;
    comment: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class KneeDto implements IKneeDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    extMusclePower: number | undefined;
    flexion: string | undefined;
    flexMusclePower: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IKneeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.extension = data["extension"];
            this.extMusclePower = data["extMusclePower"];
            this.flexion = data["flexion"];
            this.flexMusclePower = data["flexMusclePower"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): KneeDto {
        data = typeof data === 'object' ? data : {};
        let result = new KneeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["extension"] = this.extension;
        data["extMusclePower"] = this.extMusclePower;
        data["flexion"] = this.flexion;
        data["flexMusclePower"] = this.flexMusclePower;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): KneeDto {
        const json = this.toJSON();
        let result = new KneeDto();
        result.init(json);
        return result;
    }
}

export interface IKneeDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    extMusclePower: number | undefined;
    flexion: string | undefined;
    flexMusclePower: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ShoulderDto implements IShoulderDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    extMusclePower: number | undefined;
    flexion: string | undefined;
    flexMusclePower: number | undefined;
    abduction: string | undefined;
    abdMusclePower: number | undefined;
    adduction: string | undefined;
    addMusclePower: number | undefined;
    internalRotation: string | undefined;
    irMusclePower: number | undefined;
    externalRotation: string | undefined;
    erMusclePower: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IShoulderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.extension = data["extension"];
            this.extMusclePower = data["extMusclePower"];
            this.flexion = data["flexion"];
            this.flexMusclePower = data["flexMusclePower"];
            this.abduction = data["abduction"];
            this.abdMusclePower = data["abdMusclePower"];
            this.adduction = data["adduction"];
            this.addMusclePower = data["addMusclePower"];
            this.internalRotation = data["internalRotation"];
            this.irMusclePower = data["irMusclePower"];
            this.externalRotation = data["externalRotation"];
            this.erMusclePower = data["erMusclePower"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ShoulderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShoulderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["extension"] = this.extension;
        data["extMusclePower"] = this.extMusclePower;
        data["flexion"] = this.flexion;
        data["flexMusclePower"] = this.flexMusclePower;
        data["abduction"] = this.abduction;
        data["abdMusclePower"] = this.abdMusclePower;
        data["adduction"] = this.adduction;
        data["addMusclePower"] = this.addMusclePower;
        data["internalRotation"] = this.internalRotation;
        data["irMusclePower"] = this.irMusclePower;
        data["externalRotation"] = this.externalRotation;
        data["erMusclePower"] = this.erMusclePower;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ShoulderDto {
        const json = this.toJSON();
        let result = new ShoulderDto();
        result.init(json);
        return result;
    }
}

export interface IShoulderDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    extMusclePower: number | undefined;
    flexion: string | undefined;
    flexMusclePower: number | undefined;
    abduction: string | undefined;
    abdMusclePower: number | undefined;
    adduction: string | undefined;
    addMusclePower: number | undefined;
    internalRotation: string | undefined;
    irMusclePower: number | undefined;
    externalRotation: string | undefined;
    erMusclePower: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfHandDto implements IListResultDtoOfHandDto {
    items: HandDto[] | undefined;

    constructor(data?: IListResultDtoOfHandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(HandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfHandDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfHandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfHandDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfHandDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfHandDto {
    items: HandDto[] | undefined;
}

export class HandDto implements IHandDto {
    name: string | undefined;
    rangeOfMotionId: string | undefined;
    abduction: number | undefined;
    adduction: number | undefined;
    dipFlexionExtension: number | undefined;
    pipFlexionExtension: number | undefined;
    mpHyperExtension: number | undefined;
    mpFlexion: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    cmExtension: number | undefined;
    cmFlexion: number | undefined;
    ipFlexionExtension: number | undefined;
    opposition: number | undefined;
    position: number | undefined;
    status: number | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IHandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.abduction = data["abduction"];
            this.adduction = data["adduction"];
            this.dipFlexionExtension = data["dipFlexionExtension"];
            this.pipFlexionExtension = data["pipFlexionExtension"];
            this.mpHyperExtension = data["mpHyperExtension"];
            this.mpFlexion = data["mpFlexion"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.cmExtension = data["cmExtension"];
            this.cmFlexion = data["cmFlexion"];
            this.ipFlexionExtension = data["ipFlexionExtension"];
            this.opposition = data["opposition"];
            this.position = data["position"];
            this.status = data["status"];
            this.side = data["side"];
            this.chosen = data["chosen"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HandDto {
        data = typeof data === 'object' ? data : {};
        let result = new HandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["abduction"] = this.abduction;
        data["adduction"] = this.adduction;
        data["dipFlexionExtension"] = this.dipFlexionExtension;
        data["pipFlexionExtension"] = this.pipFlexionExtension;
        data["mpHyperExtension"] = this.mpHyperExtension;
        data["mpFlexion"] = this.mpFlexion;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["cmExtension"] = this.cmExtension;
        data["cmFlexion"] = this.cmFlexion;
        data["ipFlexionExtension"] = this.ipFlexionExtension;
        data["opposition"] = this.opposition;
        data["position"] = this.position;
        data["status"] = this.status;
        data["side"] = this.side;
        data["chosen"] = this.chosen;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): HandDto {
        const json = this.toJSON();
        let result = new HandDto();
        result.init(json);
        return result;
    }
}

export interface IHandDto {
    name: string | undefined;
    rangeOfMotionId: string | undefined;
    abduction: number | undefined;
    adduction: number | undefined;
    dipFlexionExtension: number | undefined;
    pipFlexionExtension: number | undefined;
    mpHyperExtension: number | undefined;
    mpFlexion: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    cmExtension: number | undefined;
    cmFlexion: number | undefined;
    ipFlexionExtension: number | undefined;
    opposition: number | undefined;
    position: number | undefined;
    status: number | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class RangeOfMotionSelectionDto implements IRangeOfMotionSelectionDto {
    clientId: string | undefined;
    identifier: number | undefined;
    sides: number[] | undefined;

    constructor(data?: IRangeOfMotionSelectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.identifier = data["identifier"];
            if (data["sides"] && data["sides"].constructor === Array) {
                this.sides = [];
                for (let item of data["sides"])
                    this.sides.push(item);
            }
        }
    }

    static fromJS(data: any): RangeOfMotionSelectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RangeOfMotionSelectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["identifier"] = this.identifier;
        if (this.sides && this.sides.constructor === Array) {
            data["sides"] = [];
            for (let item of this.sides)
                data["sides"].push(item);
        }
        return data; 
    }

    clone(): RangeOfMotionSelectionDto {
        const json = this.toJSON();
        let result = new RangeOfMotionSelectionDto();
        result.init(json);
        return result;
    }
}

export interface IRangeOfMotionSelectionDto {
    clientId: string | undefined;
    identifier: number | undefined;
    sides: number[] | undefined;
}

export class ListResultDtoOfRepetitiveFootMotionProtocolDto implements IListResultDtoOfRepetitiveFootMotionProtocolDto {
    items: RepetitiveFootMotionProtocolDto[] | undefined;

    constructor(data?: IListResultDtoOfRepetitiveFootMotionProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RepetitiveFootMotionProtocolDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRepetitiveFootMotionProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRepetitiveFootMotionProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRepetitiveFootMotionProtocolDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRepetitiveFootMotionProtocolDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRepetitiveFootMotionProtocolDto {
    items: RepetitiveFootMotionProtocolDto[] | undefined;
}

export class RepetitiveFootMotionProtocolDto implements IRepetitiveFootMotionProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    result: string | undefined;
    otComments: string | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    repetitiveFootMotionOptions: RepetitiveFootMotionOptionDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRepetitiveFootMotionProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.result = data["result"];
            this.otComments = data["otComments"];
            this.isStopped = data["isStopped"];
            this.chosen = data["chosen"];
            if (data["repetitiveFootMotionOptions"] && data["repetitiveFootMotionOptions"].constructor === Array) {
                this.repetitiveFootMotionOptions = [];
                for (let item of data["repetitiveFootMotionOptions"])
                    this.repetitiveFootMotionOptions.push(RepetitiveFootMotionOptionDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RepetitiveFootMotionProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepetitiveFootMotionProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["result"] = this.result;
        data["otComments"] = this.otComments;
        data["isStopped"] = this.isStopped;
        data["chosen"] = this.chosen;
        if (this.repetitiveFootMotionOptions && this.repetitiveFootMotionOptions.constructor === Array) {
            data["repetitiveFootMotionOptions"] = [];
            for (let item of this.repetitiveFootMotionOptions)
                data["repetitiveFootMotionOptions"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RepetitiveFootMotionProtocolDto {
        const json = this.toJSON();
        let result = new RepetitiveFootMotionProtocolDto();
        result.init(json);
        return result;
    }
}

export interface IRepetitiveFootMotionProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    result: string | undefined;
    otComments: string | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    repetitiveFootMotionOptions: RepetitiveFootMotionOptionDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class RepetitiveFootMotionOptionDto implements IRepetitiveFootMotionOptionDto {
    repetitiveFootMotionProtocolId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    numTests: number | undefined;
    comment: string | undefined;
    numDepressions: number | undefined;
    result: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRepetitiveFootMotionOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.repetitiveFootMotionProtocolId = data["repetitiveFootMotionProtocolId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.side = data["side"];
            this.painLevel = data["painLevel"];
            this.numTests = data["numTests"];
            this.comment = data["comment"];
            this.numDepressions = data["numDepressions"];
            this.result = data["result"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RepetitiveFootMotionOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepetitiveFootMotionOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repetitiveFootMotionProtocolId"] = this.repetitiveFootMotionProtocolId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["side"] = this.side;
        data["painLevel"] = this.painLevel;
        data["numTests"] = this.numTests;
        data["comment"] = this.comment;
        data["numDepressions"] = this.numDepressions;
        data["result"] = this.result;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RepetitiveFootMotionOptionDto {
        const json = this.toJSON();
        let result = new RepetitiveFootMotionOptionDto();
        result.init(json);
        return result;
    }
}

export interface IRepetitiveFootMotionOptionDto {
    repetitiveFootMotionProtocolId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    numTests: number | undefined;
    comment: string | undefined;
    numDepressions: number | undefined;
    result: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class RepetitiveSquattingCreateInput implements IRepetitiveSquattingCreateInput {
    clientId: string | undefined;
    timeAtOneMinute: number | undefined;
    timeAtTwoMinutes: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    numSquats: number | undefined;
    numPegsFirstTime: number | undefined;
    numPegsSecondTime: number | undefined;
    thirdHeartRate: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;

    constructor(data?: IRepetitiveSquattingCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.timeAtOneMinute = data["timeAtOneMinute"];
            this.timeAtTwoMinutes = data["timeAtTwoMinutes"];
            this.initialHeartRate = data["initialHeartRate"];
            this.secondHeartRate = data["secondHeartRate"];
            this.numSquats = data["numSquats"];
            this.numPegsFirstTime = data["numPegsFirstTime"];
            this.numPegsSecondTime = data["numPegsSecondTime"];
            this.thirdHeartRate = data["thirdHeartRate"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
        }
    }

    static fromJS(data: any): RepetitiveSquattingCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new RepetitiveSquattingCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["timeAtOneMinute"] = this.timeAtOneMinute;
        data["timeAtTwoMinutes"] = this.timeAtTwoMinutes;
        data["initialHeartRate"] = this.initialHeartRate;
        data["secondHeartRate"] = this.secondHeartRate;
        data["numSquats"] = this.numSquats;
        data["numPegsFirstTime"] = this.numPegsFirstTime;
        data["numPegsSecondTime"] = this.numPegsSecondTime;
        data["thirdHeartRate"] = this.thirdHeartRate;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        return data; 
    }

    clone(): RepetitiveSquattingCreateInput {
        const json = this.toJSON();
        let result = new RepetitiveSquattingCreateInput();
        result.init(json);
        return result;
    }
}

export interface IRepetitiveSquattingCreateInput {
    clientId: string | undefined;
    timeAtOneMinute: number | undefined;
    timeAtTwoMinutes: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    numSquats: number | undefined;
    numPegsFirstTime: number | undefined;
    numPegsSecondTime: number | undefined;
    thirdHeartRate: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
}

export class RepetitiveSquattingProtocolDto implements IRepetitiveSquattingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    repetitveSquattingOptions: RepetitiveSquattingOptionDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRepetitiveSquattingProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.chosen = data["chosen"];
            if (data["repetitveSquattingOptions"] && data["repetitveSquattingOptions"].constructor === Array) {
                this.repetitveSquattingOptions = [];
                for (let item of data["repetitveSquattingOptions"])
                    this.repetitveSquattingOptions.push(RepetitiveSquattingOptionDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RepetitiveSquattingProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepetitiveSquattingProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["chosen"] = this.chosen;
        if (this.repetitveSquattingOptions && this.repetitveSquattingOptions.constructor === Array) {
            data["repetitveSquattingOptions"] = [];
            for (let item of this.repetitveSquattingOptions)
                data["repetitveSquattingOptions"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RepetitiveSquattingProtocolDto {
        const json = this.toJSON();
        let result = new RepetitiveSquattingProtocolDto();
        result.init(json);
        return result;
    }
}

export interface IRepetitiveSquattingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    repetitveSquattingOptions: RepetitiveSquattingOptionDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class RepetitiveSquattingOptionDto implements IRepetitiveSquattingOptionDto {
    repetitiveSquattingId: string | undefined;
    clientId: string | undefined;
    timeAtOneMinute: number | undefined;
    timeAtTwoMinutes: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    numSquats: number | undefined;
    numPegsFirstTime: number | undefined;
    numPegsSecondTime: number | undefined;
    thirdHeartRate: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRepetitiveSquattingOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.repetitiveSquattingId = data["repetitiveSquattingId"];
            this.clientId = data["clientId"];
            this.timeAtOneMinute = data["timeAtOneMinute"];
            this.timeAtTwoMinutes = data["timeAtTwoMinutes"];
            this.initialHeartRate = data["initialHeartRate"];
            this.secondHeartRate = data["secondHeartRate"];
            this.numSquats = data["numSquats"];
            this.numPegsFirstTime = data["numPegsFirstTime"];
            this.numPegsSecondTime = data["numPegsSecondTime"];
            this.thirdHeartRate = data["thirdHeartRate"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RepetitiveSquattingOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepetitiveSquattingOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repetitiveSquattingId"] = this.repetitiveSquattingId;
        data["clientId"] = this.clientId;
        data["timeAtOneMinute"] = this.timeAtOneMinute;
        data["timeAtTwoMinutes"] = this.timeAtTwoMinutes;
        data["initialHeartRate"] = this.initialHeartRate;
        data["secondHeartRate"] = this.secondHeartRate;
        data["numSquats"] = this.numSquats;
        data["numPegsFirstTime"] = this.numPegsFirstTime;
        data["numPegsSecondTime"] = this.numPegsSecondTime;
        data["thirdHeartRate"] = this.thirdHeartRate;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RepetitiveSquattingOptionDto {
        const json = this.toJSON();
        let result = new RepetitiveSquattingOptionDto();
        result.init(json);
        return result;
    }
}

export interface IRepetitiveSquattingOptionDto {
    repetitiveSquattingId: string | undefined;
    clientId: string | undefined;
    timeAtOneMinute: number | undefined;
    timeAtTwoMinutes: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    numSquats: number | undefined;
    numPegsFirstTime: number | undefined;
    numPegsSecondTime: number | undefined;
    thirdHeartRate: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfRepetitiveSquattingOptionDto implements IListResultDtoOfRepetitiveSquattingOptionDto {
    items: RepetitiveSquattingOptionDto[] | undefined;

    constructor(data?: IListResultDtoOfRepetitiveSquattingOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RepetitiveSquattingOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRepetitiveSquattingOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRepetitiveSquattingOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRepetitiveSquattingOptionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRepetitiveSquattingOptionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRepetitiveSquattingOptionDto {
    items: RepetitiveSquattingOptionDto[] | undefined;
}

export class ReportSummaryDto implements IReportSummaryDto {
    clientId: string | undefined;
    discussion: string | undefined;
    lossOfEmenities: string | undefined;
    residualWorkCapacity: string | undefined;
    futureMedicalExpenses: string | undefined;
    futureMedicalAndSurgicalIntervention: string | undefined;
    supplementaryHealthServices: string | undefined;
    physiotherapy: string | undefined;
    occupationalTherapy: string | undefined;
    specialEquipment: string | undefined;
    caseManagement1: string | undefined;
    psychology: string | undefined;
    transportationCosts: string | undefined;
    recommendations: string | undefined;
    id: string | undefined;

    constructor(data?: IReportSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.discussion = data["discussion"];
            this.lossOfEmenities = data["lossOfEmenities"];
            this.residualWorkCapacity = data["residualWorkCapacity"];
            this.futureMedicalExpenses = data["futureMedicalExpenses"];
            this.futureMedicalAndSurgicalIntervention = data["futureMedicalAndSurgicalIntervention"];
            this.supplementaryHealthServices = data["supplementaryHealthServices"];
            this.physiotherapy = data["physiotherapy"];
            this.occupationalTherapy = data["occupationalTherapy"];
            this.specialEquipment = data["specialEquipment"];
            this.caseManagement1 = data["caseManagement1"];
            this.psychology = data["psychology"];
            this.transportationCosts = data["transportationCosts"];
            this.recommendations = data["recommendations"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ReportSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["discussion"] = this.discussion;
        data["lossOfEmenities"] = this.lossOfEmenities;
        data["residualWorkCapacity"] = this.residualWorkCapacity;
        data["futureMedicalExpenses"] = this.futureMedicalExpenses;
        data["futureMedicalAndSurgicalIntervention"] = this.futureMedicalAndSurgicalIntervention;
        data["supplementaryHealthServices"] = this.supplementaryHealthServices;
        data["physiotherapy"] = this.physiotherapy;
        data["occupationalTherapy"] = this.occupationalTherapy;
        data["specialEquipment"] = this.specialEquipment;
        data["caseManagement1"] = this.caseManagement1;
        data["psychology"] = this.psychology;
        data["transportationCosts"] = this.transportationCosts;
        data["recommendations"] = this.recommendations;
        data["id"] = this.id;
        return data; 
    }

    clone(): ReportSummaryDto {
        const json = this.toJSON();
        let result = new ReportSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IReportSummaryDto {
    clientId: string | undefined;
    discussion: string | undefined;
    lossOfEmenities: string | undefined;
    residualWorkCapacity: string | undefined;
    futureMedicalExpenses: string | undefined;
    futureMedicalAndSurgicalIntervention: string | undefined;
    supplementaryHealthServices: string | undefined;
    physiotherapy: string | undefined;
    occupationalTherapy: string | undefined;
    specialEquipment: string | undefined;
    caseManagement1: string | undefined;
    psychology: string | undefined;
    transportationCosts: string | undefined;
    recommendations: string | undefined;
    id: string | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["grantedPermissions"] && data["grantedPermissions"].constructor === Array) {
                this.grantedPermissions = [];
                for (let item of data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.grantedPermissions && this.grantedPermissions.constructor === Array) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["grantedPermissions"] && data["grantedPermissions"].constructor === Array) {
                this.grantedPermissions = [];
                for (let item of data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.grantedPermissions && this.grantedPermissions.constructor === Array) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfPermissionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfRoleDto implements IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;
}

export class SensationOptionDto implements ISensationOptionDto {
    name: string | undefined;
    sensationCategoryId: string | undefined;
    sensationOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: ISensationOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.sensationCategoryId = data["sensationCategoryId"];
            this.sensationOptionScore = data["sensationOptionScore"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.side = data["side"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SensationOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensationOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sensationCategoryId"] = this.sensationCategoryId;
        data["sensationOptionScore"] = this.sensationOptionScore;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["side"] = this.side;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): SensationOptionDto {
        const json = this.toJSON();
        let result = new SensationOptionDto();
        result.init(json);
        return result;
    }
}

export interface ISensationOptionDto {
    name: string | undefined;
    sensationCategoryId: string | undefined;
    sensationOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfSensationOptionDto implements IListResultDtoOfSensationOptionDto {
    items: SensationOptionDto[] | undefined;

    constructor(data?: IListResultDtoOfSensationOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SensationOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSensationOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSensationOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfSensationOptionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfSensationOptionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfSensationOptionDto {
    items: SensationOptionDto[] | undefined;
}

export class CreateSensationInput implements ICreateSensationInput {
    otComment: string | undefined;
    clientId: string | undefined;

    constructor(data?: ICreateSensationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.otComment = data["otComment"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): CreateSensationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSensationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["otComment"] = this.otComment;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): CreateSensationInput {
        const json = this.toJSON();
        let result = new CreateSensationInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSensationInput {
    otComment: string | undefined;
    clientId: string | undefined;
}

export class SensationListDto implements ISensationListDto {
    otComment: string | undefined;
    id: string | undefined;

    constructor(data?: ISensationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.otComment = data["otComment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SensationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["otComment"] = this.otComment;
        data["id"] = this.id;
        return data; 
    }

    clone(): SensationListDto {
        const json = this.toJSON();
        let result = new SensationListDto();
        result.init(json);
        return result;
    }
}

export interface ISensationListDto {
    otComment: string | undefined;
    id: string | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;
}

export class SittingTestCreateInput implements ISittingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;

    constructor(data?: ISittingTestCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): SittingTestCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new SittingTestCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): SittingTestCreateInput {
        const json = this.toJSON();
        let result = new SittingTestCreateInput();
        result.init(json);
        return result;
    }
}

export interface ISittingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
}

export class SittingTestDto implements ISittingTestDto {
    sittingId: string | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    id: string | undefined;

    constructor(data?: ISittingTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sittingId = data["sittingId"];
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SittingTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new SittingTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sittingId"] = this.sittingId;
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data; 
    }

    clone(): SittingTestDto {
        const json = this.toJSON();
        let result = new SittingTestDto();
        result.init(json);
        return result;
    }
}

export interface ISittingTestDto {
    sittingId: string | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    id: string | undefined;
}

export class StairClimbingCreateInput implements IStairClimbingCreateInput {
    clientId: string | undefined;
    timeTaken: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    thirdHeartRate: number | undefined;
    fourthHeartRate: number | undefined;
    numStairs: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;

    constructor(data?: IStairClimbingCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.initialHeartRate = data["initialHeartRate"];
            this.secondHeartRate = data["secondHeartRate"];
            this.thirdHeartRate = data["thirdHeartRate"];
            this.fourthHeartRate = data["fourthHeartRate"];
            this.numStairs = data["numStairs"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
        }
    }

    static fromJS(data: any): StairClimbingCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new StairClimbingCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["initialHeartRate"] = this.initialHeartRate;
        data["secondHeartRate"] = this.secondHeartRate;
        data["thirdHeartRate"] = this.thirdHeartRate;
        data["fourthHeartRate"] = this.fourthHeartRate;
        data["numStairs"] = this.numStairs;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        return data; 
    }

    clone(): StairClimbingCreateInput {
        const json = this.toJSON();
        let result = new StairClimbingCreateInput();
        result.init(json);
        return result;
    }
}

export interface IStairClimbingCreateInput {
    clientId: string | undefined;
    timeTaken: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    thirdHeartRate: number | undefined;
    fourthHeartRate: number | undefined;
    numStairs: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
}

export class StairClimbingProtocolDto implements IStairClimbingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    stairClimbingOptions: StairClimbingOptionDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IStairClimbingProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.chosen = data["chosen"];
            if (data["stairClimbingOptions"] && data["stairClimbingOptions"].constructor === Array) {
                this.stairClimbingOptions = [];
                for (let item of data["stairClimbingOptions"])
                    this.stairClimbingOptions.push(StairClimbingOptionDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StairClimbingProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new StairClimbingProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["chosen"] = this.chosen;
        if (this.stairClimbingOptions && this.stairClimbingOptions.constructor === Array) {
            data["stairClimbingOptions"] = [];
            for (let item of this.stairClimbingOptions)
                data["stairClimbingOptions"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): StairClimbingProtocolDto {
        const json = this.toJSON();
        let result = new StairClimbingProtocolDto();
        result.init(json);
        return result;
    }
}

export interface IStairClimbingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    chosen: boolean | undefined;
    stairClimbingOptions: StairClimbingOptionDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class StairClimbingOptionDto implements IStairClimbingOptionDto {
    stairClimbingProcolId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    thirdHeartRate: number | undefined;
    fourthHeartRate: number | undefined;
    numStairs: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IStairClimbingOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.stairClimbingProcolId = data["stairClimbingProcolId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.initialHeartRate = data["initialHeartRate"];
            this.secondHeartRate = data["secondHeartRate"];
            this.thirdHeartRate = data["thirdHeartRate"];
            this.fourthHeartRate = data["fourthHeartRate"];
            this.numStairs = data["numStairs"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StairClimbingOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new StairClimbingOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stairClimbingProcolId"] = this.stairClimbingProcolId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["initialHeartRate"] = this.initialHeartRate;
        data["secondHeartRate"] = this.secondHeartRate;
        data["thirdHeartRate"] = this.thirdHeartRate;
        data["fourthHeartRate"] = this.fourthHeartRate;
        data["numStairs"] = this.numStairs;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): StairClimbingOptionDto {
        const json = this.toJSON();
        let result = new StairClimbingOptionDto();
        result.init(json);
        return result;
    }
}

export interface IStairClimbingOptionDto {
    stairClimbingProcolId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    thirdHeartRate: number | undefined;
    fourthHeartRate: number | undefined;
    numStairs: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfStairClimbingOptionDto implements IListResultDtoOfStairClimbingOptionDto {
    items: StairClimbingOptionDto[] | undefined;

    constructor(data?: IListResultDtoOfStairClimbingOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(StairClimbingOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfStairClimbingOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfStairClimbingOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfStairClimbingOptionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfStairClimbingOptionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfStairClimbingOptionDto {
    items: StairClimbingOptionDto[] | undefined;
}

export class StandingTestCreateInput implements IStandingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;

    constructor(data?: IStandingTestCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): StandingTestCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new StandingTestCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): StandingTestCreateInput {
        const json = this.toJSON();
        let result = new StandingTestCreateInput();
        result.init(json);
        return result;
    }
}

export interface IStandingTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
}

export class StandingTestDto implements IStandingTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    standingId: string | undefined;
    id: string | undefined;

    constructor(data?: IStandingTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.taskType = data["taskType"];
            this.result = data["result"];
            this.isStopped = data["isStopped"];
            this.trial = data["trial"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.standingId = data["standingId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StandingTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new StandingTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        data["isStopped"] = this.isStopped;
        data["trial"] = this.trial;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["standingId"] = this.standingId;
        data["id"] = this.id;
        return data; 
    }

    clone(): StandingTestDto {
        const json = this.toJSON();
        let result = new StandingTestDto();
        result.init(json);
        return result;
    }
}

export interface IStandingTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    taskType: string | undefined;
    result: string | undefined;
    isStopped: boolean | undefined;
    trial: number | undefined;
    noOfRepetitions: number | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    standingId: string | undefined;
    id: string | undefined;
}

export class AssessmentCategoryDetailOutput implements IAssessmentCategoryDetailOutput {
    name: string | undefined;
    assessments: AssessmentsListListDto[] | undefined;
    id: string | undefined;

    constructor(data?: IAssessmentCategoryDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["assessments"] && data["assessments"].constructor === Array) {
                this.assessments = [];
                for (let item of data["assessments"])
                    this.assessments.push(AssessmentsListListDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssessmentCategoryDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentCategoryDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.assessments && this.assessments.constructor === Array) {
            data["assessments"] = [];
            for (let item of this.assessments)
                data["assessments"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): AssessmentCategoryDetailOutput {
        const json = this.toJSON();
        let result = new AssessmentCategoryDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IAssessmentCategoryDetailOutput {
    name: string | undefined;
    assessments: AssessmentsListListDto[] | undefined;
    id: string | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfTenantDto implements IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTenantDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
}

export class UnilateralTestCreateInput implements IUnilateralTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    hand: string | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    distance: number | undefined;
    isStopped: boolean | undefined;
    painLevel: number | undefined;
    comment: string | undefined;

    constructor(data?: IUnilateralTestCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.status = data["status"];
            this.timeTaken = data["timeTaken"];
            this.hand = data["hand"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.weight = data["weight"];
            this.distance = data["distance"];
            this.isStopped = data["isStopped"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): UnilateralTestCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnilateralTestCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        data["timeTaken"] = this.timeTaken;
        data["hand"] = this.hand;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["weight"] = this.weight;
        data["distance"] = this.distance;
        data["isStopped"] = this.isStopped;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): UnilateralTestCreateInput {
        const json = this.toJSON();
        let result = new UnilateralTestCreateInput();
        result.init(json);
        return result;
    }
}

export interface IUnilateralTestCreateInput {
    clientId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    hand: string | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    distance: number | undefined;
    isStopped: boolean | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
}

export class ListResultDtoOfUnilateralTestDto implements IListResultDtoOfUnilateralTestDto {
    items: UnilateralTestDto[] | undefined;

    constructor(data?: IListResultDtoOfUnilateralTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UnilateralTestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUnilateralTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUnilateralTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfUnilateralTestDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfUnilateralTestDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfUnilateralTestDto {
    items: UnilateralTestDto[] | undefined;
}

export class UnilateralTestDto implements IUnilateralTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    hand: string | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    distance: number | undefined;
    isStopped: boolean | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    unilateralId: string | undefined;
    id: string | undefined;

    constructor(data?: IUnilateralTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.timeTaken = data["timeTaken"];
            this.hand = data["hand"];
            this.noOfRepetitions = data["noOfRepetitions"];
            this.weight = data["weight"];
            this.distance = data["distance"];
            this.isStopped = data["isStopped"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.unilateralId = data["unilateralId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UnilateralTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnilateralTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["timeTaken"] = this.timeTaken;
        data["hand"] = this.hand;
        data["noOfRepetitions"] = this.noOfRepetitions;
        data["weight"] = this.weight;
        data["distance"] = this.distance;
        data["isStopped"] = this.isStopped;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["unilateralId"] = this.unilateralId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UnilateralTestDto {
        const json = this.toJSON();
        let result = new UnilateralTestDto();
        result.init(json);
        return result;
    }
}

export interface IUnilateralTestDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    timeTaken: number | undefined;
    hand: string | undefined;
    noOfRepetitions: number | undefined;
    weight: number | undefined;
    distance: number | undefined;
    isStopped: boolean | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    unilateralId: string | undefined;
    id: string | undefined;
}

export class UnilateralDto implements IUnilateralDto {
    unilateralTests: UnilateralTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IUnilateralDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["unilateralTests"] && data["unilateralTests"].constructor === Array) {
                this.unilateralTests = [];
                for (let item of data["unilateralTests"])
                    this.unilateralTests.push(UnilateralTestDto.fromJS(item));
            }
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.chosen = data["chosen"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UnilateralDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnilateralDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.unilateralTests && this.unilateralTests.constructor === Array) {
            data["unilateralTests"] = [];
            for (let item of this.unilateralTests)
                data["unilateralTests"].push(item.toJSON());
        }
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["chosen"] = this.chosen;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UnilateralDto {
        const json = this.toJSON();
        let result = new UnilateralDto();
        result.init(json);
        return result;
    }
}

export interface IUnilateralDto {
    unilateralTests: UnilateralTestDto[] | undefined;
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    chosen: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleDto implements IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adminPassword = data["adminPassword"];
            this.userId = data["userId"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class PagedResultDtoOfUserDto implements IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;
}

export class WalkingProtocolDetailOutput implements IWalkingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IWalkingProtocolDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WalkingProtocolDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WalkingProtocolDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WalkingProtocolDetailOutput {
        const json = this.toJSON();
        let result = new WalkingProtocolDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IWalkingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class WalkingProtocolDto implements IWalkingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IWalkingProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WalkingProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalkingProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WalkingProtocolDto {
        const json = this.toJSON();
        let result = new WalkingProtocolDto();
        result.init(json);
        return result;
    }
}

export interface IWalkingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class WorkContextDto implements IWorkContextDto {
    onetSocCode: string | undefined;
    title: string | undefined;
    category: number | undefined;
    elementID: string | undefined;
    elementName: string | undefined;
    scaleID: string | undefined;
    scaleName: string | undefined;
    dataValue: number | undefined;
    n: number | undefined;
    standardError: string | undefined;
    lowerCIBound: number | undefined;
    upperCIBound: number | undefined;
    recommendSuppress: string | undefined;
    notRelevant: string | undefined;
    date: moment.Moment | undefined;
    domainSource: string | undefined;

    constructor(data?: IWorkContextDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.onetSocCode = data["onetSocCode"];
            this.title = data["title"];
            this.category = data["category"];
            this.elementID = data["elementID"];
            this.elementName = data["elementName"];
            this.scaleID = data["scaleID"];
            this.scaleName = data["scaleName"];
            this.dataValue = data["dataValue"];
            this.n = data["n"];
            this.standardError = data["standardError"];
            this.lowerCIBound = data["lowerCIBound"];
            this.upperCIBound = data["upperCIBound"];
            this.recommendSuppress = data["recommendSuppress"];
            this.notRelevant = data["notRelevant"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.domainSource = data["domainSource"];
        }
    }

    static fromJS(data: any): WorkContextDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkContextDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onetSocCode"] = this.onetSocCode;
        data["title"] = this.title;
        data["category"] = this.category;
        data["elementID"] = this.elementID;
        data["elementName"] = this.elementName;
        data["scaleID"] = this.scaleID;
        data["scaleName"] = this.scaleName;
        data["dataValue"] = this.dataValue;
        data["n"] = this.n;
        data["standardError"] = this.standardError;
        data["lowerCIBound"] = this.lowerCIBound;
        data["upperCIBound"] = this.upperCIBound;
        data["recommendSuppress"] = this.recommendSuppress;
        data["notRelevant"] = this.notRelevant;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["domainSource"] = this.domainSource;
        return data; 
    }

    clone(): WorkContextDto {
        const json = this.toJSON();
        let result = new WorkContextDto();
        result.init(json);
        return result;
    }
}

export interface IWorkContextDto {
    onetSocCode: string | undefined;
    title: string | undefined;
    category: number | undefined;
    elementID: string | undefined;
    elementName: string | undefined;
    scaleID: string | undefined;
    scaleName: string | undefined;
    dataValue: number | undefined;
    n: number | undefined;
    standardError: string | undefined;
    lowerCIBound: number | undefined;
    upperCIBound: number | undefined;
    recommendSuppress: string | undefined;
    notRelevant: string | undefined;
    date: moment.Moment | undefined;
    domainSource: string | undefined;
}

export class OccupationDto implements IOccupationDto {
    code: string | undefined;
    title: string | undefined;
    relevanceScore: number | undefined;

    constructor(data?: IOccupationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.title = data["title"];
            this.relevanceScore = data["relevanceScore"];
        }
    }

    static fromJS(data: any): OccupationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OccupationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["title"] = this.title;
        data["relevanceScore"] = this.relevanceScore;
        return data; 
    }

    clone(): OccupationDto {
        const json = this.toJSON();
        let result = new OccupationDto();
        result.init(json);
        return result;
    }
}

export interface IOccupationDto {
    code: string | undefined;
    title: string | undefined;
    relevanceScore: number | undefined;
}

export class WorkContextSummaryDto implements IWorkContextSummaryDto {
    id: string | undefined;
    name: string | undefined;
    description: string | undefined;
    reponses: SummaryReponseDto[] | undefined;

    constructor(data?: IWorkContextSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.description = data["description"];
            if (data["reponses"] && data["reponses"].constructor === Array) {
                this.reponses = [];
                for (let item of data["reponses"])
                    this.reponses.push(SummaryReponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkContextSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkContextSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (this.reponses && this.reponses.constructor === Array) {
            data["reponses"] = [];
            for (let item of this.reponses)
                data["reponses"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WorkContextSummaryDto {
        const json = this.toJSON();
        let result = new WorkContextSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IWorkContextSummaryDto {
    id: string | undefined;
    name: string | undefined;
    description: string | undefined;
    reponses: SummaryReponseDto[] | undefined;
}

export class SummaryReponseDto implements ISummaryReponseDto {
    percentage: number | undefined;
    name: string | undefined;

    constructor(data?: ISummaryReponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.percentage = data["percentage"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SummaryReponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SummaryReponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["percentage"] = this.percentage;
        data["name"] = this.name;
        return data; 
    }

    clone(): SummaryReponseDto {
        const json = this.toJSON();
        let result = new SummaryReponseDto();
        result.init(json);
        return result;
    }
}

export interface ISummaryReponseDto {
    percentage: number | undefined;
    name: string | undefined;
}

export class PositionalToleranceDto implements IPositionalToleranceDto {
    averageTimeTaken: number | undefined;
    result: string | undefined;
    assessmentName: string | undefined;
    jobDemand: string | undefined;
    isDeficit: string | undefined;
    noTrials: number | undefined;

    constructor(data?: IPositionalToleranceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.averageTimeTaken = data["averageTimeTaken"];
            this.result = data["result"];
            this.assessmentName = data["assessmentName"];
            this.jobDemand = data["jobDemand"];
            this.isDeficit = data["isDeficit"];
            this.noTrials = data["noTrials"];
        }
    }

    static fromJS(data: any): PositionalToleranceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionalToleranceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["averageTimeTaken"] = this.averageTimeTaken;
        data["result"] = this.result;
        data["assessmentName"] = this.assessmentName;
        data["jobDemand"] = this.jobDemand;
        data["isDeficit"] = this.isDeficit;
        data["noTrials"] = this.noTrials;
        return data; 
    }

    clone(): PositionalToleranceDto {
        const json = this.toJSON();
        let result = new PositionalToleranceDto();
        result.init(json);
        return result;
    }
}

export interface IPositionalToleranceDto {
    averageTimeTaken: number | undefined;
    result: string | undefined;
    assessmentName: string | undefined;
    jobDemand: string | undefined;
    isDeficit: string | undefined;
    noTrials: number | undefined;
}

export class WeightedProtocolDto implements IWeightedProtocolDto {
    averageTimeTaken: number | undefined;
    result: string | undefined;
    assessmentName: string | undefined;
    jobDemand: string | undefined;
    isDeficit: string | undefined;
    noTrials: number | undefined;

    constructor(data?: IWeightedProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.averageTimeTaken = data["averageTimeTaken"];
            this.result = data["result"];
            this.assessmentName = data["assessmentName"];
            this.jobDemand = data["jobDemand"];
            this.isDeficit = data["isDeficit"];
            this.noTrials = data["noTrials"];
        }
    }

    static fromJS(data: any): WeightedProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeightedProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["averageTimeTaken"] = this.averageTimeTaken;
        data["result"] = this.result;
        data["assessmentName"] = this.assessmentName;
        data["jobDemand"] = this.jobDemand;
        data["isDeficit"] = this.isDeficit;
        data["noTrials"] = this.noTrials;
        return data; 
    }

    clone(): WeightedProtocolDto {
        const json = this.toJSON();
        let result = new WeightedProtocolDto();
        result.init(json);
        return result;
    }
}

export interface IWeightedProtocolDto {
    averageTimeTaken: number | undefined;
    result: string | undefined;
    assessmentName: string | undefined;
    jobDemand: string | undefined;
    isDeficit: string | undefined;
    noTrials: number | undefined;
}

export class RepetitiveToleranceDto implements IRepetitiveToleranceDto {
    averageTimeTaken: number | undefined;
    result: string | undefined;
    assessmentName: string | undefined;
    jobDemand: string | undefined;
    isDeficit: string | undefined;
    noTrials: number | undefined;

    constructor(data?: IRepetitiveToleranceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.averageTimeTaken = data["averageTimeTaken"];
            this.result = data["result"];
            this.assessmentName = data["assessmentName"];
            this.jobDemand = data["jobDemand"];
            this.isDeficit = data["isDeficit"];
            this.noTrials = data["noTrials"];
        }
    }

    static fromJS(data: any): RepetitiveToleranceDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepetitiveToleranceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["averageTimeTaken"] = this.averageTimeTaken;
        data["result"] = this.result;
        data["assessmentName"] = this.assessmentName;
        data["jobDemand"] = this.jobDemand;
        data["isDeficit"] = this.isDeficit;
        data["noTrials"] = this.noTrials;
        return data; 
    }

    clone(): RepetitiveToleranceDto {
        const json = this.toJSON();
        let result = new RepetitiveToleranceDto();
        result.init(json);
        return result;
    }
}

export interface IRepetitiveToleranceDto {
    averageTimeTaken: number | undefined;
    result: string | undefined;
    assessmentName: string | undefined;
    jobDemand: string | undefined;
    isDeficit: string | undefined;
    noTrials: number | undefined;
}

export class WorkAssessmentTasksParentDto implements IWorkAssessmentTasksParentDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    assessmentName: string | undefined;
    taskType: string | undefined;
    chosen: boolean | undefined;
    rating: number | undefined;
    id: string | undefined;

    constructor(data?: IWorkAssessmentTasksParentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.isStopped = data["isStopped"];
            this.comment = data["comment"];
            this.assessmentName = data["assessmentName"];
            this.taskType = data["taskType"];
            this.chosen = data["chosen"];
            this.rating = data["rating"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkAssessmentTasksParentDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkAssessmentTasksParentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["isStopped"] = this.isStopped;
        data["comment"] = this.comment;
        data["assessmentName"] = this.assessmentName;
        data["taskType"] = this.taskType;
        data["chosen"] = this.chosen;
        data["rating"] = this.rating;
        data["id"] = this.id;
        return data; 
    }

    clone(): WorkAssessmentTasksParentDto {
        const json = this.toJSON();
        let result = new WorkAssessmentTasksParentDto();
        result.init(json);
        return result;
    }
}

export interface IWorkAssessmentTasksParentDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isStopped: boolean | undefined;
    comment: string | undefined;
    assessmentName: string | undefined;
    taskType: string | undefined;
    chosen: boolean | undefined;
    rating: number | undefined;
    id: string | undefined;
}

export class WorkInformationDto implements IWorkInformationDto {
    jobTitle: string | undefined;
    jobDescription: string | undefined;
    clientId: string | undefined;
    id: string | undefined;

    constructor(data?: IWorkInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.jobTitle = data["jobTitle"];
            this.jobDescription = data["jobDescription"];
            this.clientId = data["clientId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobTitle"] = this.jobTitle;
        data["jobDescription"] = this.jobDescription;
        data["clientId"] = this.clientId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WorkInformationDto {
        const json = this.toJSON();
        let result = new WorkInformationDto();
        result.init(json);
        return result;
    }
}

export interface IWorkInformationDto {
    jobTitle: string | undefined;
    jobDescription: string | undefined;
    clientId: string | undefined;
    id: string | undefined;
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}