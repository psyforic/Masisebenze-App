/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.7.0 (NJsonSchema v9.13.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class ActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createActivityLog(input: CreateActivityLogInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/CreateActivityLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActivityLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActivityLog(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateActivityLog(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editActivityLog(input: ActivityLogDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/EditActivityLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditActivityLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditActivityLog(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditActivityLog(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<ActivityLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ActivityLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityLogListDto.fromJS(resultData200) : new ActivityLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityLogListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<ActivityLogDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<ActivityLogDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityLogDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<ActivityLogDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityLogDetailOutput.fromJS(resultData200) : new ActivityLogDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityLogDetailOutput>(<any>null);
    }
}

@Injectable()
export class AssessmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createClientAssessment(input: CreateClientAssessmentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateClientAssessment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClientAssessment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClientAssessment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateClientAssessment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getClientAssessment(clientId: string | null | undefined): Observable<ClientAssessmentDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetClientAssessment?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientAssessment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientAssessment(<any>response_);
                } catch (e) {
                    return <Observable<ClientAssessmentDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientAssessmentDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientAssessment(response: HttpResponseBase): Observable<ClientAssessmentDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientAssessmentDetailOutput.fromJS(resultData200) : new ClientAssessmentDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientAssessmentDetailOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getClientAssessments(id: string | null | undefined): Observable<ListResultDtoOfClientAssessmentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetClientAssessments?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientAssessments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientAssessments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfClientAssessmentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfClientAssessmentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientAssessments(response: HttpResponseBase): Observable<ListResultDtoOfClientAssessmentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfClientAssessmentListDto.fromJS(resultData200) : new ListResultDtoOfClientAssessmentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfClientAssessmentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createGripStrength(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateGripStrength?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGripStrength(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGripStrength(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateGripStrength(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateGripStrength(clientId: string | null | undefined, side: number | null | undefined, input: GripStrengthDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdateGripStrength?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGripStrength(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGripStrength(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGripStrength(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getGripStrength(clientId: string | null | undefined, side: number | null | undefined): Observable<GripStrengthDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetGripStrength?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGripStrength(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGripStrength(<any>response_);
                } catch (e) {
                    return <Observable<GripStrengthDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GripStrengthDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGripStrength(response: HttpResponseBase): Observable<GripStrengthDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GripStrengthDetailOutput.fromJS(resultData200) : new GripStrengthDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GripStrengthDetailOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createMusclePower(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateMusclePower?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMusclePower(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMusclePower(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMusclePower(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateMusclePower(clientId: string | null | undefined, input: MusclePowerDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdateMusclePower?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMusclePower(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMusclePower(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMusclePower(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param type (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateMusclePowerOption(clientId: string | null | undefined, type: number | null | undefined, input: MusclePowerOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdateMusclePowerOption?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMusclePowerOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMusclePowerOption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMusclePowerOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param type (optional) 
     * @return Success
     */
    getMusclePowerOption(clientId: string | null | undefined, type: number | null | undefined): Observable<MusclePowerOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetMusclePowerOption?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMusclePowerOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMusclePowerOption(<any>response_);
                } catch (e) {
                    return <Observable<MusclePowerOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MusclePowerOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMusclePowerOption(response: HttpResponseBase): Observable<MusclePowerOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MusclePowerOptionDto.fromJS(resultData200) : new MusclePowerOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MusclePowerOptionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createGait(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateGait?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGait(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGait(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateGait(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateGait(clientId: string | null | undefined, input: GaitDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdateGait?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGait(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGait(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGait(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getGait(clientId: string | null | undefined): Observable<GaitDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetGait?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGait(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGait(<any>response_);
                } catch (e) {
                    return <Observable<GaitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GaitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGait(response: HttpResponseBase): Observable<GaitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GaitDto.fromJS(resultData200) : new GaitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GaitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createPosture(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreatePosture?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePosture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePosture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePosture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param postureOptionId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updatePostureOption(postureOptionId: string | null | undefined, input: PostureOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdatePostureOption?";
        if (postureOptionId !== undefined)
            url_ += "postureOptionId=" + encodeURIComponent("" + postureOptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePostureOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePostureOption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePostureOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getPosture(clientId: string | null | undefined): Observable<ListResultDtoOfPostureOptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetPosture?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosture(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPostureOptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPostureOptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPosture(response: HttpResponseBase): Observable<ListResultDtoOfPostureOptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPostureOptionListDto.fromJS(resultData200) : new ListResultDtoOfPostureOptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPostureOptionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createBorgBalance(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateBorgBalance?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBorgBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBorgBalance(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBorgBalance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param borgBalanceOptionId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateBorgBalanceOption(borgBalanceOptionId: string | null | undefined, input: BorgBalanceOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdateBorgBalanceOption?";
        if (borgBalanceOptionId !== undefined)
            url_ += "borgBalanceOptionId=" + encodeURIComponent("" + borgBalanceOptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBorgBalanceOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBorgBalanceOption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBorgBalanceOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getBorgBalance(clientId: string | null | undefined): Observable<ListResultDtoOfBorgBalanceOptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetBorgBalance?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBorgBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBorgBalance(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBorgBalanceOptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBorgBalanceOptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBorgBalance(response: HttpResponseBase): Observable<ListResultDtoOfBorgBalanceOptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfBorgBalanceOptionListDto.fromJS(resultData200) : new ListResultDtoOfBorgBalanceOptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBorgBalanceOptionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createSensation(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateSensation?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSensation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSensation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSensation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateUpperExtremity(clientId: string | null | undefined, side: number | null | undefined, input: SensationOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdateUpperExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUpperExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUpperExtremity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUpperExtremity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getUpperExtremity(clientId: string | null | undefined, side: number | null | undefined): Observable<ListResultDtoOfSensationOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetUpperExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUpperExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUpperExtremity(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUpperExtremity(response: HttpResponseBase): Observable<ListResultDtoOfSensationOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSensationOptionDto.fromJS(resultData200) : new ListResultDtoOfSensationOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSensationOptionDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateTrunkExtremity(clientId: string | null | undefined, side: number | null | undefined, input: SensationOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdateTrunkExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTrunkExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTrunkExtremity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTrunkExtremity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getTrunkExtremity(clientId: string | null | undefined, side: number | null | undefined): Observable<ListResultDtoOfSensationOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetTrunkExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTrunkExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTrunkExtremity(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTrunkExtremity(response: HttpResponseBase): Observable<ListResultDtoOfSensationOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSensationOptionDto.fromJS(resultData200) : new ListResultDtoOfSensationOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSensationOptionDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateLowerExtremity(clientId: string | null | undefined, side: number | null | undefined, input: SensationOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdateLowerExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLowerExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLowerExtremity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLowerExtremity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getLowerExtremity(clientId: string | null | undefined, side: number | null | undefined): Observable<ListResultDtoOfSensationOptionDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetLowerExtremity?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLowerExtremity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLowerExtremity(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSensationOptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLowerExtremity(response: HttpResponseBase): Observable<ListResultDtoOfSensationOptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSensationOptionDto.fromJS(resultData200) : new ListResultDtoOfSensationOptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSensationOptionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createCoordination(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateCoordination?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCoordination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCoordination(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCoordination(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param coordinationId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateCoordinationOption(coordinationId: string | null | undefined, input: CoordinationOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdateCoordinationOption?";
        if (coordinationId !== undefined)
            url_ += "coordinationId=" + encodeURIComponent("" + coordinationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCoordinationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCoordinationOption(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCoordinationOption(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getCoordination(clientId: string | null | undefined): Observable<ListResultDtoOfCoordinationOptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetCoordination?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoordination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoordination(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCoordinationOptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCoordinationOptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoordination(response: HttpResponseBase): Observable<ListResultDtoOfCoordinationOptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCoordinationOptionListDto.fromJS(resultData200) : new ListResultDtoOfCoordinationOptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCoordinationOptionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    createCoordinationIncomplete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/CreateCoordinationIncomplete?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCoordinationIncomplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCoordinationIncomplete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCoordinationIncomplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateCoordinationIncomplete(clientId: string | null | undefined, input: CoordinationIncompleteDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/UpdateCoordinationIncomplete?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCoordinationIncomplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCoordinationIncomplete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCoordinationIncomplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getCoordinationIncomplete(clientId: string | null | undefined, side: number | null | undefined): Observable<CoordinationIncompleteDto> {
        let url_ = this.baseUrl + "/api/services/app/Assessment/GetCoordinationIncomplete?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoordinationIncomplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoordinationIncomplete(<any>response_);
                } catch (e) {
                    return <Observable<CoordinationIncompleteDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CoordinationIncompleteDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoordinationIncomplete(response: HttpResponseBase): Observable<CoordinationIncompleteDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CoordinationIncompleteDto.fromJS(resultData200) : new CoordinationIncompleteDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CoordinationIncompleteDto>(<any>null);
    }
}

@Injectable()
export class AttorneyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createAttorney(input: CreateAttorneyInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/CreateAttorney";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAttorney(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAttorney(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAttorney(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfAttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAttorneyListDto.fromJS(resultData200) : new PagedResultDtoOfAttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAttorneyListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editAttorney(input: AttorneyDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/EditAttorney";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditAttorney(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditAttorney(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditAttorney(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<AttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<AttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttorneyListDto.fromJS(resultData200) : new AttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttorneyListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<AttorneyDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<AttorneyDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttorneyDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<AttorneyDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttorneyDetailOutput.fromJS(resultData200) : new AttorneyDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttorneyDetailOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<AttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<AttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<AttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttorneyListDto.fromJS(resultData200) : new AttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttorneyListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateAttorneyInput | null | undefined): Observable<AttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttorneyListDto.fromJS(resultData200) : new AttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttorneyListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: AttorneyListDto | null | undefined): Observable<AttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AttorneyListDto.fromJS(resultData200) : new AttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttorneyListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attorney/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BalanceProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    create(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BalanceProtocol/Create?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<ListResultDtoOfBalanceProtocolOptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/BalanceProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBalanceProtocolOptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBalanceProtocolOptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ListResultDtoOfBalanceProtocolOptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfBalanceProtocolOptionListDto.fromJS(resultData200) : new ListResultDtoOfBalanceProtocolOptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBalanceProtocolOptionListDto>(<any>null);
    }

    /**
     * @param balanceProtocolOptionId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(balanceProtocolOptionId: string | null | undefined, input: BalanceProtocolOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BalanceProtocol/Update?";
        if (balanceProtocolOptionId !== undefined)
            url_ += "BalanceProtocolOptionId=" + encodeURIComponent("" + balanceProtocolOptionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BookingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createBooking(input: CreateBookingInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Booking/CreateBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBooking(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBooking(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editBooking(input: BookingDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Booking/EditBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditBooking(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditBooking(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<BookingDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<BookingDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookingDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<BookingDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BookingDetailOutput.fromJS(resultData200) : new BookingDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookingDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<BookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<BookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<BookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BookingListDto.fromJS(resultData200) : new BookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookingListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getBookings(input: any | null | undefined): Observable<ListResultDtoOfBookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetBookings?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBookings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBookings(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBookings(response: HttpResponseBase): Observable<ListResultDtoOfBookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfBookingListDto.fromJS(resultData200) : new ListResultDtoOfBookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBookingListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createEvent(input: CreateEventInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Booking/CreateEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEvent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEvent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getAllEvents(input: any | null | undefined): Observable<ListResultDtoOfEventListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetAllEvents?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEvents(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEventListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEventListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEvents(response: HttpResponseBase): Observable<ListResultDtoOfEventListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEventListDto.fromJS(resultData200) : new ListResultDtoOfEventListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEventListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEventDetail(id: number | null | undefined): Observable<EventDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetEventDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventDetail(<any>response_);
                } catch (e) {
                    return <Observable<EventDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEventDetail(response: HttpResponseBase): Observable<EventDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EventDetailOutput.fromJS(resultData200) : new EventDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getEventById(input: number | null | undefined): Observable<EventListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetEventById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventById(<any>response_);
                } catch (e) {
                    return <Observable<EventListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EventListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEventById(response: HttpResponseBase): Observable<EventListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EventListDto.fromJS(resultData200) : new EventListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EventListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserBookings(id: string | null | undefined): Observable<ListResultDtoOfBookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetUserBookings?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserBookings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserBookings(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserBookings(response: HttpResponseBase): Observable<ListResultDtoOfBookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfBookingListDto.fromJS(resultData200) : new ListResultDtoOfBookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBookingListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<BookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<BookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BookingListDto.fromJS(resultData200) : new BookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookingListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfBookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBookingListDto.fromJS(resultData200) : new PagedResultDtoOfBookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBookingListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateBookingInput | null | undefined): Observable<BookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<BookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BookingListDto.fromJS(resultData200) : new BookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookingListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: BookingListDto | null | undefined): Observable<BookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/Booking/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<BookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<BookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BookingListDto.fromJS(resultData200) : new BookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookingListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Booking/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CalculationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param age (optional) 
     * @param gender (optional) 
     * @param side (optional) 
     * @param weight (optional) 
     * @param machineTest (optional) 
     * @return Success
     */
    getGripStrengthResults(age: number | null | undefined, gender: number | null | undefined, side: number | null | undefined, weight: number | null | undefined, machineTest: number | null | undefined): Observable<AssessmentResult> {
        let url_ = this.baseUrl + "/api/services/app/Calculations/GetGripStrengthResults?";
        if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&"; 
        if (gender !== undefined)
            url_ += "Gender=" + encodeURIComponent("" + gender) + "&"; 
        if (side !== undefined)
            url_ += "Side=" + encodeURIComponent("" + side) + "&"; 
        if (weight !== undefined)
            url_ += "Weight=" + encodeURIComponent("" + weight) + "&"; 
        if (machineTest !== undefined)
            url_ += "MachineTest=" + encodeURIComponent("" + machineTest) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGripStrengthResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGripStrengthResults(<any>response_);
                } catch (e) {
                    return <Observable<AssessmentResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssessmentResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetGripStrengthResults(response: HttpResponseBase): Observable<AssessmentResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssessmentResult.fromJS(resultData200) : new AssessmentResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssessmentResult>(<any>null);
    }

    /**
     * @param seconds (optional) 
     * @param type (optional) 
     * @return Success
     */
    getCoordinationCompleteResults(seconds: number | null | undefined, type: number | null | undefined): Observable<AssessmentResult> {
        let url_ = this.baseUrl + "/api/services/app/Calculations/GetCoordinationCompleteResults?";
        if (seconds !== undefined)
            url_ += "Seconds=" + encodeURIComponent("" + seconds) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoordinationCompleteResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoordinationCompleteResults(<any>response_);
                } catch (e) {
                    return <Observable<AssessmentResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssessmentResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoordinationCompleteResults(response: HttpResponseBase): Observable<AssessmentResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssessmentResult.fromJS(resultData200) : new AssessmentResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssessmentResult>(<any>null);
    }
}

@Injectable()
export class ClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createClient(input: CreateClientInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/CreateClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClient(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateClient(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editClient(input: ClientDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/EditClient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditClient(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditClient(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param url (optional) 
     * @return Success
     */
    updateProfilePic(id: string | null | undefined, url: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/UpdateProfilePic?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (url !== undefined)
            url_ += "url=" + encodeURIComponent("" + url) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePic(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePic(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfClientListDto.fromJS(resultData200) : new PagedResultDtoOfClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfClientListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<ClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientListDto.fromJS(resultData200) : new ClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListDto>(<any>null);
    }

    /**
     * @param attorneyId (optional) 
     * @param contactId (optional) 
     * @return Success
     */
    getByContactAttorneyId(attorneyId: string | null | undefined, contactId: string | null | undefined): Observable<ListResultDtoOfClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetByContactAttorneyId?";
        if (attorneyId !== undefined)
            url_ += "AttorneyId=" + encodeURIComponent("" + attorneyId) + "&"; 
        if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByContactAttorneyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByContactAttorneyId(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByContactAttorneyId(response: HttpResponseBase): Observable<ListResultDtoOfClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfClientListDto.fromJS(resultData200) : new ListResultDtoOfClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfClientListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<ClientDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<ClientDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<ClientDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientDetailOutput.fromJS(resultData200) : new ClientDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createWorkHistory(input: CreateWorkHistoryInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/CreateWorkHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWorkHistory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateWorkHistory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkHistoryDetail(id: string | null | undefined): Observable<WorkHistoryDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetWorkHistoryDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkHistoryDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistoryDetail(<any>response_);
                } catch (e) {
                    return <Observable<WorkHistoryDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkHistoryDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkHistoryDetail(response: HttpResponseBase): Observable<WorkHistoryDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkHistoryDetailOutput.fromJS(resultData200) : new WorkHistoryDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkHistoryDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getWorkHistoryByClientId(input: string | null | undefined): Observable<WorkHistoryListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetWorkHistoryByClientId?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkHistoryByClientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkHistoryByClientId(<any>response_);
                } catch (e) {
                    return <Observable<WorkHistoryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkHistoryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkHistoryByClientId(response: HttpResponseBase): Observable<WorkHistoryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WorkHistoryListDto.fromJS(resultData200) : new WorkHistoryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkHistoryListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editWorkHistory(input: WorkHistoryDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/EditWorkHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditWorkHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditWorkHistory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditWorkHistory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createMedicalHistory(input: CreateMedicalHistoryInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/CreateMedicalHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMedicalHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMedicalHistory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMedicalHistory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMedicalHistoryDetail(id: string | null | undefined): Observable<MedicalHistoryDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetMedicalHistoryDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedicalHistoryDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedicalHistoryDetail(<any>response_);
                } catch (e) {
                    return <Observable<MedicalHistoryDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicalHistoryDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedicalHistoryDetail(response: HttpResponseBase): Observable<MedicalHistoryDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MedicalHistoryDetailOutput.fromJS(resultData200) : new MedicalHistoryDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicalHistoryDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getMedicalHistoryByClientId(input: string | null | undefined): Observable<MedicalHistoryListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetMedicalHistoryByClientId?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMedicalHistoryByClientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMedicalHistoryByClientId(<any>response_);
                } catch (e) {
                    return <Observable<MedicalHistoryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicalHistoryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMedicalHistoryByClientId(response: HttpResponseBase): Observable<MedicalHistoryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MedicalHistoryListDto.fromJS(resultData200) : new MedicalHistoryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicalHistoryListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editMedicalHistory(input: MedicalHistoryDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/EditMedicalHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditMedicalHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditMedicalHistory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditMedicalHistory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<ClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientListDto.fromJS(resultData200) : new ClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateClientInput | null | undefined): Observable<ClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientListDto.fromJS(resultData200) : new ClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: ClientListDto | null | undefined): Observable<ClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientListDto.fromJS(resultData200) : new ClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientListDto>(<any>null);
    }
}

@Injectable()
export class CommentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createComment(input: CreateCommentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comment/CreateComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editComment(input: CommentDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comment/EditComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<CommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentListDto.fromJS(resultData200) : new CommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<CommentDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Comment/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<CommentDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<CommentDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentDetailOutput.fromJS(resultData200) : new CommentDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentDetailOutput>(<any>null);
    }

    /**
     * @param targetId (optional) 
     * @return Success
     */
    getUserComments(targetId: string | null | undefined): Observable<CommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/GetUserComments?";
        if (targetId !== undefined)
            url_ += "TargetId=" + encodeURIComponent("" + targetId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserComments(<any>response_);
                } catch (e) {
                    return <Observable<CommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserComments(response: HttpResponseBase): Observable<CommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentListDto.fromJS(resultData200) : new CommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<CommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentListDto.fromJS(resultData200) : new CommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfCommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCommentListDto.fromJS(resultData200) : new PagedResultDtoOfCommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCommentListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateCommentInput | null | undefined): Observable<CommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentListDto.fromJS(resultData200) : new CommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: CommentListDto | null | undefined): Observable<CommentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CommentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CommentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommentListDto.fromJS(resultData200) : new CommentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Comment/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeUiTheme(input: ChangeUiThemeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createContact(input: CreateContactInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contact/CreateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editContact(input: ContactDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contact/EditContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<ContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactListDto.fromJS(resultData200) : new ContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<ContactDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Contact/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<ContactDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<ContactDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactDetailOutput.fromJS(resultData200) : new ContactDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getByLawFirm(input: string | null | undefined): Observable<ListResultDtoOfContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/GetByLawFirm?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLawFirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLawFirm(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByLawFirm(response: HttpResponseBase): Observable<ListResultDtoOfContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfContactListDto.fromJS(resultData200) : new ListResultDtoOfContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfContactListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<ContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactListDto.fromJS(resultData200) : new ContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfContactListDto.fromJS(resultData200) : new PagedResultDtoOfContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContactListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateContactInput | null | undefined): Observable<ContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactListDto.fromJS(resultData200) : new ContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: ContactListDto | null | undefined): Observable<ContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/Contact/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContactListDto.fromJS(resultData200) : new ContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contact/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CrawlingProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    create(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CrawlingProtocol/Create?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<CrawlingProtocolDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/CrawlingProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CrawlingProtocolDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CrawlingProtocolDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CrawlingProtocolDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CrawlingProtocolDetailOutput.fromJS(resultData200) : new CrawlingProtocolDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CrawlingProtocolDetailOutput>(<any>null);
    }

    /**
     * @param crawlingProtocolId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(crawlingProtocolId: string | null | undefined, input: CrawlingProtocolDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CrawlingProtocol/Update?";
        if (crawlingProtocolId !== undefined)
            url_ += "crawlingProtocolId=" + encodeURIComponent("" + crawlingProtocolId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DashBoardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getLatestActivity(input: any | null | undefined): Observable<ListResultDtoOfBookingListDto> {
        let url_ = this.baseUrl + "/api/services/app/DashBoard/GetLatestActivity?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestActivity(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBookingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestActivity(response: HttpResponseBase): Observable<ListResultDtoOfBookingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfBookingListDto.fromJS(resultData200) : new ListResultDtoOfBookingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBookingListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getNewClients(input: any | null | undefined): Observable<ListResultDtoOfClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/DashBoard/GetNewClients?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewClients(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNewClients(response: HttpResponseBase): Observable<ListResultDtoOfClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfClientListDto.fromJS(resultData200) : new ListResultDtoOfClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfClientListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getNumberFiles(input: any | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/DashBoard/GetNumberFiles?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNumberFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNumberFiles(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetNumberFiles(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class DocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createDocument(input: CreateDocumentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/CreateDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editDocument(input: DocumentDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/EditDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditDocument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getAllUserDocuments(clientId: string | null | undefined): Observable<ListResultDtoOfDocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAllUserDocuments?";
        if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserDocuments(response: HttpResponseBase): Observable<ListResultDtoOfDocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfDocumentListDto.fromJS(resultData200) : new ListResultDtoOfDocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDocumentListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: number | null | undefined): Observable<DocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<DocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentListDto.fromJS(resultData200) : new DocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: number | null | undefined): Observable<DocumentDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<DocumentDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<DocumentDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentDetailOutput.fromJS(resultData200) : new DocumentDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentDetailOutput>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getClientDocuments(clientId: string | null | undefined): Observable<ListResultDtoOfDocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetClientDocuments?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientDocuments(response: HttpResponseBase): Observable<ListResultDtoOfDocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfDocumentListDto.fromJS(resultData200) : new ListResultDtoOfDocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDocumentListDto>(<any>null);
    }

    /**
     * @param documentId (optional) 
     * @return Success
     */
    getChildDocuments(documentId: number | null | undefined): Observable<ListResultDtoOfDocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetChildDocuments?";
        if (documentId !== undefined)
            url_ += "documentId=" + encodeURIComponent("" + documentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetChildDocuments(response: HttpResponseBase): Observable<ListResultDtoOfDocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfDocumentListDto.fromJS(resultData200) : new ListResultDtoOfDocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDocumentListDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getAllChildDocuments(clientId: string | null | undefined): Observable<ListResultDtoOfDocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAllChildDocuments?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChildDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChildDocuments(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChildDocuments(response: HttpResponseBase): Observable<ListResultDtoOfDocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfDocumentListDto.fromJS(resultData200) : new ListResultDtoOfDocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDocumentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<DocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentListDto.fromJS(resultData200) : new DocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDocumentListDto.fromJS(resultData200) : new PagedResultDtoOfDocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDocumentListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateDocumentInput | null | undefined): Observable<DocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentListDto.fromJS(resultData200) : new DocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: DocumentListDto | null | undefined): Observable<DocumentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DocumentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DocumentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentListDto.fromJS(resultData200) : new DocumentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FirebaseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateGripStrength(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Firebase/UpdateGripStrength?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGripStrength(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGripStrength(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGripStrength(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateMusclePower(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Firebase/UpdateMusclePower?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMusclePower(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMusclePower(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMusclePower(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateBorgBalance(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Firebase/UpdateBorgBalance?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBorgBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBorgBalance(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBorgBalance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updatePosture(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Firebase/UpdatePosture?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePosture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePosture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePosture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateSensation(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Firebase/UpdateSensation?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSensation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSensation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSensation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateRangeOfMotion(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Firebase/UpdateRangeOfMotion?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRangeOfMotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRangeOfMotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRangeOfMotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateCoordination(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Firebase/UpdateCoordination?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCoordination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCoordination(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCoordination(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class JobDescriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createJobDescription(input: CreateJobDescriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/CreateJobDescription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateJobDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateJobDescription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateJobDescription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editJobDescription(input: JobDescriptionDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/EditJobDescription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditJobDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditJobDescription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditJobDescription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: number | null | undefined): Observable<JobDescriptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<JobDescriptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDescriptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<JobDescriptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobDescriptionListDto.fromJS(resultData200) : new JobDescriptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDescriptionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: number | null | undefined): Observable<JobDescriptionDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<JobDescriptionDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDescriptionDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<JobDescriptionDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobDescriptionDetailOutput.fromJS(resultData200) : new JobDescriptionDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDescriptionDetailOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<JobDescriptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<JobDescriptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDescriptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<JobDescriptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobDescriptionListDto.fromJS(resultData200) : new JobDescriptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDescriptionListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfJobDescriptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfJobDescriptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfJobDescriptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfJobDescriptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfJobDescriptionListDto.fromJS(resultData200) : new PagedResultDtoOfJobDescriptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfJobDescriptionListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateJobDescriptionInput | null | undefined): Observable<JobDescriptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<JobDescriptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDescriptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<JobDescriptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobDescriptionListDto.fromJS(resultData200) : new JobDescriptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDescriptionListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: JobDescriptionListDto | null | undefined): Observable<JobDescriptionListDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<JobDescriptionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<JobDescriptionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<JobDescriptionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobDescriptionListDto.fromJS(resultData200) : new JobDescriptionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<JobDescriptionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LadderWorkProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    create(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LadderWorkProtocol/Create?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<LadderWorkProtocolDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/LadderWorkProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LadderWorkProtocolDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<LadderWorkProtocolDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LadderWorkProtocolDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LadderWorkProtocolDetailOutput.fromJS(resultData200) : new LadderWorkProtocolDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LadderWorkProtocolDetailOutput>(<any>null);
    }

    /**
     * @param ladderWorkProtocolId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(ladderWorkProtocolId: string | null | undefined, input: LadderWorkProtocolDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LadderWorkProtocol/Update?";
        if (ladderWorkProtocolId !== undefined)
            url_ += "ladderWorkProtocolId=" + encodeURIComponent("" + ladderWorkProtocolId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LawFirmServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createLawFirm(input: CreateLawFirmInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/CreateLawFirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLawFirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLawFirm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLawFirm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    editLawFirm(input: LawFirmDetailOutput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/EditLawFirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditLawFirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditLawFirm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEditLawFirm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getById(input: string | null | undefined): Observable<LawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetById?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<LawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<LawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LawFirmListDto.fromJS(resultData200) : new LawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LawFirmListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetail(id: string | null | undefined): Observable<LawFirmDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetail(<any>response_);
                } catch (e) {
                    return <Observable<LawFirmDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<LawFirmDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetail(response: HttpResponseBase): Observable<LawFirmDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LawFirmDetailOutput.fromJS(resultData200) : new LawFirmDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LawFirmDetailOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getLawFirms(input: any | null | undefined): Observable<ListResultDtoOfLawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetLawFirms?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLawFirms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLawFirms(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLawFirms(response: HttpResponseBase): Observable<ListResultDtoOfLawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLawFirmListDto.fromJS(resultData200) : new ListResultDtoOfLawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLawFirmListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAttorneys(id: string | null | undefined): Observable<ListResultDtoOfAttorneyListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetAttorneys?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttorneys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttorneys(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAttorneyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAttorneyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAttorneys(response: HttpResponseBase): Observable<ListResultDtoOfAttorneyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfAttorneyListDto.fromJS(resultData200) : new ListResultDtoOfAttorneyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAttorneyListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContacts(id: string | null | undefined): Observable<ListResultDtoOfContactListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetContacts?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContacts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfContactListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfContactListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContacts(response: HttpResponseBase): Observable<ListResultDtoOfContactListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfContactListDto.fromJS(resultData200) : new ListResultDtoOfContactListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfContactListDto>(<any>null);
    }

    /**
     * @param lawFirmId (optional) 
     * @return Success
     */
    getClients(lawFirmId: string | null | undefined): Observable<ListResultDtoOfClientListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetClients?";
        if (lawFirmId !== undefined)
            url_ += "LawFirmId=" + encodeURIComponent("" + lawFirmId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClients(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfClientListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClients(response: HttpResponseBase): Observable<ListResultDtoOfClientListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfClientListDto.fromJS(resultData200) : new ListResultDtoOfClientListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfClientListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<LawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LawFirmListDto.fromJS(resultData200) : new LawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LawFirmListDto>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfLawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLawFirmListDto.fromJS(resultData200) : new PagedResultDtoOfLawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLawFirmListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateLawFirmInput | null | undefined): Observable<LawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<LawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LawFirmListDto.fromJS(resultData200) : new LawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LawFirmListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: LawFirmListDto | null | undefined): Observable<LawFirmListDto> {
        let url_ = this.baseUrl + "/api/services/app/LawFirm/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<LawFirmListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LawFirmListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LawFirmListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LawFirmListDto.fromJS(resultData200) : new LawFirmListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LawFirmListDto>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserProfile(): Observable<ProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<ProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<ProfileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfileDto.fromJS(resultData200) : new ProfileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLoggedInUser(id: number | null | undefined): Observable<ProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetLoggedInUser?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoggedInUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoggedInUser(<any>response_);
                } catch (e) {
                    return <Observable<ProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoggedInUser(response: HttpResponseBase): Observable<ProfileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfileDto.fromJS(resultData200) : new ProfileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileDto>(<any>null);
    }
}

@Injectable()
export class RangeOfMotionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createClientRangeOfMotion(input: CreateClientAssessmentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/CreateClientRangeOfMotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClientRangeOfMotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClientRangeOfMotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateClientRangeOfMotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    getClientRangeOfMotion(clientId: string | null | undefined): Observable<RangeOfMotionDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetClientRangeOfMotion?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientRangeOfMotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientRangeOfMotion(<any>response_);
                } catch (e) {
                    return <Observable<RangeOfMotionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RangeOfMotionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientRangeOfMotion(response: HttpResponseBase): Observable<RangeOfMotionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RangeOfMotionDto.fromJS(resultData200) : new RangeOfMotionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RangeOfMotionDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getAnkle(clientId: string | null | undefined, side: number | null | undefined): Observable<AnkleDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetAnkle?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnkle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnkle(<any>response_);
                } catch (e) {
                    return <Observable<AnkleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AnkleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAnkle(response: HttpResponseBase): Observable<AnkleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AnkleDto.fromJS(resultData200) : new AnkleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnkleDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getElbow(clientId: string | null | undefined, side: number | null | undefined): Observable<ElbowDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetElbow?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetElbow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetElbow(<any>response_);
                } catch (e) {
                    return <Observable<ElbowDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ElbowDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetElbow(response: HttpResponseBase): Observable<ElbowDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ElbowDto.fromJS(resultData200) : new ElbowDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ElbowDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getForearmWrist(clientId: string | null | undefined, side: number | null | undefined): Observable<ForearmWristDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetForearmWrist?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForearmWrist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForearmWrist(<any>response_);
                } catch (e) {
                    return <Observable<ForearmWristDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ForearmWristDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForearmWrist(response: HttpResponseBase): Observable<ForearmWristDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ForearmWristDto.fromJS(resultData200) : new ForearmWristDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ForearmWristDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getHip(clientId: string | null | undefined, side: number | null | undefined): Observable<HipDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetHip?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHip(<any>response_);
                } catch (e) {
                    return <Observable<HipDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HipDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHip(response: HttpResponseBase): Observable<HipDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HipDto.fromJS(resultData200) : new HipDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HipDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getKnee(clientId: string | null | undefined, side: number | null | undefined): Observable<KneeDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetKnee?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKnee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKnee(<any>response_);
                } catch (e) {
                    return <Observable<KneeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KneeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetKnee(response: HttpResponseBase): Observable<KneeDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? KneeDto.fromJS(resultData200) : new KneeDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KneeDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getShoulder(clientId: string | null | undefined, side: number | null | undefined): Observable<ShoulderDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetShoulder?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShoulder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShoulder(<any>response_);
                } catch (e) {
                    return <Observable<ShoulderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShoulderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShoulder(response: HttpResponseBase): Observable<ShoulderDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ShoulderDto.fromJS(resultData200) : new ShoulderDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShoulderDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    getHand(clientId: string | null | undefined, side: number | null | undefined): Observable<HandDto> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/GetHand?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHand(<any>response_);
                } catch (e) {
                    return <Observable<HandDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HandDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetHand(response: HttpResponseBase): Observable<HandDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HandDto.fromJS(resultData200) : new HandDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HandDto>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateAnkle(clientId: string | null | undefined, input: AnkleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateAnkle?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAnkle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAnkle(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAnkle(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateElbow(clientId: string | null | undefined, input: ElbowDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateElbow?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateElbow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateElbow(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateElbow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateForearmWrist(clientId: string | null | undefined, input: ForearmWristDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateForearmWrist?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateForearmWrist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateForearmWrist(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateForearmWrist(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateHip(clientId: string | null | undefined, input: HipDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateHip?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHip(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHip(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateKnee(clientId: string | null | undefined, input: KneeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateKnee?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateKnee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateKnee(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateKnee(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateShoulder(clientId: string | null | undefined, input: ShoulderDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateShoulder?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateShoulder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateShoulder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateShoulder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param input (optional) 
     * @return Success
     */
    updateHand(clientId: string | null | undefined, input: HandDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RangeOfMotion/UpdateHand?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHand(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHand(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RepetitiveFootMotionProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    create(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveFootMotionProtocol/Create?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @param side (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined, side: number | null | undefined): Observable<RepetitiveFootMotionProtocolDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveFootMotionProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        if (side !== undefined)
            url_ += "side=" + encodeURIComponent("" + side) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveFootMotionProtocolDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveFootMotionProtocolDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RepetitiveFootMotionProtocolDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveFootMotionProtocolDetailOutput.fromJS(resultData200) : new RepetitiveFootMotionProtocolDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveFootMotionProtocolDetailOutput>(<any>null);
    }

    /**
     * @param repetitiveFootMotionProtocolId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(repetitiveFootMotionProtocolId: string | null | undefined, input: RepetitiveFootMotionProtocolDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveFootMotionProtocol/Update?";
        if (repetitiveFootMotionProtocolId !== undefined)
            url_ += "repetitiveFootMotionProtocolId=" + encodeURIComponent("" + repetitiveFootMotionProtocolId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RepetitiveSquattingProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    create(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveSquattingProtocol/Create?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<RepetitiveSquattingProtocolDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveSquattingProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RepetitiveSquattingProtocolDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RepetitiveSquattingProtocolDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RepetitiveSquattingProtocolDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepetitiveSquattingProtocolDetailOutput.fromJS(resultData200) : new RepetitiveSquattingProtocolDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RepetitiveSquattingProtocolDetailOutput>(<any>null);
    }

    /**
     * @param repetitiveSquattingProtocolId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(repetitiveSquattingProtocolId: string | null | undefined, input: RepetitiveSquattingProtocolDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveSquattingProtocol/Update?";
        if (repetitiveSquattingProtocolId !== undefined)
            url_ += "repetitiveSquattingProtocolId=" + encodeURIComponent("" + repetitiveSquattingProtocolId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RepetitiveToleranceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    updateRepetitiveTolerance(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RepetitiveTolerance/UpdateRepetitiveTolerance?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRepetitiveTolerance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRepetitiveTolerance(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRepetitiveTolerance(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateRoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRolesAsync(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRolesAsync?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolesAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolesAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolesAsync(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: RoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRoleDto.fromJS(resultData200) : new PagedResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRoleDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class StairClimbingProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    create(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StairClimbingProtocol/Create?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<StairClimbingProtocolDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/StairClimbingProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<StairClimbingProtocolDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StairClimbingProtocolDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StairClimbingProtocolDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StairClimbingProtocolDetailOutput.fromJS(resultData200) : new StairClimbingProtocolDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StairClimbingProtocolDetailOutput>(<any>null);
    }

    /**
     * @param stairClimbingProtocolId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(stairClimbingProtocolId: string | null | undefined, input: StairClimbingProtocolDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StairClimbingProtocol/Update?";
        if (stairClimbingProtocolId !== undefined)
            url_ += "stairClimbingProtocolId=" + encodeURIComponent("" + stairClimbingProtocolId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateTenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantDto.fromJS(resultData200) : new PagedResultDtoOfTenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: TenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateUserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: UserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<ListResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleDto.fromJS(resultData200) : new ListResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserDto.fromJS(resultData200) : new PagedResultDtoOfUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDto>(<any>null);
    }
}

@Injectable()
export class WalkingProtocolServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    create(clientId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WalkingProtocol/Create?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param clientId (optional) 
     * @return Success
     */
    get(clientId: string | null | undefined): Observable<WalkingProtocolDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/WalkingProtocol/Get?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WalkingProtocolDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<WalkingProtocolDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WalkingProtocolDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WalkingProtocolDetailOutput.fromJS(resultData200) : new WalkingProtocolDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WalkingProtocolDetailOutput>(<any>null);
    }

    /**
     * @param walkingProtocolId (optional) 
     * @param input (optional) 
     * @return Success
     */
    update(walkingProtocolId: string | null | undefined, input: WalkingProtocolDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WalkingProtocol/Update?";
        if (walkingProtocolId !== undefined)
            url_ += "walkingProtocolId=" + encodeURIComponent("" + walkingProtocolId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class CreateActivityLogInput implements ICreateActivityLogInput {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    targetId: string | undefined;
    targetType: string | undefined;

    constructor(data?: ICreateActivityLogInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.routeUrl = data["routeUrl"];
            this.userId = data["userId"];
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
        }
    }

    static fromJS(data: any): CreateActivityLogInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityLogInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["routeUrl"] = this.routeUrl;
        data["userId"] = this.userId;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        return data; 
    }

    clone(): CreateActivityLogInput {
        const json = this.toJSON();
        let result = new CreateActivityLogInput();
        result.init(json);
        return result;
    }
}

export interface ICreateActivityLogInput {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
}

export class ActivityLogDetailOutput implements IActivityLogDetailOutput {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    user: User | undefined;
    targetId: string | undefined;
    targetType: string | undefined;

    constructor(data?: IActivityLogDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.routeUrl = data["routeUrl"];
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
        }
    }

    static fromJS(data: any): ActivityLogDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["routeUrl"] = this.routeUrl;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        return data; 
    }

    clone(): ActivityLogDetailOutput {
        const json = this.toJSON();
        let result = new ActivityLogDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IActivityLogDetailOutput {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    user: User | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
}

export class User implements IUser {
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User | undefined;
    creatorUser: User | undefined;
    lastModifierUser: User | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number | undefined;
    isLockoutEnabled: boolean | undefined;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean | undefined;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean | undefined;
    isActive: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.normalizedUserName = data["normalizedUserName"];
            this.normalizedEmailAddress = data["normalizedEmailAddress"];
            this.concurrencyStamp = data["concurrencyStamp"];
            if (data["tokens"] && data["tokens"].constructor === Array) {
                this.tokens = [];
                for (let item of data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = data["deleterUser"] ? User.fromJS(data["deleterUser"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = data["lastModifierUser"] ? User.fromJS(data["lastModifierUser"]) : <any>undefined;
            this.authenticationSource = data["authenticationSource"];
            this.userName = data["userName"];
            this.tenantId = data["tenantId"];
            this.emailAddress = data["emailAddress"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.fullName = data["fullName"];
            this.password = data["password"];
            this.emailConfirmationCode = data["emailConfirmationCode"];
            this.passwordResetCode = data["passwordResetCode"];
            this.lockoutEndDateUtc = data["lockoutEndDateUtc"] ? moment(data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = data["accessFailedCount"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.securityStamp = data["securityStamp"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            if (data["logins"] && data["logins"].constructor === Array) {
                this.logins = [];
                for (let item of data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (data["claims"] && data["claims"].constructor === Array) {
                this.claims = [];
                for (let item of data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (data["settings"] && data["settings"].constructor === Array) {
                this.settings = [];
                for (let item of data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.isActive = data["isActive"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (this.tokens && this.tokens.constructor === Array) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (this.logins && this.logins.constructor === Array) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.claims && this.claims.constructor === Array) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.settings && this.settings.constructor === Array) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User | undefined;
    creatorUser: User | undefined;
    lastModifierUser: User | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number | undefined;
    isLockoutEnabled: boolean | undefined;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean | undefined;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean | undefined;
    isActive: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserToken implements IUserToken {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.name = data["name"];
            this.value = data["value"];
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number | undefined;
}

export class UserLogin implements IUserLogin {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string;
    providerKey: string;
    id: number | undefined;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.providerKey = data["providerKey"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string;
    providerKey: string;
    id: number | undefined;
}

export class UserRole implements IUserRole {
    tenantId: number | undefined;
    userId: number | undefined;
    roleId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.roleId = data["roleId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number | undefined;
    roleId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserClaim implements IUserClaim {
    tenantId: number | undefined;
    userId: number | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.claimType = data["claimType"];
            this.claimValue = data["claimValue"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.isGranted = data["isGranted"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    userId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Setting implements ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.value = data["value"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ActivityLogListDto implements IActivityLogListDto {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    user: User | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IActivityLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.routeUrl = data["routeUrl"];
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["routeUrl"] = this.routeUrl;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityLogListDto {
        const json = this.toJSON();
        let result = new ActivityLogListDto();
        result.init(json);
        return result;
    }
}

export interface IActivityLogListDto {
    description: string | undefined;
    routeUrl: string | undefined;
    userId: number | undefined;
    user: User | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateClientAssessmentInput implements ICreateClientAssessmentInput {
    clientId: string | undefined;
    userId: number | undefined;

    constructor(data?: ICreateClientAssessmentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): CreateClientAssessmentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientAssessmentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): CreateClientAssessmentInput {
        const json = this.toJSON();
        let result = new CreateClientAssessmentInput();
        result.init(json);
        return result;
    }
}

export interface ICreateClientAssessmentInput {
    clientId: string | undefined;
    userId: number | undefined;
}

export class ClientAssessmentDetailOutput implements IClientAssessmentDetailOutput {
    clientId: string | undefined;
    userId: number | undefined;

    constructor(data?: IClientAssessmentDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ClientAssessmentDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAssessmentDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): ClientAssessmentDetailOutput {
        const json = this.toJSON();
        let result = new ClientAssessmentDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IClientAssessmentDetailOutput {
    clientId: string | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfClientAssessmentListDto implements IListResultDtoOfClientAssessmentListDto {
    items: ClientAssessmentListDto[] | undefined;

    constructor(data?: IListResultDtoOfClientAssessmentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ClientAssessmentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfClientAssessmentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfClientAssessmentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfClientAssessmentListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfClientAssessmentListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfClientAssessmentListDto {
    items: ClientAssessmentListDto[] | undefined;
}

export class ClientAssessmentListDto implements IClientAssessmentListDto {
    name: string | undefined;
    category: AssessmentCategory | undefined;
    painCommentId: string | undefined;
    painComment: PainComment | undefined;
    client: Client | undefined;
    side: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IClientAssessmentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.category = data["category"] ? AssessmentCategory.fromJS(data["category"]) : <any>undefined;
            this.painCommentId = data["painCommentId"];
            this.painComment = data["painComment"] ? PainComment.fromJS(data["painComment"]) : <any>undefined;
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.side = data["side"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ClientAssessmentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientAssessmentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["painCommentId"] = this.painCommentId;
        data["painComment"] = this.painComment ? this.painComment.toJSON() : <any>undefined;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["side"] = this.side;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientAssessmentListDto {
        const json = this.toJSON();
        let result = new ClientAssessmentListDto();
        result.init(json);
        return result;
    }
}

export interface IClientAssessmentListDto {
    name: string | undefined;
    category: AssessmentCategory | undefined;
    painCommentId: string | undefined;
    painComment: PainComment | undefined;
    client: Client | undefined;
    side: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class AssessmentCategory implements IAssessmentCategory {
    name: string | undefined;
    assessments: Assessment[] | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAssessmentCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["assessments"] && data["assessments"].constructor === Array) {
                this.assessments = [];
                for (let item of data["assessments"])
                    this.assessments.push(Assessment.fromJS(item));
            }
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssessmentCategory {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.assessments && this.assessments.constructor === Array) {
            data["assessments"] = [];
            for (let item of this.assessments)
                data["assessments"].push(item.toJSON());
        }
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AssessmentCategory {
        const json = this.toJSON();
        let result = new AssessmentCategory();
        result.init(json);
        return result;
    }
}

export interface IAssessmentCategory {
    name: string | undefined;
    assessments: Assessment[] | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PainComment implements IPainComment {
    painLevel: number | undefined;
    comment: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPainComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PainComment {
        data = typeof data === 'object' ? data : {};
        let result = new PainComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PainComment {
        const json = this.toJSON();
        let result = new PainComment();
        result.init(json);
        return result;
    }
}

export interface IPainComment {
    painLevel: number | undefined;
    comment: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Client implements IClient {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: number | undefined;
    dob: moment.Moment | undefined;
    addressId: number | undefined;
    dateOfInjury: moment.Moment | undefined;
    address: Address | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IClient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.attorneyId = data["attorneyId"];
            this.attorney = data["attorney"] ? Attorney.fromJS(data["attorney"]) : <any>undefined;
            this.courtDate = data["courtDate"] ? moment(data["courtDate"].toString()) : <any>undefined;
            this.caseNumber = data["caseNumber"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.title = data["title"];
            this.idNumber = data["idNumber"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.addressId = data["addressId"];
            this.dateOfInjury = data["dateOfInjury"] ? moment(data["dateOfInjury"].toString()) : <any>undefined;
            this.address = data["address"] ? Address.fromJS(data["address"]) : <any>undefined;
            this.assessmentDate = data["assessmentDate"] ? moment(data["assessmentDate"].toString()) : <any>undefined;
            this.earlyChildhood = data["earlyChildhood"];
            this.family = data["family"];
            this.homeEnvironment = data["homeEnvironment"];
            this.education = data["education"];
            this.socialHabits = data["socialHabits"];
            this.currentComplaints = data["currentComplaints"];
            this.profilePictureId = data["profilePictureId"];
            this.affect = data["affect"];
            this.jobDescription = data["jobDescription"];
            this.motivation = data["motivation"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Client {
        data = typeof data === 'object' ? data : {};
        let result = new Client();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["attorneyId"] = this.attorneyId;
        data["attorney"] = this.attorney ? this.attorney.toJSON() : <any>undefined;
        data["courtDate"] = this.courtDate ? this.courtDate.toISOString() : <any>undefined;
        data["caseNumber"] = this.caseNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["title"] = this.title;
        data["idNumber"] = this.idNumber;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        data["dateOfInjury"] = this.dateOfInjury ? this.dateOfInjury.toISOString() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["assessmentDate"] = this.assessmentDate ? this.assessmentDate.toISOString() : <any>undefined;
        data["earlyChildhood"] = this.earlyChildhood;
        data["family"] = this.family;
        data["homeEnvironment"] = this.homeEnvironment;
        data["education"] = this.education;
        data["socialHabits"] = this.socialHabits;
        data["currentComplaints"] = this.currentComplaints;
        data["profilePictureId"] = this.profilePictureId;
        data["affect"] = this.affect;
        data["jobDescription"] = this.jobDescription;
        data["motivation"] = this.motivation;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Client {
        const json = this.toJSON();
        let result = new Client();
        result.init(json);
        return result;
    }
}

export interface IClient {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: number | undefined;
    dob: moment.Moment | undefined;
    addressId: number | undefined;
    dateOfInjury: moment.Moment | undefined;
    address: Address | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Assessment implements IAssessment {
    name: string | undefined;
    categoryId: string | undefined;
    category: AssessmentCategory | undefined;
    clientId: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAssessment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.categoryId = data["categoryId"];
            this.category = data["category"] ? AssessmentCategory.fromJS(data["category"]) : <any>undefined;
            this.clientId = data["clientId"];
            this.side = data["side"];
            this.chosen = data["chosen"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Assessment {
        data = typeof data === 'object' ? data : {};
        let result = new Assessment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["clientId"] = this.clientId;
        data["side"] = this.side;
        data["chosen"] = this.chosen;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Assessment {
        const json = this.toJSON();
        let result = new Assessment();
        result.init(json);
        return result;
    }
}

export interface IAssessment {
    name: string | undefined;
    categoryId: string | undefined;
    category: AssessmentCategory | undefined;
    clientId: string | undefined;
    side: number | undefined;
    chosen: boolean | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class LawFirm implements ILawFirm {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: Address | undefined;
    postalAddressId: number | undefined;
    postalAddress: Address | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    contacts: Contact[] | undefined;
    attorneys: Attorney[] | undefined;
    clients: Client[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILawFirm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.physicalAddressId = data["physicalAddressId"];
            this.physicalAddress = data["physicalAddress"] ? Address.fromJS(data["physicalAddress"]) : <any>undefined;
            this.postalAddressId = data["postalAddressId"];
            this.postalAddress = data["postalAddress"] ? Address.fromJS(data["postalAddress"]) : <any>undefined;
            this.email = data["email"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            if (data["contacts"] && data["contacts"].constructor === Array) {
                this.contacts = [];
                for (let item of data["contacts"])
                    this.contacts.push(Contact.fromJS(item));
            }
            if (data["attorneys"] && data["attorneys"].constructor === Array) {
                this.attorneys = [];
                for (let item of data["attorneys"])
                    this.attorneys.push(Attorney.fromJS(item));
            }
            if (data["clients"] && data["clients"].constructor === Array) {
                this.clients = [];
                for (let item of data["clients"])
                    this.clients.push(Client.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LawFirm {
        data = typeof data === 'object' ? data : {};
        let result = new LawFirm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["physicalAddressId"] = this.physicalAddressId;
        data["physicalAddress"] = this.physicalAddress ? this.physicalAddress.toJSON() : <any>undefined;
        data["postalAddressId"] = this.postalAddressId;
        data["postalAddress"] = this.postalAddress ? this.postalAddress.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        if (this.contacts && this.contacts.constructor === Array) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        if (this.attorneys && this.attorneys.constructor === Array) {
            data["attorneys"] = [];
            for (let item of this.attorneys)
                data["attorneys"].push(item.toJSON());
        }
        if (this.clients && this.clients.constructor === Array) {
            data["clients"] = [];
            for (let item of this.clients)
                data["clients"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LawFirm {
        const json = this.toJSON();
        let result = new LawFirm();
        result.init(json);
        return result;
    }
}

export interface ILawFirm {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: Address | undefined;
    postalAddressId: number | undefined;
    postalAddress: Address | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    contacts: Contact[] | undefined;
    attorneys: Attorney[] | undefined;
    clients: Client[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Contact implements IContact {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.role = data["role"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["role"] = this.role;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Contact {
        const json = this.toJSON();
        let result = new Contact();
        result.init(json);
        return result;
    }
}

export interface IContact {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Attorney implements IAttorney {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    clients: Client[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAttorney) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cellphone = data["cellphone"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.fax = data["fax"];
            if (data["clients"] && data["clients"].constructor === Array) {
                this.clients = [];
                for (let item of data["clients"])
                    this.clients.push(Client.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Attorney {
        data = typeof data === 'object' ? data : {};
        let result = new Attorney();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cellphone"] = this.cellphone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fax"] = this.fax;
        if (this.clients && this.clients.constructor === Array) {
            data["clients"] = [];
            for (let item of this.clients)
                data["clients"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Attorney {
        const json = this.toJSON();
        let result = new Attorney();
        result.init(json);
        return result;
    }
}

export interface IAttorney {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    clients: Client[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Address implements IAddress {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;
    id: number | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.city = data["city"];
            this.postalCode = data["postalCode"];
            this.province = data["province"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["province"] = this.province;
        data["id"] = this.id;
        return data; 
    }

    clone(): Address {
        const json = this.toJSON();
        let result = new Address();
        result.init(json);
        return result;
    }
}

export interface IAddress {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;
    id: number | undefined;
}

export class GripStrengthDto implements IGripStrengthDto {
    age: number | undefined;
    weight: number | undefined;
    gender: number | undefined;
    machineTest: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IGripStrengthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.age = data["age"];
            this.weight = data["weight"];
            this.gender = data["gender"];
            this.machineTest = data["machineTest"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.side = data["side"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GripStrengthDto {
        data = typeof data === 'object' ? data : {};
        let result = new GripStrengthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["age"] = this.age;
        data["weight"] = this.weight;
        data["gender"] = this.gender;
        data["machineTest"] = this.machineTest;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["side"] = this.side;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): GripStrengthDto {
        const json = this.toJSON();
        let result = new GripStrengthDto();
        result.init(json);
        return result;
    }
}

export interface IGripStrengthDto {
    age: number | undefined;
    weight: number | undefined;
    gender: number | undefined;
    machineTest: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class GripStrengthDetailOutput implements IGripStrengthDetailOutput {
    assessment: Assessment | undefined;
    age: number | undefined;
    weight: number | undefined;
    gender: number | undefined;
    machineTest: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IGripStrengthDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.age = data["age"];
            this.weight = data["weight"];
            this.gender = data["gender"];
            this.machineTest = data["machineTest"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.side = data["side"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GripStrengthDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GripStrengthDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["age"] = this.age;
        data["weight"] = this.weight;
        data["gender"] = this.gender;
        data["machineTest"] = this.machineTest;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["side"] = this.side;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): GripStrengthDetailOutput {
        const json = this.toJSON();
        let result = new GripStrengthDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IGripStrengthDetailOutput {
    assessment: Assessment | undefined;
    age: number | undefined;
    weight: number | undefined;
    gender: number | undefined;
    machineTest: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class MusclePowerDto implements IMusclePowerDto {
    leftArmResult: number | undefined;
    rightArmResult: number | undefined;
    leftLegResult: number | undefined;
    rightLegResult: number | undefined;
    leftPainLevel: number | undefined;
    rightPainLevel: number | undefined;
    leftSideComment: string | undefined;
    rightSideComment: string | undefined;
    type: number | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IMusclePowerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leftArmResult = data["leftArmResult"];
            this.rightArmResult = data["rightArmResult"];
            this.leftLegResult = data["leftLegResult"];
            this.rightLegResult = data["rightLegResult"];
            this.leftPainLevel = data["leftPainLevel"];
            this.rightPainLevel = data["rightPainLevel"];
            this.leftSideComment = data["leftSideComment"];
            this.rightSideComment = data["rightSideComment"];
            this.type = data["type"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MusclePowerDto {
        data = typeof data === 'object' ? data : {};
        let result = new MusclePowerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leftArmResult"] = this.leftArmResult;
        data["rightArmResult"] = this.rightArmResult;
        data["leftLegResult"] = this.leftLegResult;
        data["rightLegResult"] = this.rightLegResult;
        data["leftPainLevel"] = this.leftPainLevel;
        data["rightPainLevel"] = this.rightPainLevel;
        data["leftSideComment"] = this.leftSideComment;
        data["rightSideComment"] = this.rightSideComment;
        data["type"] = this.type;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): MusclePowerDto {
        const json = this.toJSON();
        let result = new MusclePowerDto();
        result.init(json);
        return result;
    }
}

export interface IMusclePowerDto {
    leftArmResult: number | undefined;
    rightArmResult: number | undefined;
    leftLegResult: number | undefined;
    rightLegResult: number | undefined;
    leftPainLevel: number | undefined;
    rightPainLevel: number | undefined;
    leftSideComment: string | undefined;
    rightSideComment: string | undefined;
    type: number | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class MusclePowerOptionDto implements IMusclePowerOptionDto {
    name: string | undefined;
    optionResult: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    musclePowerId: string | undefined;
    comment: string | undefined;
    type: number | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IMusclePowerOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.optionResult = data["optionResult"];
            this.side = data["side"];
            this.painLevel = data["painLevel"];
            this.musclePowerId = data["musclePowerId"];
            this.comment = data["comment"];
            this.type = data["type"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MusclePowerOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MusclePowerOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["optionResult"] = this.optionResult;
        data["side"] = this.side;
        data["painLevel"] = this.painLevel;
        data["musclePowerId"] = this.musclePowerId;
        data["comment"] = this.comment;
        data["type"] = this.type;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): MusclePowerOptionDto {
        const json = this.toJSON();
        let result = new MusclePowerOptionDto();
        result.init(json);
        return result;
    }
}

export interface IMusclePowerOptionDto {
    name: string | undefined;
    optionResult: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    musclePowerId: string | undefined;
    comment: string | undefined;
    type: number | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class GaitDto implements IGaitDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    timeRecorded: number | undefined;
    walkingTime: string | undefined;
    painLevel: string | undefined;
    comment: string | undefined;
    videoUrl: string | undefined;
    otObservationComments: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGaitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.timeRecorded = data["timeRecorded"];
            this.walkingTime = data["walkingTime"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.videoUrl = data["videoUrl"];
            this.otObservationComments = data["otObservationComments"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GaitDto {
        data = typeof data === 'object' ? data : {};
        let result = new GaitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["timeRecorded"] = this.timeRecorded;
        data["walkingTime"] = this.walkingTime;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["videoUrl"] = this.videoUrl;
        data["otObservationComments"] = this.otObservationComments;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GaitDto {
        const json = this.toJSON();
        let result = new GaitDto();
        result.init(json);
        return result;
    }
}

export interface IGaitDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    timeRecorded: number | undefined;
    walkingTime: string | undefined;
    painLevel: string | undefined;
    comment: string | undefined;
    videoUrl: string | undefined;
    otObservationComments: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PostureOptionDto implements IPostureOptionDto {
    name: string | undefined;
    postureOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IPostureOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.postureOptionScore = data["postureOptionScore"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PostureOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostureOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["postureOptionScore"] = this.postureOptionScore;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): PostureOptionDto {
        const json = this.toJSON();
        let result = new PostureOptionDto();
        result.init(json);
        return result;
    }
}

export interface IPostureOptionDto {
    name: string | undefined;
    postureOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfPostureOptionListDto implements IListResultDtoOfPostureOptionListDto {
    items: PostureOptionListDto[] | undefined;

    constructor(data?: IListResultDtoOfPostureOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PostureOptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPostureOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPostureOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfPostureOptionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfPostureOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPostureOptionListDto {
    items: PostureOptionListDto[] | undefined;
}

export class PostureOptionListDto implements IPostureOptionListDto {
    name: string | undefined;
    postureId: string | undefined;
    postureOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IPostureOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.postureId = data["postureId"];
            this.postureOptionScore = data["postureOptionScore"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PostureOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostureOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["postureId"] = this.postureId;
        data["postureOptionScore"] = this.postureOptionScore;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): PostureOptionListDto {
        const json = this.toJSON();
        let result = new PostureOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IPostureOptionListDto {
    name: string | undefined;
    postureId: string | undefined;
    postureOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class BorgBalanceOptionDto implements IBorgBalanceOptionDto {
    name: string | undefined;
    borgBalanceId: string | undefined;
    borgBalanceOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;

    constructor(data?: IBorgBalanceOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.borgBalanceId = data["borgBalanceId"];
            this.borgBalanceOptionScore = data["borgBalanceOptionScore"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): BorgBalanceOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorgBalanceOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["borgBalanceId"] = this.borgBalanceId;
        data["borgBalanceOptionScore"] = this.borgBalanceOptionScore;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["status"] = this.status;
        return data; 
    }

    clone(): BorgBalanceOptionDto {
        const json = this.toJSON();
        let result = new BorgBalanceOptionDto();
        result.init(json);
        return result;
    }
}

export interface IBorgBalanceOptionDto {
    name: string | undefined;
    borgBalanceId: string | undefined;
    borgBalanceOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
}

export class ListResultDtoOfBorgBalanceOptionListDto implements IListResultDtoOfBorgBalanceOptionListDto {
    items: BorgBalanceOptionListDto[] | undefined;

    constructor(data?: IListResultDtoOfBorgBalanceOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BorgBalanceOptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfBorgBalanceOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfBorgBalanceOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfBorgBalanceOptionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfBorgBalanceOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfBorgBalanceOptionListDto {
    items: BorgBalanceOptionListDto[] | undefined;
}

export class BorgBalanceOptionListDto implements IBorgBalanceOptionListDto {
    name: string | undefined;
    borgBalanceId: string | undefined;
    borgBalanceOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: IBorgBalanceOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.borgBalanceId = data["borgBalanceId"];
            this.borgBalanceOptionScore = data["borgBalanceOptionScore"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BorgBalanceOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorgBalanceOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["borgBalanceId"] = this.borgBalanceId;
        data["borgBalanceOptionScore"] = this.borgBalanceOptionScore;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): BorgBalanceOptionListDto {
        const json = this.toJSON();
        let result = new BorgBalanceOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IBorgBalanceOptionListDto {
    name: string | undefined;
    borgBalanceId: string | undefined;
    borgBalanceOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class SensationOptionDto implements ISensationOptionDto {
    name: string | undefined;
    sensationCategoryId: string | undefined;
    sensationOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    status: number | undefined;
    id: string | undefined;

    constructor(data?: ISensationOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.sensationCategoryId = data["sensationCategoryId"];
            this.sensationOptionScore = data["sensationOptionScore"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.side = data["side"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SensationOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensationOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sensationCategoryId"] = this.sensationCategoryId;
        data["sensationOptionScore"] = this.sensationOptionScore;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["side"] = this.side;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): SensationOptionDto {
        const json = this.toJSON();
        let result = new SensationOptionDto();
        result.init(json);
        return result;
    }
}

export interface ISensationOptionDto {
    name: string | undefined;
    sensationCategoryId: string | undefined;
    sensationOptionScore: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    side: number | undefined;
    status: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfSensationOptionDto implements IListResultDtoOfSensationOptionDto {
    items: SensationOptionDto[] | undefined;

    constructor(data?: IListResultDtoOfSensationOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SensationOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSensationOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSensationOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfSensationOptionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfSensationOptionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfSensationOptionDto {
    items: SensationOptionDto[] | undefined;
}

export class CoordinationOptionDto implements ICoordinationOptionDto {
    index: number | undefined;
    name: string | undefined;
    coordinationId: string | undefined;
    time: number | undefined;
    workRate: number | undefined;
    result: string | undefined;
    numPieces: number | undefined;
    status: number | undefined;
    comment: string | undefined;
    id: string | undefined;

    constructor(data?: ICoordinationOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.index = data["index"];
            this.name = data["name"];
            this.coordinationId = data["coordinationId"];
            this.time = data["time"];
            this.workRate = data["workRate"];
            this.result = data["result"];
            this.numPieces = data["numPieces"];
            this.status = data["status"];
            this.comment = data["comment"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CoordinationOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinationOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["name"] = this.name;
        data["coordinationId"] = this.coordinationId;
        data["time"] = this.time;
        data["workRate"] = this.workRate;
        data["result"] = this.result;
        data["numPieces"] = this.numPieces;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["id"] = this.id;
        return data; 
    }

    clone(): CoordinationOptionDto {
        const json = this.toJSON();
        let result = new CoordinationOptionDto();
        result.init(json);
        return result;
    }
}

export interface ICoordinationOptionDto {
    index: number | undefined;
    name: string | undefined;
    coordinationId: string | undefined;
    time: number | undefined;
    workRate: number | undefined;
    result: string | undefined;
    numPieces: number | undefined;
    status: number | undefined;
    comment: string | undefined;
    id: string | undefined;
}

export class ListResultDtoOfCoordinationOptionListDto implements IListResultDtoOfCoordinationOptionListDto {
    items: CoordinationOptionListDto[] | undefined;

    constructor(data?: IListResultDtoOfCoordinationOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CoordinationOptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCoordinationOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCoordinationOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfCoordinationOptionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfCoordinationOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfCoordinationOptionListDto {
    items: CoordinationOptionListDto[] | undefined;
}

export class CoordinationOptionListDto implements ICoordinationOptionListDto {
    index: number | undefined;
    name: string | undefined;
    coordinationId: string | undefined;
    time: number | undefined;
    workRate: number | undefined;
    result: string | undefined;
    numPieces: number | undefined;
    status: number | undefined;
    comment: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICoordinationOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.index = data["index"];
            this.name = data["name"];
            this.coordinationId = data["coordinationId"];
            this.time = data["time"];
            this.workRate = data["workRate"];
            this.result = data["result"];
            this.numPieces = data["numPieces"];
            this.status = data["status"];
            this.comment = data["comment"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CoordinationOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinationOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["name"] = this.name;
        data["coordinationId"] = this.coordinationId;
        data["time"] = this.time;
        data["workRate"] = this.workRate;
        data["result"] = this.result;
        data["numPieces"] = this.numPieces;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CoordinationOptionListDto {
        const json = this.toJSON();
        let result = new CoordinationOptionListDto();
        result.init(json);
        return result;
    }
}

export interface ICoordinationOptionListDto {
    index: number | undefined;
    name: string | undefined;
    coordinationId: string | undefined;
    time: number | undefined;
    workRate: number | undefined;
    result: string | undefined;
    numPieces: number | undefined;
    status: number | undefined;
    comment: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CoordinationIncompleteDto implements ICoordinationIncompleteDto {
    clientId: string | undefined;
    completedPieces: number | undefined;
    timeTaken: number | undefined;
    holeType: number | undefined;
    mtm: number | undefined;
    status: number | undefined;
    side: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICoordinationIncompleteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.completedPieces = data["completedPieces"];
            this.timeTaken = data["timeTaken"];
            this.holeType = data["holeType"];
            this.mtm = data["mtm"];
            this.status = data["status"];
            this.side = data["side"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CoordinationIncompleteDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinationIncompleteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["completedPieces"] = this.completedPieces;
        data["timeTaken"] = this.timeTaken;
        data["holeType"] = this.holeType;
        data["mtm"] = this.mtm;
        data["status"] = this.status;
        data["side"] = this.side;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CoordinationIncompleteDto {
        const json = this.toJSON();
        let result = new CoordinationIncompleteDto();
        result.init(json);
        return result;
    }
}

export interface ICoordinationIncompleteDto {
    clientId: string | undefined;
    completedPieces: number | undefined;
    timeTaken: number | undefined;
    holeType: number | undefined;
    mtm: number | undefined;
    status: number | undefined;
    side: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateAttorneyInput implements ICreateAttorneyInput {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;

    constructor(data?: ICreateAttorneyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cellphone = data["cellphone"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.fax = data["fax"];
        }
    }

    static fromJS(data: any): CreateAttorneyInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAttorneyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cellphone"] = this.cellphone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fax"] = this.fax;
        return data; 
    }

    clone(): CreateAttorneyInput {
        const json = this.toJSON();
        let result = new CreateAttorneyInput();
        result.init(json);
        return result;
    }
}

export interface ICreateAttorneyInput {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
}

export class PagedResultDtoOfAttorneyListDto implements IPagedResultDtoOfAttorneyListDto {
    totalCount: number | undefined;
    items: AttorneyListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAttorneyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AttorneyListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAttorneyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAttorneyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAttorneyListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAttorneyListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAttorneyListDto {
    totalCount: number | undefined;
    items: AttorneyListDto[] | undefined;
}

export class AttorneyListDto implements IAttorneyListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAttorneyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cellphone = data["cellphone"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.fax = data["fax"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AttorneyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttorneyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cellphone"] = this.cellphone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fax"] = this.fax;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AttorneyListDto {
        const json = this.toJSON();
        let result = new AttorneyListDto();
        result.init(json);
        return result;
    }
}

export interface IAttorneyListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class AttorneyDetailOutput implements IAttorneyDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAttorneyDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cellphone = data["cellphone"];
            this.phone = data["phone"];
            this.email = data["email"];
            this.fax = data["fax"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AttorneyDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AttorneyDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cellphone"] = this.cellphone;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["fax"] = this.fax;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AttorneyDetailOutput {
        const json = this.toJSON();
        let result = new AttorneyDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IAttorneyDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellphone: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfBalanceProtocolOptionListDto implements IListResultDtoOfBalanceProtocolOptionListDto {
    items: BalanceProtocolOptionListDto[] | undefined;

    constructor(data?: IListResultDtoOfBalanceProtocolOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BalanceProtocolOptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfBalanceProtocolOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfBalanceProtocolOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfBalanceProtocolOptionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfBalanceProtocolOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfBalanceProtocolOptionListDto {
    items: BalanceProtocolOptionListDto[] | undefined;
}

export class BalanceProtocolOptionListDto implements IBalanceProtocolOptionListDto {
    balanceProtocolId: string | undefined;
    direction: string | undefined;
    timeTaken: number | undefined;
    numErrors: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBalanceProtocolOptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.balanceProtocolId = data["balanceProtocolId"];
            this.direction = data["direction"];
            this.timeTaken = data["timeTaken"];
            this.numErrors = data["numErrors"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BalanceProtocolOptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceProtocolOptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balanceProtocolId"] = this.balanceProtocolId;
        data["direction"] = this.direction;
        data["timeTaken"] = this.timeTaken;
        data["numErrors"] = this.numErrors;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BalanceProtocolOptionListDto {
        const json = this.toJSON();
        let result = new BalanceProtocolOptionListDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceProtocolOptionListDto {
    balanceProtocolId: string | undefined;
    direction: string | undefined;
    timeTaken: number | undefined;
    numErrors: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class BalanceProtocolOptionDto implements IBalanceProtocolOptionDto {
    direction: string | undefined;
    timeTaken: number | undefined;
    numErrors: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBalanceProtocolOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.direction = data["direction"];
            this.timeTaken = data["timeTaken"];
            this.numErrors = data["numErrors"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BalanceProtocolOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceProtocolOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["direction"] = this.direction;
        data["timeTaken"] = this.timeTaken;
        data["numErrors"] = this.numErrors;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BalanceProtocolOptionDto {
        const json = this.toJSON();
        let result = new BalanceProtocolOptionDto();
        result.init(json);
        return result;
    }
}

export interface IBalanceProtocolOptionDto {
    direction: string | undefined;
    timeTaken: number | undefined;
    numErrors: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateBookingInput implements ICreateBookingInput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    userId: number | undefined;
    lawFirmId: string | undefined;
    eventId: number | undefined;
    attorneyId: string | undefined;
    contactId: string | undefined;
    reason: string | undefined;

    constructor(data?: ICreateBookingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.userId = data["userId"];
            this.lawFirmId = data["lawFirmId"];
            this.eventId = data["eventId"];
            this.attorneyId = data["attorneyId"];
            this.contactId = data["contactId"];
            this.reason = data["reason"];
        }
    }

    static fromJS(data: any): CreateBookingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBookingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["userId"] = this.userId;
        data["lawFirmId"] = this.lawFirmId;
        data["eventId"] = this.eventId;
        data["attorneyId"] = this.attorneyId;
        data["contactId"] = this.contactId;
        data["reason"] = this.reason;
        return data; 
    }

    clone(): CreateBookingInput {
        const json = this.toJSON();
        let result = new CreateBookingInput();
        result.init(json);
        return result;
    }
}

export interface ICreateBookingInput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    userId: number | undefined;
    lawFirmId: string | undefined;
    eventId: number | undefined;
    attorneyId: string | undefined;
    contactId: string | undefined;
    reason: string | undefined;
}

export class BookingDetailOutput implements IBookingDetailOutput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    userId: number | undefined;
    user: User | undefined;
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    eventId: number | undefined;
    event: Event | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    changed: number | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBookingDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.eventId = data["eventId"];
            this.event = data["event"] ? Event.fromJS(data["event"]) : <any>undefined;
            this.attorneyId = data["attorneyId"];
            this.attorney = data["attorney"] ? Attorney.fromJS(data["attorney"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.changed = data["changed"];
            this.reason = data["reason"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BookingDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BookingDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["eventId"] = this.eventId;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["attorneyId"] = this.attorneyId;
        data["attorney"] = this.attorney ? this.attorney.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["changed"] = this.changed;
        data["reason"] = this.reason;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BookingDetailOutput {
        const json = this.toJSON();
        let result = new BookingDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IBookingDetailOutput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    userId: number | undefined;
    user: User | undefined;
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    eventId: number | undefined;
    event: Event | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    changed: number | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class Event implements IEvent {
    name: string | undefined;
    id: number | undefined;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Event {
        data = typeof data === 'object' ? data : {};
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): Event {
        const json = this.toJSON();
        let result = new Event();
        result.init(json);
        return result;
    }
}

export interface IEvent {
    name: string | undefined;
    id: number | undefined;
}

export class BookingListDto implements IBookingListDto {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    userId: number | undefined;
    user: User | undefined;
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    eventId: number | undefined;
    attorneyId: string | undefined;
    event: Event | undefined;
    attorney: Attorney | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    changed: number | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBookingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.eventId = data["eventId"];
            this.attorneyId = data["attorneyId"];
            this.event = data["event"] ? Event.fromJS(data["event"]) : <any>undefined;
            this.attorney = data["attorney"] ? Attorney.fromJS(data["attorney"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.changed = data["changed"];
            this.reason = data["reason"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BookingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["eventId"] = this.eventId;
        data["attorneyId"] = this.attorneyId;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["attorney"] = this.attorney ? this.attorney.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["changed"] = this.changed;
        data["reason"] = this.reason;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BookingListDto {
        const json = this.toJSON();
        let result = new BookingListDto();
        result.init(json);
        return result;
    }
}

export interface IBookingListDto {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    userId: number | undefined;
    user: User | undefined;
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    eventId: number | undefined;
    attorneyId: string | undefined;
    event: Event | undefined;
    attorney: Attorney | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    changed: number | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfBookingListDto implements IListResultDtoOfBookingListDto {
    items: BookingListDto[] | undefined;

    constructor(data?: IListResultDtoOfBookingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BookingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfBookingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfBookingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfBookingListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfBookingListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfBookingListDto {
    items: BookingListDto[] | undefined;
}

export class CreateEventInput implements ICreateEventInput {
    name: string | undefined;

    constructor(data?: ICreateEventInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CreateEventInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEventInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateEventInput {
        const json = this.toJSON();
        let result = new CreateEventInput();
        result.init(json);
        return result;
    }
}

export interface ICreateEventInput {
    name: string | undefined;
}

export class ListResultDtoOfEventListDto implements IListResultDtoOfEventListDto {
    items: EventListDto[] | undefined;

    constructor(data?: IListResultDtoOfEventListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EventListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEventListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEventListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfEventListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfEventListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfEventListDto {
    items: EventListDto[] | undefined;
}

export class EventListDto implements IEventListDto {
    name: string | undefined;
    id: number | undefined;

    constructor(data?: IEventListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EventListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): EventListDto {
        const json = this.toJSON();
        let result = new EventListDto();
        result.init(json);
        return result;
    }
}

export interface IEventListDto {
    name: string | undefined;
    id: number | undefined;
}

export class EventDetailOutput implements IEventDetailOutput {
    name: string | undefined;
    id: number | undefined;

    constructor(data?: IEventDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EventDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EventDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): EventDetailOutput {
        const json = this.toJSON();
        let result = new EventDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IEventDetailOutput {
    name: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfBookingListDto implements IPagedResultDtoOfBookingListDto {
    totalCount: number | undefined;
    items: BookingListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBookingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BookingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBookingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBookingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfBookingListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfBookingListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfBookingListDto {
    totalCount: number | undefined;
    items: BookingListDto[] | undefined;
}

export class AssessmentResult implements IAssessmentResult {
    result: number | undefined;
    comment: string | undefined;

    constructor(data?: IAssessmentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): AssessmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssessmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): AssessmentResult {
        const json = this.toJSON();
        let result = new AssessmentResult();
        result.init(json);
        return result;
    }
}

export interface IAssessmentResult {
    result: number | undefined;
    comment: string | undefined;
}

export class CreateClientInput implements ICreateClientInput {
    lawFirmId: string | undefined;
    contactId: string | undefined;
    attorneyId: string | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: number | undefined;
    dob: moment.Moment | undefined;
    addressId: number | undefined;
    dateOfInjury: moment.Moment | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;

    constructor(data?: ICreateClientInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.contactId = data["contactId"];
            this.attorneyId = data["attorneyId"];
            this.courtDate = data["courtDate"] ? moment(data["courtDate"].toString()) : <any>undefined;
            this.caseNumber = data["caseNumber"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.title = data["title"];
            this.idNumber = data["idNumber"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.addressId = data["addressId"];
            this.dateOfInjury = data["dateOfInjury"] ? moment(data["dateOfInjury"].toString()) : <any>undefined;
            this.assessmentDate = data["assessmentDate"] ? moment(data["assessmentDate"].toString()) : <any>undefined;
            this.earlyChildhood = data["earlyChildhood"];
            this.family = data["family"];
            this.homeEnvironment = data["homeEnvironment"];
            this.education = data["education"];
            this.socialHabits = data["socialHabits"];
            this.currentComplaints = data["currentComplaints"];
            this.profilePictureId = data["profilePictureId"];
            this.affect = data["affect"];
            this.jobDescription = data["jobDescription"];
            this.motivation = data["motivation"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateClientInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["contactId"] = this.contactId;
        data["attorneyId"] = this.attorneyId;
        data["courtDate"] = this.courtDate ? this.courtDate.toISOString() : <any>undefined;
        data["caseNumber"] = this.caseNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["title"] = this.title;
        data["idNumber"] = this.idNumber;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        data["dateOfInjury"] = this.dateOfInjury ? this.dateOfInjury.toISOString() : <any>undefined;
        data["assessmentDate"] = this.assessmentDate ? this.assessmentDate.toISOString() : <any>undefined;
        data["earlyChildhood"] = this.earlyChildhood;
        data["family"] = this.family;
        data["homeEnvironment"] = this.homeEnvironment;
        data["education"] = this.education;
        data["socialHabits"] = this.socialHabits;
        data["currentComplaints"] = this.currentComplaints;
        data["profilePictureId"] = this.profilePictureId;
        data["affect"] = this.affect;
        data["jobDescription"] = this.jobDescription;
        data["motivation"] = this.motivation;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CreateClientInput {
        const json = this.toJSON();
        let result = new CreateClientInput();
        result.init(json);
        return result;
    }
}

export interface ICreateClientInput {
    lawFirmId: string | undefined;
    contactId: string | undefined;
    attorneyId: string | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: number | undefined;
    dob: moment.Moment | undefined;
    addressId: number | undefined;
    dateOfInjury: moment.Moment | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
}

export class ClientDetailOutput implements IClientDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: number | undefined;
    dob: moment.Moment | undefined;
    dateOfInjury: moment.Moment | undefined;
    addressId: number | undefined;
    address: CreateAddressInput | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IClientDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.attorneyId = data["attorneyId"];
            this.attorney = data["attorney"] ? Attorney.fromJS(data["attorney"]) : <any>undefined;
            this.courtDate = data["courtDate"] ? moment(data["courtDate"].toString()) : <any>undefined;
            this.caseNumber = data["caseNumber"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.title = data["title"];
            this.idNumber = data["idNumber"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.dateOfInjury = data["dateOfInjury"] ? moment(data["dateOfInjury"].toString()) : <any>undefined;
            this.addressId = data["addressId"];
            this.address = data["address"] ? CreateAddressInput.fromJS(data["address"]) : <any>undefined;
            this.assessmentDate = data["assessmentDate"] ? moment(data["assessmentDate"].toString()) : <any>undefined;
            this.earlyChildhood = data["earlyChildhood"];
            this.family = data["family"];
            this.homeEnvironment = data["homeEnvironment"];
            this.education = data["education"];
            this.socialHabits = data["socialHabits"];
            this.currentComplaints = data["currentComplaints"];
            this.profilePictureId = data["profilePictureId"];
            this.affect = data["affect"];
            this.jobDescription = data["jobDescription"];
            this.motivation = data["motivation"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ClientDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["attorneyId"] = this.attorneyId;
        data["attorney"] = this.attorney ? this.attorney.toJSON() : <any>undefined;
        data["courtDate"] = this.courtDate ? this.courtDate.toISOString() : <any>undefined;
        data["caseNumber"] = this.caseNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["title"] = this.title;
        data["idNumber"] = this.idNumber;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["dateOfInjury"] = this.dateOfInjury ? this.dateOfInjury.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["assessmentDate"] = this.assessmentDate ? this.assessmentDate.toISOString() : <any>undefined;
        data["earlyChildhood"] = this.earlyChildhood;
        data["family"] = this.family;
        data["homeEnvironment"] = this.homeEnvironment;
        data["education"] = this.education;
        data["socialHabits"] = this.socialHabits;
        data["currentComplaints"] = this.currentComplaints;
        data["profilePictureId"] = this.profilePictureId;
        data["affect"] = this.affect;
        data["jobDescription"] = this.jobDescription;
        data["motivation"] = this.motivation;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientDetailOutput {
        const json = this.toJSON();
        let result = new ClientDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IClientDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: number | undefined;
    dob: moment.Moment | undefined;
    dateOfInjury: moment.Moment | undefined;
    addressId: number | undefined;
    address: CreateAddressInput | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateAddressInput implements ICreateAddressInput {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;

    constructor(data?: ICreateAddressInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.city = data["city"];
            this.postalCode = data["postalCode"];
            this.province = data["province"];
        }
    }

    static fromJS(data: any): CreateAddressInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAddressInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["province"] = this.province;
        return data; 
    }

    clone(): CreateAddressInput {
        const json = this.toJSON();
        let result = new CreateAddressInput();
        result.init(json);
        return result;
    }
}

export interface ICreateAddressInput {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;
}

export class PagedResultDtoOfClientListDto implements IPagedResultDtoOfClientListDto {
    totalCount: number | undefined;
    items: ClientListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfClientListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ClientListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfClientListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfClientListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfClientListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfClientListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfClientListDto {
    totalCount: number | undefined;
    items: ClientListDto[] | undefined;
}

export class ClientListDto implements IClientListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: number | undefined;
    dob: moment.Moment | undefined;
    dateOfInjury: moment.Moment | undefined;
    address: Address | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IClientListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.attorneyId = data["attorneyId"];
            this.attorney = data["attorney"] ? Attorney.fromJS(data["attorney"]) : <any>undefined;
            this.courtDate = data["courtDate"] ? moment(data["courtDate"].toString()) : <any>undefined;
            this.caseNumber = data["caseNumber"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.title = data["title"];
            this.idNumber = data["idNumber"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.dateOfInjury = data["dateOfInjury"] ? moment(data["dateOfInjury"].toString()) : <any>undefined;
            this.address = data["address"] ? Address.fromJS(data["address"]) : <any>undefined;
            this.assessmentDate = data["assessmentDate"] ? moment(data["assessmentDate"].toString()) : <any>undefined;
            this.earlyChildhood = data["earlyChildhood"];
            this.family = data["family"];
            this.homeEnvironment = data["homeEnvironment"];
            this.education = data["education"];
            this.socialHabits = data["socialHabits"];
            this.currentComplaints = data["currentComplaints"];
            this.profilePictureId = data["profilePictureId"];
            this.affect = data["affect"];
            this.jobDescription = data["jobDescription"];
            this.motivation = data["motivation"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ClientListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["attorneyId"] = this.attorneyId;
        data["attorney"] = this.attorney ? this.attorney.toJSON() : <any>undefined;
        data["courtDate"] = this.courtDate ? this.courtDate.toISOString() : <any>undefined;
        data["caseNumber"] = this.caseNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["title"] = this.title;
        data["idNumber"] = this.idNumber;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["dateOfInjury"] = this.dateOfInjury ? this.dateOfInjury.toISOString() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["assessmentDate"] = this.assessmentDate ? this.assessmentDate.toISOString() : <any>undefined;
        data["earlyChildhood"] = this.earlyChildhood;
        data["family"] = this.family;
        data["homeEnvironment"] = this.homeEnvironment;
        data["education"] = this.education;
        data["socialHabits"] = this.socialHabits;
        data["currentComplaints"] = this.currentComplaints;
        data["profilePictureId"] = this.profilePictureId;
        data["affect"] = this.affect;
        data["jobDescription"] = this.jobDescription;
        data["motivation"] = this.motivation;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientListDto {
        const json = this.toJSON();
        let result = new ClientListDto();
        result.init(json);
        return result;
    }
}

export interface IClientListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    attorneyId: string | undefined;
    attorney: Attorney | undefined;
    courtDate: moment.Moment | undefined;
    caseNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    title: string | undefined;
    idNumber: number | undefined;
    dob: moment.Moment | undefined;
    dateOfInjury: moment.Moment | undefined;
    address: Address | undefined;
    assessmentDate: moment.Moment | undefined;
    earlyChildhood: string | undefined;
    family: string | undefined;
    homeEnvironment: string | undefined;
    education: string | undefined;
    socialHabits: string | undefined;
    currentComplaints: string | undefined;
    profilePictureId: string | undefined;
    affect: string | undefined;
    jobDescription: string | undefined;
    motivation: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfClientListDto implements IListResultDtoOfClientListDto {
    items: ClientListDto[] | undefined;

    constructor(data?: IListResultDtoOfClientListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ClientListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfClientListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfClientListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfClientListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfClientListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfClientListDto {
    items: ClientListDto[] | undefined;
}

export class CreateWorkHistoryInput implements ICreateWorkHistoryInput {
    clientId: string | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;

    constructor(data?: ICreateWorkHistoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.premorbid = data["premorbid"];
            this.postMorbid = data["postMorbid"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): CreateWorkHistoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkHistoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["premorbid"] = this.premorbid;
        data["postMorbid"] = this.postMorbid;
        data["description"] = this.description;
        return data; 
    }

    clone(): CreateWorkHistoryInput {
        const json = this.toJSON();
        let result = new CreateWorkHistoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateWorkHistoryInput {
    clientId: string | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;
}

export class WorkHistoryDetailOutput implements IWorkHistoryDetailOutput {
    clientId: string | undefined;
    client: Client | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;
    id: string | undefined;

    constructor(data?: IWorkHistoryDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.premorbid = data["premorbid"];
            this.postMorbid = data["postMorbid"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkHistoryDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WorkHistoryDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["premorbid"] = this.premorbid;
        data["postMorbid"] = this.postMorbid;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): WorkHistoryDetailOutput {
        const json = this.toJSON();
        let result = new WorkHistoryDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IWorkHistoryDetailOutput {
    clientId: string | undefined;
    client: Client | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;
    id: string | undefined;
}

export class WorkHistoryListDto implements IWorkHistoryListDto {
    clientId: string | undefined;
    client: Client | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;
    id: string | undefined;

    constructor(data?: IWorkHistoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.premorbid = data["premorbid"];
            this.postMorbid = data["postMorbid"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkHistoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkHistoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["premorbid"] = this.premorbid;
        data["postMorbid"] = this.postMorbid;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): WorkHistoryListDto {
        const json = this.toJSON();
        let result = new WorkHistoryListDto();
        result.init(json);
        return result;
    }
}

export interface IWorkHistoryListDto {
    clientId: string | undefined;
    client: Client | undefined;
    premorbid: string | undefined;
    postMorbid: string | undefined;
    description: string | undefined;
    id: string | undefined;
}

export class CreateMedicalHistoryInput implements ICreateMedicalHistoryInput {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    medication: string | undefined;

    constructor(data?: ICreateMedicalHistoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.previousInjuries = data["previousInjuries"];
            this.clientId = data["clientId"];
            this.medicalConditions = data["medicalConditions"];
            this.currentHistory = data["currentHistory"];
            this.medication = data["medication"];
        }
    }

    static fromJS(data: any): CreateMedicalHistoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMedicalHistoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["previousInjuries"] = this.previousInjuries;
        data["clientId"] = this.clientId;
        data["medicalConditions"] = this.medicalConditions;
        data["currentHistory"] = this.currentHistory;
        data["medication"] = this.medication;
        return data; 
    }

    clone(): CreateMedicalHistoryInput {
        const json = this.toJSON();
        let result = new CreateMedicalHistoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateMedicalHistoryInput {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    medication: string | undefined;
}

export class MedicalHistoryDetailOutput implements IMedicalHistoryDetailOutput {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    medication: string | undefined;
    id: string | undefined;

    constructor(data?: IMedicalHistoryDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.previousInjuries = data["previousInjuries"];
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.medicalConditions = data["medicalConditions"];
            this.currentHistory = data["currentHistory"];
            this.medication = data["medication"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MedicalHistoryDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MedicalHistoryDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["previousInjuries"] = this.previousInjuries;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["medicalConditions"] = this.medicalConditions;
        data["currentHistory"] = this.currentHistory;
        data["medication"] = this.medication;
        data["id"] = this.id;
        return data; 
    }

    clone(): MedicalHistoryDetailOutput {
        const json = this.toJSON();
        let result = new MedicalHistoryDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IMedicalHistoryDetailOutput {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    medication: string | undefined;
    id: string | undefined;
}

export class MedicalHistoryListDto implements IMedicalHistoryListDto {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    medication: string | undefined;
    id: string | undefined;

    constructor(data?: IMedicalHistoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.previousInjuries = data["previousInjuries"];
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.medicalConditions = data["medicalConditions"];
            this.currentHistory = data["currentHistory"];
            this.medication = data["medication"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MedicalHistoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicalHistoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["previousInjuries"] = this.previousInjuries;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["medicalConditions"] = this.medicalConditions;
        data["currentHistory"] = this.currentHistory;
        data["medication"] = this.medication;
        data["id"] = this.id;
        return data; 
    }

    clone(): MedicalHistoryListDto {
        const json = this.toJSON();
        let result = new MedicalHistoryListDto();
        result.init(json);
        return result;
    }
}

export interface IMedicalHistoryListDto {
    previousInjuries: string | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    medicalConditions: string | undefined;
    currentHistory: string | undefined;
    medication: string | undefined;
    id: string | undefined;
}

export class CreateCommentInput implements ICreateCommentInput {
    userId: number | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;

    constructor(data?: ICreateCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.text = data["text"];
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
        }
    }

    static fromJS(data: any): CreateCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["text"] = this.text;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        return data; 
    }

    clone(): CreateCommentInput {
        const json = this.toJSON();
        let result = new CreateCommentInput();
        result.init(json);
        return result;
    }
}

export interface ICreateCommentInput {
    userId: number | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
}

export class CommentDetailOutput implements ICommentDetailOutput {
    userId: number | undefined;
    user: User | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICommentDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.text = data["text"];
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CommentDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CommentDetailOutput {
        const json = this.toJSON();
        let result = new CommentDetailOutput();
        result.init(json);
        return result;
    }
}

export interface ICommentDetailOutput {
    userId: number | undefined;
    user: User | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CommentListDto implements ICommentListDto {
    userId: number | undefined;
    user: User | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICommentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.text = data["text"];
            this.targetId = data["targetId"];
            this.targetType = data["targetType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CommentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["text"] = this.text;
        data["targetId"] = this.targetId;
        data["targetType"] = this.targetType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CommentListDto {
        const json = this.toJSON();
        let result = new CommentListDto();
        result.init(json);
        return result;
    }
}

export interface ICommentListDto {
    userId: number | undefined;
    user: User | undefined;
    text: string | undefined;
    targetId: string | undefined;
    targetType: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfCommentListDto implements IPagedResultDtoOfCommentListDto {
    totalCount: number | undefined;
    items: CommentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCommentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CommentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCommentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCommentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCommentListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCommentListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCommentListDto {
    totalCount: number | undefined;
    items: CommentListDto[] | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class CreateContactInput implements ICreateContactInput {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;

    constructor(data?: ICreateContactInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.role = data["role"];
        }
    }

    static fromJS(data: any): CreateContactInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["role"] = this.role;
        return data; 
    }

    clone(): CreateContactInput {
        const json = this.toJSON();
        let result = new CreateContactInput();
        result.init(json);
        return result;
    }
}

export interface ICreateContactInput {
    lawFirmId: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
}

export class ContactDetailOutput implements IContactDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IContactDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.role = data["role"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["role"] = this.role;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ContactDetailOutput {
        const json = this.toJSON();
        let result = new ContactDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IContactDetailOutput {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ContactListDto implements IContactListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IContactListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lawFirmId = data["lawFirmId"];
            this.lawFirm = data["lawFirm"] ? LawFirm.fromJS(data["lawFirm"]) : <any>undefined;
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.role = data["role"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lawFirmId"] = this.lawFirmId;
        data["lawFirm"] = this.lawFirm ? this.lawFirm.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["role"] = this.role;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ContactListDto {
        const json = this.toJSON();
        let result = new ContactListDto();
        result.init(json);
        return result;
    }
}

export interface IContactListDto {
    lawFirmId: string | undefined;
    lawFirm: LawFirm | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    email: string | undefined;
    role: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfContactListDto implements IListResultDtoOfContactListDto {
    items: ContactListDto[] | undefined;

    constructor(data?: IListResultDtoOfContactListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContactListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfContactListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfContactListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfContactListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfContactListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfContactListDto {
    items: ContactListDto[] | undefined;
}

export class PagedResultDtoOfContactListDto implements IPagedResultDtoOfContactListDto {
    totalCount: number | undefined;
    items: ContactListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ContactListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfContactListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfContactListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfContactListDto {
    totalCount: number | undefined;
    items: ContactListDto[] | undefined;
}

export class CrawlingProtocolDetailOutput implements ICrawlingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    numTests: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICrawlingProtocolDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.numTests = data["numTests"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CrawlingProtocolDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CrawlingProtocolDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["numTests"] = this.numTests;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CrawlingProtocolDetailOutput {
        const json = this.toJSON();
        let result = new CrawlingProtocolDetailOutput();
        result.init(json);
        return result;
    }
}

export interface ICrawlingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    numTests: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CrawlingProtocolDto implements ICrawlingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    numTests: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICrawlingProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.numTests = data["numTests"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CrawlingProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrawlingProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["numTests"] = this.numTests;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CrawlingProtocolDto {
        const json = this.toJSON();
        let result = new CrawlingProtocolDto();
        result.init(json);
        return result;
    }
}

export interface ICrawlingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    numTests: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateDocumentInput implements ICreateDocumentInput {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    contactId: string | undefined;
    parentDocId: number | undefined;
    userId: number | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;

    constructor(data?: ICreateDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.authorName = data["authorName"];
            this.authorDate = data["authorDate"] ? moment(data["authorDate"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.contactId = data["contactId"];
            this.parentDocId = data["parentDocId"];
            this.userId = data["userId"];
            this.fileUrl = data["fileUrl"];
            this.identifier = data["identifier"];
        }
    }

    static fromJS(data: any): CreateDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["authorName"] = this.authorName;
        data["authorDate"] = this.authorDate ? this.authorDate.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["contactId"] = this.contactId;
        data["parentDocId"] = this.parentDocId;
        data["userId"] = this.userId;
        data["fileUrl"] = this.fileUrl;
        data["identifier"] = this.identifier;
        return data; 
    }

    clone(): CreateDocumentInput {
        const json = this.toJSON();
        let result = new CreateDocumentInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDocumentInput {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    contactId: string | undefined;
    parentDocId: number | undefined;
    userId: number | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;
}

export class DocumentDetailOutput implements IDocumentDetailOutput {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    parentDocId: number | undefined;
    client: Client | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    userId: number | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDocumentDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.authorName = data["authorName"];
            this.authorDate = data["authorDate"] ? moment(data["authorDate"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.parentDocId = data["parentDocId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.userId = data["userId"];
            this.fileUrl = data["fileUrl"];
            this.identifier = data["identifier"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DocumentDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["authorName"] = this.authorName;
        data["authorDate"] = this.authorDate ? this.authorDate.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["parentDocId"] = this.parentDocId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["fileUrl"] = this.fileUrl;
        data["identifier"] = this.identifier;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DocumentDetailOutput {
        const json = this.toJSON();
        let result = new DocumentDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IDocumentDetailOutput {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    parentDocId: number | undefined;
    client: Client | undefined;
    contactId: string | undefined;
    contact: Contact | undefined;
    userId: number | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ListResultDtoOfDocumentListDto implements IListResultDtoOfDocumentListDto {
    items: DocumentListDto[] | undefined;

    constructor(data?: IListResultDtoOfDocumentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DocumentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDocumentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDocumentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfDocumentListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfDocumentListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfDocumentListDto {
    items: DocumentListDto[] | undefined;
}

export class DocumentListDto implements IDocumentListDto {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    contactId: string | undefined;
    parentDocId: number | undefined;
    contact: Contact | undefined;
    userId: number | undefined;
    user: User | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IDocumentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.authorName = data["authorName"];
            this.authorDate = data["authorDate"] ? moment(data["authorDate"].toString()) : <any>undefined;
            this.clientId = data["clientId"];
            this.client = data["client"] ? Client.fromJS(data["client"]) : <any>undefined;
            this.contactId = data["contactId"];
            this.parentDocId = data["parentDocId"];
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.fileUrl = data["fileUrl"];
            this.identifier = data["identifier"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DocumentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["authorName"] = this.authorName;
        data["authorDate"] = this.authorDate ? this.authorDate.toISOString() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["parentDocId"] = this.parentDocId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["fileUrl"] = this.fileUrl;
        data["identifier"] = this.identifier;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DocumentListDto {
        const json = this.toJSON();
        let result = new DocumentListDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentListDto {
    name: string | undefined;
    authorName: string | undefined;
    authorDate: moment.Moment | undefined;
    clientId: string | undefined;
    client: Client | undefined;
    contactId: string | undefined;
    parentDocId: number | undefined;
    contact: Contact | undefined;
    userId: number | undefined;
    user: User | undefined;
    fileUrl: string | undefined;
    identifier: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDocumentListDto implements IPagedResultDtoOfDocumentListDto {
    totalCount: number | undefined;
    items: DocumentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDocumentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DocumentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDocumentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDocumentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDocumentListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDocumentListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDocumentListDto {
    totalCount: number | undefined;
    items: DocumentListDto[] | undefined;
}

export class CreateJobDescriptionInput implements ICreateJobDescriptionInput {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;

    constructor(data?: ICreateJobDescriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.description = data["description"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): CreateJobDescriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobDescriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["title"] = this.title;
        return data; 
    }

    clone(): CreateJobDescriptionInput {
        const json = this.toJSON();
        let result = new CreateJobDescriptionInput();
        result.init(json);
        return result;
    }
}

export interface ICreateJobDescriptionInput {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;
}

export class JobDescriptionDetailOutput implements IJobDescriptionDetailOutput {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IJobDescriptionDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.description = data["description"];
            this.title = data["title"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): JobDescriptionDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new JobDescriptionDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["title"] = this.title;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): JobDescriptionDetailOutput {
        const json = this.toJSON();
        let result = new JobDescriptionDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IJobDescriptionDetailOutput {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class JobDescriptionListDto implements IJobDescriptionListDto {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IJobDescriptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.description = data["description"];
            this.title = data["title"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): JobDescriptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobDescriptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["title"] = this.title;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): JobDescriptionListDto {
        const json = this.toJSON();
        let result = new JobDescriptionListDto();
        result.init(json);
        return result;
    }
}

export interface IJobDescriptionListDto {
    code: string | undefined;
    description: string | undefined;
    title: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfJobDescriptionListDto implements IPagedResultDtoOfJobDescriptionListDto {
    totalCount: number | undefined;
    items: JobDescriptionListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfJobDescriptionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(JobDescriptionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfJobDescriptionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfJobDescriptionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfJobDescriptionListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfJobDescriptionListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfJobDescriptionListDto {
    totalCount: number | undefined;
    items: JobDescriptionListDto[] | undefined;
}

export class LadderWorkProtocolDetailOutput implements ILadderWorkProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    numTests: number | undefined;
    numSets: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILadderWorkProtocolDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.numTests = data["numTests"];
            this.numSets = data["numSets"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LadderWorkProtocolDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LadderWorkProtocolDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["numTests"] = this.numTests;
        data["numSets"] = this.numSets;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LadderWorkProtocolDetailOutput {
        const json = this.toJSON();
        let result = new LadderWorkProtocolDetailOutput();
        result.init(json);
        return result;
    }
}

export interface ILadderWorkProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    numTests: number | undefined;
    numSets: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class LadderWorkProtocolDto implements ILadderWorkProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    numTests: number | undefined;
    numSets: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILadderWorkProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.numTests = data["numTests"];
            this.numSets = data["numSets"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LadderWorkProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new LadderWorkProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["numTests"] = this.numTests;
        data["numSets"] = this.numSets;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LadderWorkProtocolDto {
        const json = this.toJSON();
        let result = new LadderWorkProtocolDto();
        result.init(json);
        return result;
    }
}

export interface ILadderWorkProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    numTests: number | undefined;
    numSets: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateLawFirmInput implements ICreateLawFirmInput {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: CreateAddressInput | undefined;
    postalAddressId: number | undefined;
    postalAddress: CreateAddressInput | undefined;
    sameAddress: boolean | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;

    constructor(data?: ICreateLawFirmInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.physicalAddressId = data["physicalAddressId"];
            this.physicalAddress = data["physicalAddress"] ? CreateAddressInput.fromJS(data["physicalAddress"]) : <any>undefined;
            this.postalAddressId = data["postalAddressId"];
            this.postalAddress = data["postalAddress"] ? CreateAddressInput.fromJS(data["postalAddress"]) : <any>undefined;
            this.sameAddress = data["sameAddress"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.fax = data["fax"];
        }
    }

    static fromJS(data: any): CreateLawFirmInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLawFirmInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["physicalAddressId"] = this.physicalAddressId;
        data["physicalAddress"] = this.physicalAddress ? this.physicalAddress.toJSON() : <any>undefined;
        data["postalAddressId"] = this.postalAddressId;
        data["postalAddress"] = this.postalAddress ? this.postalAddress.toJSON() : <any>undefined;
        data["sameAddress"] = this.sameAddress;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        return data; 
    }

    clone(): CreateLawFirmInput {
        const json = this.toJSON();
        let result = new CreateLawFirmInput();
        result.init(json);
        return result;
    }
}

export interface ICreateLawFirmInput {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: CreateAddressInput | undefined;
    postalAddressId: number | undefined;
    postalAddress: CreateAddressInput | undefined;
    sameAddress: boolean | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
}

export class LawFirmDetailOutput implements ILawFirmDetailOutput {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: AddressDetailOutput | undefined;
    postalAddressId: number | undefined;
    postalAddress: AddressDetailOutput | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    sameAddress: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILawFirmDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.physicalAddressId = data["physicalAddressId"];
            this.physicalAddress = data["physicalAddress"] ? AddressDetailOutput.fromJS(data["physicalAddress"]) : <any>undefined;
            this.postalAddressId = data["postalAddressId"];
            this.postalAddress = data["postalAddress"] ? AddressDetailOutput.fromJS(data["postalAddress"]) : <any>undefined;
            this.email = data["email"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.sameAddress = data["sameAddress"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LawFirmDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new LawFirmDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["physicalAddressId"] = this.physicalAddressId;
        data["physicalAddress"] = this.physicalAddress ? this.physicalAddress.toJSON() : <any>undefined;
        data["postalAddressId"] = this.postalAddressId;
        data["postalAddress"] = this.postalAddress ? this.postalAddress.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["sameAddress"] = this.sameAddress;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LawFirmDetailOutput {
        const json = this.toJSON();
        let result = new LawFirmDetailOutput();
        result.init(json);
        return result;
    }
}

export interface ILawFirmDetailOutput {
    companyName: string | undefined;
    physicalAddressId: number | undefined;
    physicalAddress: AddressDetailOutput | undefined;
    postalAddressId: number | undefined;
    postalAddress: AddressDetailOutput | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    sameAddress: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class AddressDetailOutput implements IAddressDetailOutput {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;
    id: number | undefined;

    constructor(data?: IAddressDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.city = data["city"];
            this.postalCode = data["postalCode"];
            this.province = data["province"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AddressDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["province"] = this.province;
        data["id"] = this.id;
        return data; 
    }

    clone(): AddressDetailOutput {
        const json = this.toJSON();
        let result = new AddressDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IAddressDetailOutput {
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    postalCode: string | undefined;
    province: string | undefined;
    id: number | undefined;
}

export class LawFirmListDto implements ILawFirmListDto {
    companyName: string | undefined;
    physicalAddress: Address | undefined;
    postalAddress: Address | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ILawFirmListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.physicalAddress = data["physicalAddress"] ? Address.fromJS(data["physicalAddress"]) : <any>undefined;
            this.postalAddress = data["postalAddress"] ? Address.fromJS(data["postalAddress"]) : <any>undefined;
            this.email = data["email"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LawFirmListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LawFirmListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["physicalAddress"] = this.physicalAddress ? this.physicalAddress.toJSON() : <any>undefined;
        data["postalAddress"] = this.postalAddress ? this.postalAddress.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LawFirmListDto {
        const json = this.toJSON();
        let result = new LawFirmListDto();
        result.init(json);
        return result;
    }
}

export interface ILawFirmListDto {
    companyName: string | undefined;
    physicalAddress: Address | undefined;
    postalAddress: Address | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfLawFirmListDto implements IListResultDtoOfLawFirmListDto {
    items: LawFirmListDto[] | undefined;

    constructor(data?: IListResultDtoOfLawFirmListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LawFirmListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLawFirmListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLawFirmListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfLawFirmListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfLawFirmListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfLawFirmListDto {
    items: LawFirmListDto[] | undefined;
}

export class ListResultDtoOfAttorneyListDto implements IListResultDtoOfAttorneyListDto {
    items: AttorneyListDto[] | undefined;

    constructor(data?: IListResultDtoOfAttorneyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AttorneyListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAttorneyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAttorneyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfAttorneyListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfAttorneyListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfAttorneyListDto {
    items: AttorneyListDto[] | undefined;
}

export class PagedResultDtoOfLawFirmListDto implements IPagedResultDtoOfLawFirmListDto {
    totalCount: number | undefined;
    items: LawFirmListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLawFirmListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LawFirmListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLawFirmListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLawFirmListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLawFirmListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLawFirmListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLawFirmListDto {
    totalCount: number | undefined;
    items: LawFirmListDto[] | undefined;
}

export class ProfileDto implements IProfileDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;

    constructor(data?: IProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
        }
    }

    static fromJS(data: any): ProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data; 
    }

    clone(): ProfileDto {
        const json = this.toJSON();
        let result = new ProfileDto();
        result.init(json);
        return result;
    }
}

export interface IProfileDto {
    userName: string | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
}

export class RangeOfMotionDto implements IRangeOfMotionDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRangeOfMotionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.assessmentId = data["assessmentId"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RangeOfMotionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RangeOfMotionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["assessmentId"] = this.assessmentId;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RangeOfMotionDto {
        const json = this.toJSON();
        let result = new RangeOfMotionDto();
        result.init(json);
        return result;
    }
}

export interface IRangeOfMotionDto {
    clientId: string | undefined;
    assessmentId: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class AnkleDto implements IAnkleDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    dorsiflexion: string | undefined;
    plantarFlexion: string | undefined;
    inversion: string | undefined;
    eversion: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IAnkleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.dorsiflexion = data["dorsiflexion"];
            this.plantarFlexion = data["plantarFlexion"];
            this.inversion = data["inversion"];
            this.eversion = data["eversion"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AnkleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnkleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["dorsiflexion"] = this.dorsiflexion;
        data["plantarFlexion"] = this.plantarFlexion;
        data["inversion"] = this.inversion;
        data["eversion"] = this.eversion;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AnkleDto {
        const json = this.toJSON();
        let result = new AnkleDto();
        result.init(json);
        return result;
    }
}

export interface IAnkleDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    dorsiflexion: string | undefined;
    plantarFlexion: string | undefined;
    inversion: string | undefined;
    eversion: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ElbowDto implements IElbowDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    pronation: string | undefined;
    supination: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IElbowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.extension = data["extension"];
            this.flexion = data["flexion"];
            this.pronation = data["pronation"];
            this.supination = data["supination"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ElbowDto {
        data = typeof data === 'object' ? data : {};
        let result = new ElbowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["extension"] = this.extension;
        data["flexion"] = this.flexion;
        data["pronation"] = this.pronation;
        data["supination"] = this.supination;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ElbowDto {
        const json = this.toJSON();
        let result = new ElbowDto();
        result.init(json);
        return result;
    }
}

export interface IElbowDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    pronation: string | undefined;
    supination: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ForearmWristDto implements IForearmWristDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    pronation: string | undefined;
    supination: string | undefined;
    radialDeviation: string | undefined;
    ulnarDeviation: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IForearmWristDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.extension = data["extension"];
            this.flexion = data["flexion"];
            this.pronation = data["pronation"];
            this.supination = data["supination"];
            this.radialDeviation = data["radialDeviation"];
            this.ulnarDeviation = data["ulnarDeviation"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ForearmWristDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForearmWristDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["extension"] = this.extension;
        data["flexion"] = this.flexion;
        data["pronation"] = this.pronation;
        data["supination"] = this.supination;
        data["radialDeviation"] = this.radialDeviation;
        data["ulnarDeviation"] = this.ulnarDeviation;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ForearmWristDto {
        const json = this.toJSON();
        let result = new ForearmWristDto();
        result.init(json);
        return result;
    }
}

export interface IForearmWristDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    pronation: string | undefined;
    supination: string | undefined;
    radialDeviation: string | undefined;
    ulnarDeviation: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class HipDto implements IHipDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    abduction: string | undefined;
    adduction: string | undefined;
    internalRotation: string | undefined;
    externalRotation: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IHipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.extension = data["extension"];
            this.flexion = data["flexion"];
            this.abduction = data["abduction"];
            this.adduction = data["adduction"];
            this.internalRotation = data["internalRotation"];
            this.externalRotation = data["externalRotation"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HipDto {
        data = typeof data === 'object' ? data : {};
        let result = new HipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["extension"] = this.extension;
        data["flexion"] = this.flexion;
        data["abduction"] = this.abduction;
        data["adduction"] = this.adduction;
        data["internalRotation"] = this.internalRotation;
        data["externalRotation"] = this.externalRotation;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): HipDto {
        const json = this.toJSON();
        let result = new HipDto();
        result.init(json);
        return result;
    }
}

export interface IHipDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    abduction: string | undefined;
    adduction: string | undefined;
    internalRotation: string | undefined;
    externalRotation: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class KneeDto implements IKneeDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IKneeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.extension = data["extension"];
            this.flexion = data["flexion"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): KneeDto {
        data = typeof data === 'object' ? data : {};
        let result = new KneeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["extension"] = this.extension;
        data["flexion"] = this.flexion;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): KneeDto {
        const json = this.toJSON();
        let result = new KneeDto();
        result.init(json);
        return result;
    }
}

export interface IKneeDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ShoulderDto implements IShoulderDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    abduction: string | undefined;
    adduction: string | undefined;
    internalRotation: string | undefined;
    externalRotation: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IShoulderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.side = data["side"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.extension = data["extension"];
            this.flexion = data["flexion"];
            this.abduction = data["abduction"];
            this.adduction = data["adduction"];
            this.internalRotation = data["internalRotation"];
            this.externalRotation = data["externalRotation"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ShoulderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShoulderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["side"] = this.side;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["extension"] = this.extension;
        data["flexion"] = this.flexion;
        data["abduction"] = this.abduction;
        data["adduction"] = this.adduction;
        data["internalRotation"] = this.internalRotation;
        data["externalRotation"] = this.externalRotation;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ShoulderDto {
        const json = this.toJSON();
        let result = new ShoulderDto();
        result.init(json);
        return result;
    }
}

export interface IShoulderDto {
    name: string | undefined;
    side: number | undefined;
    rangeOfMotionId: string | undefined;
    extension: string | undefined;
    flexion: string | undefined;
    abduction: string | undefined;
    adduction: string | undefined;
    internalRotation: string | undefined;
    externalRotation: string | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class HandDto implements IHandDto {
    name: string | undefined;
    rangeOfMotionId: string | undefined;
    indexFinger: string | undefined;
    indexFingerScore: number | undefined;
    middleFinger: string | undefined;
    middleFingerScore: number | undefined;
    ringFinger: string | undefined;
    ringFingerScore: number | undefined;
    littleFinger: string | undefined;
    littleFingerScore: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IHandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.rangeOfMotionId = data["rangeOfMotionId"];
            this.indexFinger = data["indexFinger"];
            this.indexFingerScore = data["indexFingerScore"];
            this.middleFinger = data["middleFinger"];
            this.middleFingerScore = data["middleFingerScore"];
            this.ringFinger = data["ringFinger"];
            this.ringFingerScore = data["ringFingerScore"];
            this.littleFinger = data["littleFinger"];
            this.littleFingerScore = data["littleFingerScore"];
            this.side = data["side"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): HandDto {
        data = typeof data === 'object' ? data : {};
        let result = new HandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["rangeOfMotionId"] = this.rangeOfMotionId;
        data["indexFinger"] = this.indexFinger;
        data["indexFingerScore"] = this.indexFingerScore;
        data["middleFinger"] = this.middleFinger;
        data["middleFingerScore"] = this.middleFingerScore;
        data["ringFinger"] = this.ringFinger;
        data["ringFingerScore"] = this.ringFingerScore;
        data["littleFinger"] = this.littleFinger;
        data["littleFingerScore"] = this.littleFingerScore;
        data["side"] = this.side;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): HandDto {
        const json = this.toJSON();
        let result = new HandDto();
        result.init(json);
        return result;
    }
}

export interface IHandDto {
    name: string | undefined;
    rangeOfMotionId: string | undefined;
    indexFinger: string | undefined;
    indexFingerScore: number | undefined;
    middleFinger: string | undefined;
    middleFingerScore: number | undefined;
    ringFinger: string | undefined;
    ringFingerScore: number | undefined;
    littleFinger: string | undefined;
    littleFingerScore: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class RepetitiveFootMotionProtocolDetailOutput implements IRepetitiveFootMotionProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    numTests: number | undefined;
    comment: string | undefined;
    numDepressions: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRepetitiveFootMotionProtocolDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.side = data["side"];
            this.painLevel = data["painLevel"];
            this.numTests = data["numTests"];
            this.comment = data["comment"];
            this.numDepressions = data["numDepressions"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RepetitiveFootMotionProtocolDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RepetitiveFootMotionProtocolDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["side"] = this.side;
        data["painLevel"] = this.painLevel;
        data["numTests"] = this.numTests;
        data["comment"] = this.comment;
        data["numDepressions"] = this.numDepressions;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RepetitiveFootMotionProtocolDetailOutput {
        const json = this.toJSON();
        let result = new RepetitiveFootMotionProtocolDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IRepetitiveFootMotionProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    numTests: number | undefined;
    comment: string | undefined;
    numDepressions: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class RepetitiveFootMotionProtocolDto implements IRepetitiveFootMotionProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    numTests: number | undefined;
    comment: string | undefined;
    numDepressions: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRepetitiveFootMotionProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.side = data["side"];
            this.painLevel = data["painLevel"];
            this.numTests = data["numTests"];
            this.comment = data["comment"];
            this.numDepressions = data["numDepressions"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RepetitiveFootMotionProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepetitiveFootMotionProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["side"] = this.side;
        data["painLevel"] = this.painLevel;
        data["numTests"] = this.numTests;
        data["comment"] = this.comment;
        data["numDepressions"] = this.numDepressions;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RepetitiveFootMotionProtocolDto {
        const json = this.toJSON();
        let result = new RepetitiveFootMotionProtocolDto();
        result.init(json);
        return result;
    }
}

export interface IRepetitiveFootMotionProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    side: number | undefined;
    painLevel: number | undefined;
    numTests: number | undefined;
    comment: string | undefined;
    numDepressions: number | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class RepetitiveSquattingProtocolDetailOutput implements IRepetitiveSquattingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    numSquats: number | undefined;
    numPegsFirstTime: number | undefined;
    numPegsSecondTime: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRepetitiveSquattingProtocolDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.initialHeartRate = data["initialHeartRate"];
            this.secondHeartRate = data["secondHeartRate"];
            this.numSquats = data["numSquats"];
            this.numPegsFirstTime = data["numPegsFirstTime"];
            this.numPegsSecondTime = data["numPegsSecondTime"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RepetitiveSquattingProtocolDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RepetitiveSquattingProtocolDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["initialHeartRate"] = this.initialHeartRate;
        data["secondHeartRate"] = this.secondHeartRate;
        data["numSquats"] = this.numSquats;
        data["numPegsFirstTime"] = this.numPegsFirstTime;
        data["numPegsSecondTime"] = this.numPegsSecondTime;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RepetitiveSquattingProtocolDetailOutput {
        const json = this.toJSON();
        let result = new RepetitiveSquattingProtocolDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IRepetitiveSquattingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    numSquats: number | undefined;
    numPegsFirstTime: number | undefined;
    numPegsSecondTime: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class RepetitiveSquattingProtocolDto implements IRepetitiveSquattingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    numSquats: number | undefined;
    numPegsFirstTime: number | undefined;
    numPegsSecondTime: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IRepetitiveSquattingProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.initialHeartRate = data["initialHeartRate"];
            this.secondHeartRate = data["secondHeartRate"];
            this.numSquats = data["numSquats"];
            this.numPegsFirstTime = data["numPegsFirstTime"];
            this.numPegsSecondTime = data["numPegsSecondTime"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RepetitiveSquattingProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new RepetitiveSquattingProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["initialHeartRate"] = this.initialHeartRate;
        data["secondHeartRate"] = this.secondHeartRate;
        data["numSquats"] = this.numSquats;
        data["numPegsFirstTime"] = this.numPegsFirstTime;
        data["numPegsSecondTime"] = this.numPegsSecondTime;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RepetitiveSquattingProtocolDto {
        const json = this.toJSON();
        let result = new RepetitiveSquattingProtocolDto();
        result.init(json);
        return result;
    }
}

export interface IRepetitiveSquattingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    numSquats: number | undefined;
    numPegsFirstTime: number | undefined;
    numPegsSecondTime: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["grantedPermissions"] && data["grantedPermissions"].constructor === Array) {
                this.grantedPermissions = [];
                for (let item of data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.grantedPermissions && this.grantedPermissions.constructor === Array) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["grantedPermissions"] && data["grantedPermissions"].constructor === Array) {
                this.grantedPermissions = [];
                for (let item of data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.grantedPermissions && this.grantedPermissions.constructor === Array) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfPermissionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfRoleDto implements IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;
}

export class StairClimbingProtocolDetailOutput implements IStairClimbingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    thirdHeartRate: number | undefined;
    fourthHeartRate: number | undefined;
    numStairs: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IStairClimbingProtocolDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.initialHeartRate = data["initialHeartRate"];
            this.secondHeartRate = data["secondHeartRate"];
            this.thirdHeartRate = data["thirdHeartRate"];
            this.fourthHeartRate = data["fourthHeartRate"];
            this.numStairs = data["numStairs"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StairClimbingProtocolDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StairClimbingProtocolDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["initialHeartRate"] = this.initialHeartRate;
        data["secondHeartRate"] = this.secondHeartRate;
        data["thirdHeartRate"] = this.thirdHeartRate;
        data["fourthHeartRate"] = this.fourthHeartRate;
        data["numStairs"] = this.numStairs;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): StairClimbingProtocolDetailOutput {
        const json = this.toJSON();
        let result = new StairClimbingProtocolDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IStairClimbingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    thirdHeartRate: number | undefined;
    fourthHeartRate: number | undefined;
    numStairs: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class StairClimbingProtocolDto implements IStairClimbingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    thirdHeartRate: number | undefined;
    fourthHeartRate: number | undefined;
    numStairs: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IStairClimbingProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.initialHeartRate = data["initialHeartRate"];
            this.secondHeartRate = data["secondHeartRate"];
            this.thirdHeartRate = data["thirdHeartRate"];
            this.fourthHeartRate = data["fourthHeartRate"];
            this.numStairs = data["numStairs"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StairClimbingProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new StairClimbingProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["initialHeartRate"] = this.initialHeartRate;
        data["secondHeartRate"] = this.secondHeartRate;
        data["thirdHeartRate"] = this.thirdHeartRate;
        data["fourthHeartRate"] = this.fourthHeartRate;
        data["numStairs"] = this.numStairs;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): StairClimbingProtocolDto {
        const json = this.toJSON();
        let result = new StairClimbingProtocolDto();
        result.init(json);
        return result;
    }
}

export interface IStairClimbingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    initialHeartRate: number | undefined;
    secondHeartRate: number | undefined;
    thirdHeartRate: number | undefined;
    fourthHeartRate: number | undefined;
    numStairs: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfTenantDto implements IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTenantDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleDto implements IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adminPassword = data["adminPassword"];
            this.userId = data["userId"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class PagedResultDtoOfUserDto implements IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;
}

export class WalkingProtocolDetailOutput implements IWalkingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IWalkingProtocolDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessment = data["assessment"] ? Assessment.fromJS(data["assessment"]) : <any>undefined;
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WalkingProtocolDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WalkingProtocolDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessment"] = this.assessment ? this.assessment.toJSON() : <any>undefined;
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WalkingProtocolDetailOutput {
        const json = this.toJSON();
        let result = new WalkingProtocolDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IWalkingProtocolDetailOutput {
    assessment: Assessment | undefined;
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class WalkingProtocolDto implements IWalkingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IWalkingProtocolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assessmentId = data["assessmentId"];
            this.clientId = data["clientId"];
            this.timeTaken = data["timeTaken"];
            this.painLevel = data["painLevel"];
            this.comment = data["comment"];
            this.result = data["result"];
            this.status = data["status"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WalkingProtocolDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalkingProtocolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assessmentId"] = this.assessmentId;
        data["clientId"] = this.clientId;
        data["timeTaken"] = this.timeTaken;
        data["painLevel"] = this.painLevel;
        data["comment"] = this.comment;
        data["result"] = this.result;
        data["status"] = this.status;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WalkingProtocolDto {
        const json = this.toJSON();
        let result = new WalkingProtocolDto();
        result.init(json);
        return result;
    }
}

export interface IWalkingProtocolDto {
    assessmentId: string | undefined;
    clientId: string | undefined;
    timeTaken: number | undefined;
    painLevel: number | undefined;
    comment: string | undefined;
    result: string | undefined;
    status: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}